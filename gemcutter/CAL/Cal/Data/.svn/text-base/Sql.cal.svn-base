/*
 * Copyright (c) 2007 BUSINESS OBJECTS SOFTWARE LIMITED
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *  
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *  
 *     * Neither the name of Business Objects nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


/*
 * Sql.cal
 * Creation date: Feb 5, 2004.
 * By: Richard Webster
 */

/**
 * This module provides a combinator library for creating abstract SQL queries.
 * A query is represented by the type {@link typeConstructor = Query@}.
 * 
 * A new, empty query can be created by calling {@link newQuery@}.
 * 
 * {@code
 * qry0 = newQuery;
 * @}
 * 
 * To project a column or a SQL expression, use the {@link project@} function. 
 * There are several variations on this function, such as {@link projectColumn@} and {@link projectWithAliases@}.
 * 
 * {@code
 * qry1 = project qry0 [toUntypedExpr countryField, toUntypedExpr orderDateField]; 
 * @}
 * 
 * To add a restriction to the query, use the {@link restrict@} function.
 * 
 * {@code
 * qry2 = restrict qry1 (eqExpr countryField (stringConstant "Canada"));
 * @}
 * 
 * To add sorting to the query, use the {@link order@} function.
 * 
 * {@code
 * qry3 = order qry2 orderDateField True;
 * @}
 * 
 * To add a join to the query, use the {@link join@} function. 
 * 
 * {@code
 * joinInfo = makeJoinInfo (intField custTable "Customer ID") (intField ordersTable "Customer ID") InnerJoin;
 * qry4 = join qry3 joinInfo;
 * @}
 *      
 * An abstract {@link typeConstructor = Query@} can be converted to a concrete SQL query with the {@link queryText@} function. 
 * This function requires a {@link typeConstructor = SqlBuilder@} for a specific RDBMS as found in the module {@link module = "Cal.Data.SqlBuilder"@}.
 * 
 * See the module {@link module = "Cal.Test.Data.Sql_Tests"@} for examples of query construction.
 * 
 * There is some support for other types of SQL statements, such as ones to create/delete tables and inserting rows.
 * See the {@link Statement@} type.
 * 
 * @author Richard Webster
 */
module Cal.Data.Sql;
import Cal.Core.Prelude using
    typeConstructor = Byte, Int, Double, String, Boolean, Char, Integer, JObject, JList, Maybe, Ordering;
    dataConstructor = False, True, LT, EQ, GT, Nothing, Just;
    typeClass = Eq, Ord, Num, Inputable, Outputable;
    function = 
        append, compare, concat, const, doubleToString, equals, error, fromJust, fst, input,
        intToString, isNothing, isEmpty,  max, mod, not, output, round, seq, snd, toDouble,
        field1, field2, field3, upFrom, upFromTo;
    typeConstructor = Long;
    function = compose, fromMaybe, isJust, listToMaybe, maybeToList, longToString;
    ;
import Cal.Collections.List using  
    function = all, chop, filter, foldLeft, foldLeftStrict, foldRight, head, intersperse,
        last, length, list2, map, outputList, outputListWith, reverse, subscript, sum, tail, take,
        zip, zip3, zipWith;  
    function = any, concatMap, deleteFirsts, drop, elemIndex, isElem, mapIndexed, repeat, removeDuplicates, 
        removeDuplicatesBy, lookupWithDefault, find, groupBy, intersect, isSingletonList, sort;
    ;      
import Cal.Core.String using     
    function = toLowerCase;
    ;        
import Cal.Core.Debug using
    typeClass = Show;
    function = show;
    ;
import Cal.Utilities.TimeZone using
    typeConstructor = TimeZone;
    ;
import Cal.Utilities.Time using
    typeConstructor = Time;
    ;
import Cal.Utilities.PrettyPrinter using
    typeConstructor = Document;
    function = line, multilineText, nest, text;
    ;
import Cal.Data.SqlType using
    typeConstructor = SqlType;
    ;
import Cal.Collections.Set using
    typeConstructor = Set;
    ;
import Cal.Collections.Array using
    typeConstructor = Array;
    ;
import Cal.Data.DatabaseMetadata using
    typeConstructor = DatabaseReference, TableReference, TableDescription, FieldDescription,
                      TableConstraint;
    dataConstructor = PrimaryKeyConstraint, UniqueConstraint, ForeignKeyConstraint;
    function = getTableNameFromReference, makeTableReference;
    ;
import Cal.Utilities.UniqueIdentifier using
    typeConstructor = UniqueIdentifier;
    typeClass = UniquelyNamedItem;
    function = makeUniqueIdentifierByName;
    ;
import Cal.Utilities.Range using
    typeConstructor = Range;
    function = 
        hasLeftEndpoint, hasRightEndpoint, includesLeftEndpoint, 
        includesRightEndpoint, leftEndpoint, rightEndpoint;
    ;

friend Cal.Data.SqlBuilder;


/**
 * Associates a table resource with its alias for the query.
 */
data public QueryTable = 
    /**
     * A reference to an actual database table with a given alias for the query.
     * @arg tableRef    a reference to a database table by name
     * @arg tableAlias  the alias for the table in the query
     */
    private BaseTable 
        tableRef     :: !TableReference 
        tableAlias   :: !String 
    |
    /**
     * A nested SELECT query to be treated as a query table with a given alias.
     * @arg subquery    a database query to be treated as a query table
     * @arg tableAlias  the alias for the nested SELECT 'table' in the query
     */
    private SubQueryTable 
        subquery     :: Query 
        tableAlias   :: !String 
    |
    /**
     * A nested SELECT statement to be treated as a query table with a given alias.
     * @arg subqueryText  the SQL for a SELECT statement to be treated as a query table
     * @arg tableAlias    the alias for the nested SELECT 'table' in the query
     */
    private OpaqueSubQueryTable 
        subqueryText :: String 
        tableAlias   :: !String 
    ;

/**
 * Constructs a query table using the specified table name.
 * The table alias will be based on the table name.
 * @arg tableName  the name of the table to be used in the query
 * @return         a query table for the specified table using the table name as the alias
 */
makeQueryTable :: String -> QueryTable;
public makeQueryTable !tableName = makeQueryTableWithAlias tableName "";

/**
 * Constructs a query table using the specified table name and base alias name.
 * If no table alias is specified, the table name will be used as the alias.
 * @arg tableName   the name of the table to be used in the query
 * @arg tableAlias  the alias to use for the table in the query;
 *                  An empty alias name indicates that the table name should be used as the alias
 * @return          a query table for the specified table and alias
 */
makeQueryTableWithAlias :: String -> String -> QueryTable;
public makeQueryTableWithAlias !tableName !tableAlias = 
    let
        fixedAlias :: String;
        fixedAlias = if (isEmpty tableAlias) then tableName else tableAlias;
    in
        BaseTable (makeTableReference tableName) fixedAlias;

/**
 * Constructs a subquery table using the specified query and alias.
 * This function will remove any ordering from the subquery (unless it is a {@link TopN@}
 * query).
 * @arg subquery    a database query to be treated as a query table
 * @arg tableAlias  the alias to use for the table in the query;
 *                  If an empty alias is specified, then a default one will be generated.
 * @return          a query table for the nested SELECT query with the given alias
 */
makeSubQueryTable :: Query -> String -> QueryTable;
public makeSubQueryTable subquery !tableAlias = 
    let
        fixedAlias :: String;
        fixedAlias = if (isEmpty tableAlias) then "Q" else tableAlias;
    in
        SubQueryTable (fixSubqueryOrdering subquery) fixedAlias;

/**
 * Constructs a subquery table using the specified query text and alias.
 * The query text must be valid when used as a subquery.
 * In most cases, this means that it cannot contain an ORDER BY clause.
 * @arg subqueryText  a SELECT statement text to be treated as a query table
 * @arg tableAlias    the alias to use for the table in the query;
 *                    If an empty alias is specified, then a default one will be generated.
 * @return            a query table for the nested SELECT query with the given alias
 */
makeOpaqueSubQueryTable :: String -> String -> QueryTable;
public makeOpaqueSubQueryTable subqueryText !tableAlias = 
    let
        fixedAlias :: String;
        fixedAlias = if (isEmpty tableAlias) then "Q" else tableAlias;
    in
        OpaqueSubQueryTable subqueryText fixedAlias;

/**
 * Returns whether the specified table is a subquery table.
 * @arg queryTable  a query table
 * @return          True if the table is a subquery (or opaque subquery) table;
 *                  False if the table is a base database table
 */
isSubqueryTable :: QueryTable -> Boolean;
public isSubqueryTable !queryTable = 
    case queryTable of
    (SubQueryTable | OpaqueSubQueryTable) {} -> True;
    _ -> False;
    ;

/**
 * Returns the name of the table (without quotes).
 * An empty string is returned for the name of a subquery table.
 * @arg queryTable  a query table
 * @return          the name of the base database table, 
 *                  or an empty string if the query table is based on a subquery
 */
getQueryTableName :: QueryTable -> String;
public getQueryTableName !queryTable = 
    case queryTable of
    BaseTable {tableRef} -> getTableNameFromReference tableRef;
    _ -> "";
    ;

/**
 * Returns the table alias for a query table.
 * This is a composition of the base alias and the table ID to give a distinct alias for the table.
 * @arg queryTable  a query table
 * @return          the table alias for the query table
 */
getQueryTableAlias :: QueryTable -> String;
public getQueryTableAlias !queryTable = 
    case queryTable of
    (BaseTable | SubQueryTable | OpaqueSubQueryTable) {tableAlias} -> tableAlias;
    ;

/**
 * Query tables can be compared for equality.
 * This is based only on the table aliases, not the actual table information.
 */
instance Eq QueryTable where
    equals = equalsQueryTable;
    notEquals = notEqualsQueryTable;
    ;

equalsQueryTable :: QueryTable -> QueryTable -> Boolean;
private equalsQueryTable table1 table2 = 
    case table1 of
    BaseTable {tableAlias} -> 
        case table2 of
        // TODO: should this compare the tables as well? (This breaks the
        // SqlParser code currently.)
        BaseTable {tableAlias = tableAlias2} -> 
            tableAlias == tableAlias2;
//                && table == table2;
        _ -> False;
        ;
    SubQueryTable {tableAlias} -> 
        case table2 of
        // TODO: should this compare the subqueries as well? (This breaks the
        // SqlParser code currently.)
        SubQueryTable {tableAlias = tableAlias2} ->
            tableAlias == tableAlias2;
//                && subQuery == subQuery2;
        _ -> False;
        ;
    OpaqueSubQueryTable {tableAlias} -> 
        case table2 of
        OpaqueSubQueryTable {tableAlias = tableAlias2} ->
            tableAlias == tableAlias2;
//                && subqueryText == subqueryText2;
        _ -> False;
        ;
    ;

notEqualsQueryTable :: QueryTable -> QueryTable -> Boolean;
private notEqualsQueryTable table1 table2 = not (equalsQueryTable table1 table2);


/**
 * Query tables can be shown.
 * For subquery tables, the subquery text will not be shown since this may be too verbose.
 */
instance Debug.Show QueryTable where
    show = showQueryTable;
    ;

showQueryTable :: QueryTable -> String;
private showQueryTable table = 
    case table of
    BaseTable {tableRef, tableAlias} -> 
        if (getTableNameFromReference tableRef == tableAlias) then tableAlias
        else (show tableRef) ++ " AS " ++ tableAlias;
   (SubQueryTable | 
    OpaqueSubQueryTable) {tableAlias} -> "<subquery> AS " ++ tableAlias;
    ;


/**
 * Options for the query.
 */
data public QueryOption = 
    /**
     * This option indicates that only distinct rows should be returned for the query.
     */
    public Distinct 
    |
    /**
     * This option indicates that the first N rows should be returned.
     * @arg n         the number of rows to be returned
     * @arg percent   if True then the number with be interpretted as a percentage of the full set of rows,
     *                if False then the number will be interpretted as a number of rows
     * @arg withTies  if True then any rows that are considered equivalent order-wise to the Nth row will also be included in the results;
     *                if False then only the first N rows will be returned, even if there are ties
     */
    public TopN 
        n        :: !Int 
        percent  :: !Boolean 
        withTies :: !Boolean
    deriving Eq, Show
    ;

/**
 * Returns whether the query option specifies TopN criteria.
 * @arg option  a query option
 * @return      True if the query option specifies TopN criteria
 */
isTopNOption :: QueryOption -> Boolean;
public isTopNOption !option = 
    case option of
    TopN {} -> True;
    _ -> False;
    ;


/**
 * Information about a join between 2 tables.
 */
data public JoinInfo = 
    /**
     * Information about a join between 2 tables.
     * @arg leftTable       one of the query tables to be joined
     * @arg rightTable      the other query table to be joined
     * @arg fieldJoinExprs  Boolean expressions joining fields from the tables
     * @arg joinType        the type of join being performed (inner, left outer, right outer, or full outer)
     */
    private JoinInfo 
        leftTable      :: !QueryTable 
        rightTable     :: !QueryTable 
        fieldJoinExprs :: [TypedExpr Boolean] 
        joinType       :: !JoinType 
    deriving Eq
    ;


/**
 * Creates a join info using the query field info specified.
 * The expressions provided must both be {@link QueryField@}s.
 * The link expressions will be created to compare each pair of fields using
 * {@code '='@}.
 * If other link comparison are required, the {@link typeConstructor = JoinInfo@} can be constructed with
 * these explicitly.
 * @arg leftField   an expression for a field in the left table to be joined
 * @arg rightField  an expression for a field in the right table to be joined
 * @arg joinType    the type of join being performed (inner, left outer, right outer, or full outer)
 * @return          join info between the specified table fields
 */
makeJoinInfo :: Eq a => TypedExpr a -> TypedExpr a -> JoinType -> JoinInfo;
public makeJoinInfo !leftField !rightField !joinType =
    let
        tableFromQueryField fieldExpr = 
            case (toUntypedExpr fieldExpr) of
            QueryField {queryTable} -> queryTable;
            _ -> error ("The join fields must be QueryFields");
            ;

        leftTable :: QueryTable;
        leftTable  = tableFromQueryField leftField;

        rightTable :: QueryTable;
        rightTable = tableFromQueryField rightField;

        fieldJoinExpr :: TypedExpr Boolean;
        fieldJoinExpr = eqExpr leftField rightField;
    in
        JoinInfo leftTable rightTable [fieldJoinExpr] joinType;

/**
 * Creates a join info between 2 tables using the specified linking expression.
 * @arg leftTable    one of the query tables to be joined
 * @arg rightTable   the other query table to be joined
 * @arg linkingExpr  a Boolean expression joining fields from the tables
 * @arg joinType     the type of join being performed (inner, left outer, right outer, or full outer)
 */
makeJoinInfo2 :: QueryTable -> QueryTable -> TypedExpr Boolean -> JoinType -> JoinInfo;
public makeJoinInfo2 !leftTable !rightTable linkingExpr !joinType = 
    JoinInfo leftTable rightTable [linkingExpr] joinType;


/**
 * The types of joins that can be performed between two tables.
 */
data public JoinType = 
    /**
     * The inner join option indicates that rows should be returned where 
     * the join condition between the table is satisfied.
     */
    public InnerJoin 
    |
    /**
     * The left outer join option indicates that all rows from the left table should 
     * be included along with values from the right table where the join condition is satisfied.
     */
    public LeftOuterJoin 
    | 
    /**
     * The right outer join option indicates that all rows from the right table should 
     * be included along with values from the left table where the join condition is satisfied.
     */
    public RightOuterJoin
    |
    /**
     * The full outer join option indicates that all rows satisfying the join condition should be returned
     * as well as any unmatched rows from both the left and right tables.
     */
    public FullOuterJoin
    deriving Eq, Show
    ;

/**
 * A binary tree structure for representing joins.
 */
data public JoinNode = 
    /**
     * A node representing a single query table.
     * @arg table  a query table
     */
    public JoinTable 
        table       :: QueryTable 
    |
    /**
     * A node specifying a join between tables in two join trees.
     * @arg leftNode     one of the join trees to be joined
     * @arg rightNode    the other join tree to be joined
     * @arg linkingExpr  a Boolean expression joining tables in the join trees
     * @arg joinType     the type of join to be performed
     */
    public JoinSubtree 
        leftNode    :: JoinNode 
        rightNode   :: JoinNode 
        linkingExpr :: (TypedExpr Boolean) 
        joinType    :: JoinType  
    deriving Eq
    ;

/**
 * Join nodes can be shown.
 */
instance Debug.Show JoinNode where
    show = showJoinNode;
    ;

showJoinNode :: JoinNode -> String;
private showJoinNode !node = 
    case node of
    JoinTable joinTable -> show joinTable;
    JoinSubtree {leftNode, rightNode} -> "{" ++ (showJoinNode leftNode) ++ " -> " ++ (showJoinNode rightNode) ++ "}";
    ;


/**
 * A named set of joins.
 */
data public JoinSet = 
    /**
     * A named set of joins.
     * @arg name   the name of the join set
     * @arg joins  the root join of the join set
     */
    private JoinSet 
        name  :: !String 
        joins :: JoinNode
    deriving Show
    ;

/**
 * Construct a join set from a list of JoinInfo values.
 * @arg name   the name of the join set
 * @arg joins  the joins to be part of the set
 * @return     a join set with the specified name
 */
makeJoinSet :: String -> [JoinInfo] -> JoinSet;
public makeJoinSet !name joins = 
    makeJoinSet2 name (buildJoinTree joins);

/**
 * Construct a join set from a JoinNode tree
 * @arg name      the name of the join set
 * @arg joinTree  the root join of the join set
 * @return        a join set with the specified name
 */
makeJoinSet2 :: String -> JoinNode -> JoinSet;
public makeJoinSet2 !name joinTree = 
    JoinSet name joinTree;

/**
 * Returns the join info from the join set.
 * @arg joinSet  a join set
 * @return       the root join node of the set
 */
joinSetJoinTree :: JoinSet -> JoinNode;
public joinSetJoinTree !joinSet = 
    joinSet.JoinSet.joins;

// Implement the UniquelyNamedItem class.
instance UniquelyNamedItem JoinSet where
    getDisplayName = joinSetName;
    getUniqueIdentifier = joinSetUniqueIdentifier;
    ;

joinSetName !joinSet = joinSet.JoinSet.name;
joinSetUniqueIdentifier !joinSet = makeUniqueIdentifierByName (joinSetName joinSet);


/**
 * A database expression.
 */
data public Expr = 
    /**
     * A reference to a field in a query table.
     * @arg fieldName   the name of the field
     * @arg queryTable  the query table
     */
    private QueryField 
        fieldName     :: String 
        queryTable    :: QueryTable
    |
    /**
     * A literal value expression.
     * @arg constantValue  the constant value
     */
    private ConstExpr 
        constantValue :: ConstValue
    |
    /**
     * A parameter placeholder expression.
     * @arg parameter  the database parameter
     */
    private ParameterExpr
        parameter     :: Parameter
    |
    /**
     * A list of database expressions.
     * @arg listValues  the list of expressions
     */
    private ListExpr 
        listValues    :: [Expr]
    |
    /**
     * A function expression.
     * @arg func       an identifier for the database function
     * @arg arguments  the function argument expressions
     */
    private FunctionExpr 
        func          :: DbFunction 
        arguments     :: [Expr]
    |
    /**
     * A subquery expression.
     * The subquery must have a single projected column.
     * @arg subquery  the subquery to be treated as a database expression
     */
    private SubQueryExpr 
        subquery      :: Query
    deriving Eq, Show
    ;

/**
 * Returns {@link True@} if the expression represents a list.
 * @arg expr  a database expression
 * @return    {@link True@} if the expression represents a list; {@link False@} otherwise
 */
isListExpr :: Expr -> Boolean;
public isListExpr !expr = 
    case expr of
    ListExpr {} -> True;
    _ -> False;
    ;

/**
 * Returns the value expressions from a list expression.
 * An exception will be thrown if the expression is not a list expression.
 * @arg expr  a database expression
 * @return    the list of value expressions form a list expression
 */
getListFromListExpr :: Expr -> [Expr];
public getListFromListExpr !expr =
    case expr of
    ListExpr {listValues} -> listValues;
    _ -> error "Not a list expression";
    ;

/**
 * Returns {@link True@} if the expression represents a constant containing a string value.
 * @arg expr  a database expression
 * @return    {@link True@} if the expression represents a string literal; {@link False@} otherwise
 */
isStringConstExpr :: Expr -> Boolean;
public isStringConstExpr !expr = 
    case expr of
    ConstExpr {constantValue} ->
        case constantValue of
        StringValue {} -> True;
        _ -> False;
        ;
    _ -> False;
    ;

/**
 * Returns the string value from a constant expression.
 * An exception will be thrown if the expression is not a string constant expression.
 * @arg expr  a database expression
 * @return    the string value from the constant database expression
 */
getStringValueFromConstExpr :: Expr -> String;
public getStringValueFromConstExpr !expr =
    case expr of
    ConstExpr {constantValue} -> 
        case constantValue of
        StringValue {strValue} -> strValue;
        _ -> error "Not a string constant expression";
        ;
    _ -> error "Not a constant expression";
    ;

/**
 * Returns {@link True@} if the expression represents a constant containing a number value.
 * @arg expr  a database expression
 * @return    {@link True@} if the expression represents a numeric literal; {@link False@} otherwise
 */
isNumberConstExpr :: Expr -> Boolean;
public isNumberConstExpr !expr = 
    case expr of
    ConstExpr {constantValue} ->
        case constantValue of
        NumberValue {} -> True;
        _ -> False;
        ;
    _ -> False;
    ;

/**
 * Returns the number value from a constant expression.
 * An exception will be thrown if the expression is not a numeric constant expression.
 * @arg expr  a database expression
 * @return    the numeric value from the constant database expression
 */
getNumberValueFromConstExpr :: Expr -> Double;
public getNumberValueFromConstExpr !expr =
    case expr of
    ConstExpr {constantValue} -> 
        case constantValue of
        NumberValue {numValue} -> numValue;
        _ -> error "Not a number constant expression";
        ;
    _ -> error "Not a constant expression";
    ;

/**
 * Returns {@link True@} if the expression represents a constant containing a boolean value.
 * @arg expr  a database expression
 * @return    {@link True@} if the expression represents a Boolean constant; {@link False@} otherwise
 */
isBooleanConstExpr :: Expr -> Boolean;
public isBooleanConstExpr !expr = 
    case expr of
    ConstExpr {constantValue} ->
        case constantValue of
        BooleanValue {} -> True;
        _ -> False;
        ;
    _ -> False;
    ;

/**
 * Returns the boolean value from a constant expression.
 * An exception will be thrown if the expression is not a constant Boolean expression.
 * @arg expr  a database expression
 * @return    the Boolean value from the constant database expression
 */
getBooleanValueFromConstExpr :: Expr -> Boolean;
public getBooleanValueFromConstExpr !expr =
    case expr of
    ConstExpr {constantValue} -> 
        case constantValue of
        BooleanValue {boolValue} -> boolValue;
        _ -> error "Not a boolean constant expression";
        ;
    _ -> error "Not a constant expression";
    ;

/**
 * Returns {@link True@} if the expression represents a constant containing a time value.
 * @arg expr  a database expression
 * @return    {@link True@} if the expression represents a time constant; {@link False@} otherwise
 */
isTimeConstExpr :: Expr -> Boolean;
public isTimeConstExpr !expr = 
    case expr of
    ConstExpr {constantValue} ->
        case constantValue of
        TimeValue {} -> True;
        _ -> False;
        ;
    _ -> False;
    ;

/**
 * Returns the time value from a constant expression.
 * An exception will be thrown if the expression is not a time constant expression.
 * @arg expr  a database expression
 * @return    the time value from the constant database expression
 */
getTimeValueFromConstExpr :: Expr -> Time;
public getTimeValueFromConstExpr !expr =
    case expr of
    ConstExpr {constantValue} -> 
        case constantValue of
        TimeValue {timeValue} -> timeValue;
        _ -> error "Not a time constant expression";
        ;
    _ -> error "Not a constant expression";
    ;

/**
 * Returns {@link True@} if the expression represents a field in a query table.
 * @arg expr  a database expression
 * @return    {@link True@} if the expression represents a field in a query table; {@link False@} otherwise
 */
isQueryFieldExpr :: Expr -> Boolean;
public isQueryFieldExpr !expr = 
    case expr of
    QueryField {} -> True;
    _ -> False;
    ;

/**
 * Returns the query table from a query field expression.
 * An exception will be thrown if the expression is not a query field expression.
 * @arg expr  a database expression
 * @return    the field name from the query field expression
 */
getFieldNameFromQueryFieldExpr :: Expr -> String;
public getFieldNameFromQueryFieldExpr !expr =
    case expr of
    QueryField {fieldName} -> fieldName;
    _ -> error "Not a query field expression";
    ;

/**
 * Returns the field name from a query field expression.
 * An exception will be thrown if the expression is not a query field expression.
 * @arg expr  a database expression
 * @return    the query table from the query field expression
 */
getQueryTableFromQueryFieldExpr :: Expr -> QueryTable;
public getQueryTableFromQueryFieldExpr !expr =
    case expr of
    QueryField {queryTable} -> queryTable;
    _ -> error "Not a query field expression";
    ;

/**
 * Returns {@link True@} if the expression represents a function (or operator)
 * application.
 * @arg expr  a database expression
 * @return    {@link True@} if the expression represents a database function expression; {@link False@} otherwise
 */
isFunctionExpr :: Expr -> Boolean;
public isFunctionExpr !expr =
    case expr of
    FunctionExpr {} -> True;
    _ -> False;
    ;

/**
 * Returns the function type from a function expression.
 * An exception will be thrown if the expression is not a function expression.
 * @arg expr  a database expression
 * @return    the function identifier from the function expression
 */
getFunctionFromFunctionExpr :: Expr -> DbFunction;
public getFunctionFromFunctionExpr !expr =
    case expr of
    FunctionExpr {func} -> func;
    _ -> error "Not a function expression";
    ;

/**
 * Returns the arguments from a function expression.
 * An exception will be thrown if the expression is not a function expression.
 * @arg expr  a database expression
 * @return    the argument expressions from the function expression
 */
getArgumentsFromFunctionExpr :: Expr -> [Expr];
public getArgumentsFromFunctionExpr !expr =
    case expr of
    FunctionExpr {arguments} -> arguments;
    _ -> error "Not a function expression";
    ;

/**
 * Returns whether the expression represents an operator applied to one or more
 * arguments.
 * @arg expr  a database expression
 * @return    {@link True@} if the expression represents an operator applied to one or
 *            more arguments; {@link False@} otherwise
 */
isOperatorExpr :: Expr -> Boolean;
public isOperatorExpr !expr =
    case expr of
    FunctionExpr {func} -> isOperator func;
    _ -> False;
    ;


/**
 * {@code TypedExpr@} wraps an untyped {@link Expr@} and adds information about the expression
 * data type.
 */
data public TypedExpr a = 
    private TypedExpr 
        untypedExpr :: Expr
    ;

/**
 * Returns the untyped expression from a typed expression.
 * @arg typedExpr  a typed database expression
 * @return         the untyped database expression
 */
toUntypedExpr :: TypedExpr a -> Expr;
public toUntypedExpr !typedExpr = typedExpr.TypedExpr.untypedExpr;

/**
 * Returns a typed expression from the untyped expression.
 * @arg untypedExpr  an untyped database expression
 * @return           the typed database expression
 */
toTypedExpr :: Expr -> TypedExpr a;
public toTypedExpr = TypedExpr;


/**
 * Returns the type of the values represented by this typed expression.
 * @arg expr  a database expression
 * @return    the type of the database expression
 */
typeOfExpr :: Prelude.Typeable a => TypedExpr a -> Prelude.TypeRep;
public typeOfExpr !expr = 
    head (Prelude.typeArguments (Prelude.typeOf expr));

// Allow typed expressions to be compared for equality.
instance Eq (TypedExpr a) where
    equals = equalsTypedExpr;
    notEquals = notEqualsTypedExpr;
    ;

// Allow typed expressions to be shown.
instance Show (TypedExpr a) where
    show = showTypedExpr;
    ;

showTypedExpr :: TypedExpr a -> String;
showTypedExpr !typedExpr = 
    show typedExpr.TypedExpr.untypedExpr;

/**
 * Checks whether 2 typed expressions are equal.
 */
private equalsTypedExpr !expr1 !expr2 = 
    (toUntypedExpr expr1) == (toUntypedExpr expr2);

private notEqualsTypedExpr !expr1 !expr2 = 
    not (equalsTypedExpr expr1 expr2);


/**
 * A constant value.
 */
data private ConstValue = 
    private NullValue
    |
    private StringValue
        strValue::String
    |
    private NumberValue
        numValue::Double
    |
    private BooleanValue
        boolValue::Boolean
    |
    private TimeValue
        timeValue::Time
    deriving Eq, Show
    ;

/**
 * Construct a database expression for a string literal.
 * @arg strValue  the string literal value
 * @return        the database expression for the string literal
 */
stringConstant :: String -> TypedExpr String;
public stringConstant strValue = 
    TypedExpr (ConstExpr (StringValue strValue));

/**
 * Construct a database expression for a numeric literal.
 * @arg numValue  the numeric literal value
 * @return        the database expression for the numeric literal
 */
numericConstant :: Num a => a -> TypedExpr a;
public numericConstant numValue = 
    TypedExpr (ConstExpr (NumberValue (toDouble numValue)));

/**
 * Construct a database expression for a Boolean value.
 * @arg boolValue  the Boolean value
 * @return         the database expression for the Boolean value
 */
booleanConstant :: Boolean -> TypedExpr Boolean;
public booleanConstant !boolValue = 
    if boolValue then trueConstant else falseConstant;

/**
 * A database expression for the Boolean value True.
 * @return  the database expression for the Boolean value True
 */
trueConstant :: TypedExpr Boolean;
public trueConstant = 
    TypedExpr (ConstExpr (BooleanValue True));

/**
 * A database expression for the Boolean value False.
 * @return  the database expression for the Boolean value False
 */
falseConstant :: TypedExpr Boolean;
public falseConstant = 
    TypedExpr (ConstExpr (BooleanValue False));

/**
 * Construct a database expression for a time literal.
 * @arg timeValue  the time literal value
 * @return         the database expression for the time literal
 */
timeConstant :: Time -> TypedExpr Time;
public timeConstant timeValue = 
    TypedExpr (ConstExpr (TimeValue timeValue));

/**
 * A database expression for a null value of some data type.
 * @return  a database expression for a null value
 */
nullValue :: TypedExpr a;
public nullValue = 
    TypedExpr (ConstExpr NullValue);

/**
 * Tests whether an untyped expression has the constant value of null.
 * This does not check whether an expression evaluates to null -- it simply
 * checks whether it has the constant value of null.
 * @arg expr  a database expression
 * @return    True if the expression has the constant value of null
 */
isNullValue :: Expr -> Boolean;
public isNullValue !expr = 
    case expr of
    ConstExpr {constantValue} -> 
        case constantValue of
        NullValue -> True;
        _ -> False;
        ;
    _ -> False;
    ;

/**
 * A database parameter that can be used in place of a value in a SQL statement.
 * The parameter values can be bound in when executing the SQL statement.
 * This is often used to execute the same statement multiple times with different values.
 */
data private Parameter = 
    /**
     * A parameter without a name.
     * The values for unnamed parameters will be bound based on the position of the
     * parameter in the SQL statement.
     */
    private UnnamedParameter 
    |
    /**
     * A parameter with an associated name.
     * Note: JDBC 3.0 only supports named parameter for CallableStatement.
     */
    private NamedParameter 
        name :: String
    deriving Eq, Show
    ;

/**
 * Returns whether the parameter is a named one.
 * @arg param  a database parameter
 * @return     True if the parameter is named one; False if the parameter is unnamed
 */
isUnnamedParameter :: Parameter -> Boolean;
public isUnnamedParameter !param =
    case param of
    UnnamedParameter -> True;
    _ -> False;
    ;

/**
 * Returns the name of a named parameter.
 * An error will be thrown if the parameter is unnamed.
 * @arg param  a database parameter
 * @return     the name of the named database parameter
 */
getParameterName :: Parameter -> String;
public getParameterName !param =
    case param of
    NamedParameter {name} -> name;
    _ -> error "Only a named parameter has a name!";
    ;

/**
 * Constructs an string expression for a database parameter.
 * If Nothing is specified for the name, then the parameter will be an unnamed one.
 * @arg maybeParamName  an optional name for the parameter
 * @return              a string database expression for a database parameter
 */
stringParameter :: Maybe String -> TypedExpr String;
public stringParameter !maybeParamName = TypedExpr $ untypedParameter maybeParamName;

/**
 * Constructs an integer expression for a database parameter.
 * If Nothing is specified for the name, then the parameter will be an unnamed one.
 * @arg maybeParamName  an optional name for the parameter
 * @return              a integer database expression for a database parameter
 */
integerParameter :: Maybe String -> TypedExpr Int;
public integerParameter !maybeParamName = TypedExpr $ untypedParameter maybeParamName;

/**
 * Constructs an double expression for a database parameter.
 * If Nothing is specified for the name, then the parameter will be an unnamed one.
 * @arg maybeParamName  an optional name for the parameter
 * @return              a double database expression for a database parameter
 */
doubleParameter :: Maybe String -> TypedExpr Double;
public doubleParameter !maybeParamName = TypedExpr $ untypedParameter maybeParamName;

/**
 * Constructs an Boolean expression for a database parameter.
 * If Nothing is specified for the name, then the parameter will be an unnamed one.
 * @arg maybeParamName  an optional name for the parameter
 * @return              a Boolean database expression for a database parameter
 */
booleanParameter :: Maybe String -> TypedExpr Boolean;
public booleanParameter !maybeParamName = TypedExpr $ untypedParameter maybeParamName;

/**
 * Constructs an time expression for a database parameter.
 * If Nothing is specified for the name, then the parameter will be an unnamed one.
 * @arg maybeParamName  an optional name for the parameter
 * @return              a time database expression for a database parameter
 */
timeParameter :: Maybe String -> TypedExpr Time;
public timeParameter !maybeParamName = TypedExpr $ untypedParameter maybeParamName;

/**
 * Constructs an untyped expression for a database parameter.
 * If Nothing is specified for the name, then the parameter will be an unnamed one.
 * @arg maybeParamName  an optional name for the parameter
 * @return              a database expression for a database parameter
 */
untypedParameter :: Maybe String -> Expr;
private untypedParameter !maybeParamName =
    case maybeParamName of
    Just paramName -> ParameterExpr $ NamedParameter paramName;
    Nothing        -> ParameterExpr $ UnnamedParameter;
    ;

/**
 * Constructs an untyped database expression for a list of values.
 * @arg listValues  a list of database expressions for the list value
 * @return          an untyped database expression for the list of values
 */
untypedListExpr :: [Expr] -> Expr;
public untypedListExpr listValues = ListExpr listValues;

/**
 * Constructs a typed database expression for a list of values.
 * This probably doesn't need to be exposed since it can only be used with 
 * the IN binary operator anyway.
 * @arg listValues  a list of database expressions for the list value
 * @return          a typed database expression for the list of values
 */
listExpr :: [TypedExpr a] -> TypedExpr [a];
private listExpr listValues = TypedExpr (ListExpr (map toUntypedExpr listValues));


/**
 * Creates a database expression based on a subquery.
 * Any ordering will be removed from the subquery (unless it uses {@link TopN@}).
 * The subquery must have a single projected column.
 * @arg subquery  the subquery to be treated as a database expression
 * @return        a database expression based on the subquery
 */
subQueryExpr :: Query -> Expr;
public subQueryExpr !subquery = 
    let
        // Remove any ordering from the subquery (unless it uses TopN).
        fixedSubquery = fixSubqueryOrdering subquery;
    in
        // Check that there is only 1 return column in the subquery.
        // TODO: is there a way to make this typed based on the (one and only) result column in the query?
        if (isSingletonList (getProjectedColumns fixedSubquery)) then SubQueryExpr fixedSubquery
        else error "Only subqueries returning a single column can be used as field expressions";


/**
 * Database expression functions and operators.
 */
data public DbFunction = 
    
    // Unary operators.
    public OpNot | public OpBitNot | public OpNegate
    | public OpIsNull | public OpIsNotNull
    | public OpExists
    
    // Binary operators
    | public OpEq | public OpLt | public OpLtEq | public OpGt | public OpGtEq | public OpNotEq 
    | public OpAnd | public OpOr
    | public OpLike | public OpIn
    | public OpCat
    | public OpPlus | public OpMinus | public OpMul | public OpDiv | public OpMod
    | public OpBitAnd | public OpBitOr | public OpBitXor
    
    // Other operators
    | public OpBetween | public OpCase_Simple | public OpCase_Searched

    // Conversion functions
    | public ConvertToStringFunction 
    | public ConvertToIntFunction 
    | public ConvertToDoubleFunction
    | public ConvertToTimeFunction

    // Numeric functions
    | public AbsFunction | public AcosFunction | public AsinFucntion | public AtanFunction | public Atan2Function
    | public CeilingFunction | public CosFunction | public CotFunction | public DegreesFunction | public ExpFunction
    | public FloorFunction | public LogFunction | public Log10Function | public ModFunction | public PiFunction
    | public PowerFunction | public RadiansFunction | public RandFunction | public RoundFunction | public SignFunction
    | public SinFunction | public SqrtFunction | public TanFunction | public TruncateFunction

    // String functions
    | public AsciiFunction | public CharFunction | public DifferenceFunction
    | public InsertFunction| public LcaseFunction | public LeftFunction | public LengthFunction | public LocateFunction
    | public LtrimFunction | public RepeatFunction | public ReplaceFunction | public RightFunction | public RtrimFunction
    | public SoundexFunction | public SpaceFunction | public SubstringFunction | public UcaseFunction

    // System functions
    | public DatabaseFunction | public UserFunction

    // Null-handling functions
    | public IfNullFunction | public NullIfFunction 

    // DateTime functions
    | public DayNameFunction | public DayOfWeekFunction | public DayOfMonthFunction | public DayOfYearFunction | public HourFunction | public MinuteFunction
    | public MonthFunction | public MonthNameFunction | public NowFunction | public QuarterFunction | public SecondFunction
    | public WeekFunction | public YearFunction
    | public DateTimeAddFunction timeInterval :: TimeInterval
    | public DateTimeDiffFunction timeInterval :: TimeInterval

    // Aggregation functions.
    | public AggrCount | public AggrSum | public AggrAvg | public AggrMin | public AggrMax
    | public AggrDistinctCount | public AggrDistinctSum | public AggrDistinctAvg
    | public AggrCountAll
    | public AggrStdDev | public AggrStdDevP | public AggrVar | public AggrVarP
    | public AggrOther  other :: String

    // A function with the specified name.
    | public FunctionOther funcName :: String

    deriving Eq, Show
    ;

/**
 * Possible time interval values for working with date/time values.
 */
data public TimeInterval = 
    public YearInterval 
    | public QuarterInterval
    | public MonthInterval
    | public DayInterval
    | public HourInterval
    | public MinuteInterval
    | public SecondInterval
    deriving Eq, Show
    ;

/**
 * Indicates whether a specified function is an aggregation function or not.
 * @arg fn  a database function identifier
 * @return  True if the specified function is an aggregation function
 */
isAggregationFunction :: DbFunction -> Boolean;
public isAggregationFunction !fn = 
    case fn of
   (AggrCount |
    AggrSum |
    AggrAvg |
    AggrMin |
    AggrMax |
    AggrDistinctCount |
    AggrDistinctSum   |
    AggrDistinctAvg   |
    AggrCountAll |
    AggrStdDev |
    AggrStdDevP |
    AggrVar |
    AggrVarP |
    AggrOther) {} -> True;
    _ -> False;
    ;

/**
 * Returns the default name of a database function.
 */
defaultFunctionName :: DbFunction -> String;
public defaultFunctionName !func =
    case func of
//    ConvertFunction -> "CONVERT";

    AbsFunction     -> "ABS";
    AcosFunction    -> "ACOS";
    AsinFucntion    -> "ASIN";
    AtanFunction    -> "ATAN";
    Atan2Function   -> "ATAN2";
    CeilingFunction -> "CEILING";
    CosFunction     -> "COS";
    CotFunction     -> "COT";
    DegreesFunction -> "DEGREES";
    ExpFunction     -> "EXP";
    FloorFunction   -> "FLOOR";
    LogFunction     -> "LOG";
    Log10Function   -> "LOG10";
    ModFunction     -> "MOD";
    PiFunction      -> "PI";
    PowerFunction   -> "POWER";
    RadiansFunction -> "RADIANS";
    RandFunction    -> "RAND";
    RoundFunction   -> "ROUND";
    SignFunction    -> "SIGN";
    SinFunction     -> "SIN";
    SqrtFunction    -> "SQRT";
    TanFunction     -> "TAN";
    TruncateFunction -> "TRUNCATE";

    AsciiFunction   -> "ASCII";
    CharFunction    -> "CHAR";
// TODO: use the OpCat operator instead...
//    ConcatFunction  -> "CONCAT";
    DifferenceFunction -> "DIFFERENCE";
    InsertFunction  -> "INSERT";
    LcaseFunction   -> "LCASE";
    LeftFunction    -> "LEFT";
    LengthFunction  -> "LENGTH";
    LocateFunction  -> "LOCATE";
    LtrimFunction   -> "LTRIM";
    RepeatFunction  -> "REPEAT";
    ReplaceFunction -> "REPLACE";
    RightFunction   -> "RIGHT";
    RtrimFunction   -> "RTRIM";
    SoundexFunction -> "SOUNDEX";
    SpaceFunction   -> "SPACE";
    SubstringFunction -> "SUBSTRING";
    UcaseFunction   -> "UCASE";
    DatabaseFunction -> "DATABASE";
    IfNullFunction  -> "IFNULL";
    NullIfFunction  -> "NULLIF";
    UserFunction    -> "USER";

    DayNameFunction -> "DAYNAME";
    DayOfWeekFunction -> "WEEKDAY";
    DayOfMonthFunction -> "DAY";
    DayOfYearFunction -> "DAYOFYEAR";
    HourFunction    -> "HOUR";
    MinuteFunction  -> "MINUTE";
    MonthFunction   -> "MONTH";
    MonthNameFunction -> "MONTHNAME";
    NowFunction     -> "NOW";
    QuarterFunction -> "QUARTER";
    SecondFunction  -> "SECOND";
//    TimestampAddFunction -> "TIMESTAMPADD";
//    TimestampDiffFunction -> "TIMESTAMPDIFF";
    WeekFunction    -> "WEEK";
    YearFunction    -> "YEAR";
    DateTimeAddFunction {} -> "DATEADD";
    DateTimeDiffFunction {} -> "DATEDIFF";

    AggrCount       -> "COUNT";
    AggrSum         -> "SUM";
    AggrAvg         -> "AVG";
    AggrMin         -> "MIN";
    AggrMax         -> "MAX";
    AggrStdDev      -> "STDDEV";
    AggrStdDevP     -> "STDDEVP";
    AggrVar         -> "VAR";
    AggrVarP        -> "VARP";
    AggrOther {other} -> other;

    // Note:  the following block of functions are generated specially, but names are included here for
    //        purposes of outputing to Java.
    AggrDistinctCount -> "DISTINCT COUNT";
    AggrDistinctSum   -> "DISTINCT SUM";
    AggrDistinctAvg   -> "DISTINCT AVG";
    AggrCountAll      -> "COUNT ALL";     

    FunctionOther {funcName} -> funcName;
    ;


//////////////////////////////////////////////////////////////////////////////////////////////////////
// SQL Functions

/**
 * Constructs an untyped database expression for a call to a database function.
 * No checking will be done for the number or types of the arguments.
 * Where possible the appropriate type-safe function should be called to construct the 
 * function expression.
 * @arg func       an identifier for a database function
 * @arg arguments  a list of database expressions for the function arguments
 * @return         an untyped database expression for a call to the database function
 */
untypedFunctionExpr :: DbFunction -> [Expr] -> Expr;
public untypedFunctionExpr func arguments = FunctionExpr func arguments;

// Helper functions to construct typed function expressions.
// These should not be exposed.
functionExpr0 :: DbFunction -> TypedExpr a;
private functionExpr0 func = TypedExpr (untypedFunctionExpr func []);

functionExpr1 :: DbFunction -> TypedExpr a -> TypedExpr b;
private functionExpr1 func arg1 = TypedExpr (untypedFunctionExpr func [toUntypedExpr arg1]);

functionExpr2 :: DbFunction -> TypedExpr a -> TypedExpr b -> TypedExpr c;
private functionExpr2 func arg1 arg2 = TypedExpr (untypedFunctionExpr func [toUntypedExpr arg1, toUntypedExpr arg2]);

functionExpr3 :: DbFunction -> TypedExpr a -> TypedExpr b -> TypedExpr c -> TypedExpr d;
private functionExpr3 func arg1 arg2 arg3 = TypedExpr (untypedFunctionExpr func [toUntypedExpr arg1, toUntypedExpr arg2, toUntypedExpr arg3]);

functionExpr4 :: DbFunction -> TypedExpr a -> TypedExpr b -> TypedExpr c -> TypedExpr d -> TypedExpr e;
private functionExpr4 func arg1 arg2 arg3 arg4 = TypedExpr (untypedFunctionExpr func [toUntypedExpr arg1, toUntypedExpr arg2, toUntypedExpr arg3, toUntypedExpr arg4]);


//////////////////////////////////////////////////////////////////////////////////////////////////////
// Unary operator expressions

/**
 * Constructs an untyped database expression for the application of a unary operator.
 * No checking will be done for the type of the argument.
 * Where possible the appropriate type-safe function should be called to construct the 
 * function expression.
 * @arg func      an identifier for a unary operator
 * @arg argument  a database expression to which the unary operator will be applied
 * @return        an untyped database expression for the application of the unary operator
 */
untypedUnaryExpr :: DbFunction -> Expr -> Expr;
public untypedUnaryExpr func argument = FunctionExpr func [argument];

/**
 * Constructs a database expression for the application of the 'not' operator to a Boolean argument.
 * @arg boolExpr  a Boolean database expression
 * @return        a Boolean database expression for the application of the 'not' operator to the argument expression
 */
notExpr :: TypedExpr Boolean -> TypedExpr Boolean;
public notExpr = functionExpr1 OpNot;

/**
 * Constructs a database expression for the application of the bitwise 'not' operator to an integer argument.
 * @arg intExpr  an integer database expression
 * @return       an integer database expression for the application of the bitwise 'not' operator to the argument expression
 */
bitwiseNotExpr :: TypedExpr Int -> TypedExpr Int;
public bitwiseNotExpr = functionExpr1 OpBitNot;

/**
 * Constructs a database expression for the negation of the numeric argument expression.
 * @arg numExpr  a numeric database expression
 * @return       a numeric database expression for the negation of the argument expression
 */
negateExpr :: Num a => TypedExpr a -> TypedExpr a;
public negateExpr = functionExpr1 OpNegate;

/**
 * Constructs a database expression to test whether an argument expression is null.
 * @arg expr  a database expression
 * @return    a Boolean database expression to test test whether an argument expression is null
 */
isNullExpr :: TypedExpr a -> TypedExpr Boolean;
public isNullExpr = functionExpr1 OpIsNull;

/**
 * Constructs a database expression to test whether an argument expression is non-null.
 * @arg expr  a database expression
 * @return    a Boolean database expression to test test whether an argument expression is non-null
 */
isNotNullExpr :: TypedExpr a -> TypedExpr Boolean;
public isNotNullExpr = functionExpr1 OpIsNotNull;

/**
 * Constructs a database expression to test whether the argument subquery expression returns any rows.
 * @arg subqueryExpr  a subquery expressoin
 * @return            a Boolean database expression to test whether the argument subquery expression returns any rows
 */
existsExpr :: TypedExpr [a] -> TypedExpr Boolean;
public existsExpr subqueryExpr = 
    // TODO: is there any way to make this only accept subqueries?
    functionExpr1 OpExists subqueryExpr;


//////////////////////////////////////////////////////////////////////////////////////////////////////
// Binary operator expressions

/**
 * Constructs an untyped database expression for the application of a binary operator.
 * No checking will be done for the types of the arguments.
 * Where possible the appropriate type-safe function should be called to construct the 
 * function expression.
 * @arg func           an identifier for a binary operator
 * @arg leftArgument   a database expression for the left argument to which the operator will be applied
 * @arg rightArgument  a database expression for the right argument to which the operator will be applied
 * @return             an untyped database expression for the application of the binary operator
 */
untypedBinaryExpr :: DbFunction -> Expr -> Expr -> Expr;
public untypedBinaryExpr func leftArgument rightArgument = FunctionExpr func [leftArgument, rightArgument];

/**
 * Constructs a database expression which test two operand expressions for equality.
 * @arg expr1  a database expression for the first operand
 * @arg expr2  a database expression for the second operand
 * @return     a Boolean database expression to test the operand expressions for equality
 */
eqExpr :: Eq a => TypedExpr a -> TypedExpr a -> TypedExpr Boolean;
public eqExpr = functionExpr2 OpEq;

/**
 * Constructs a database expression which tests two operand expressions for inequality.
 * @arg expr1  a database expression for the first operand
 * @arg expr2  a database expression for the second operand
 * @return     a Boolean database expression to test the operand expressions for inequality
 */
notEqExpr :: Eq a => TypedExpr a -> TypedExpr a -> TypedExpr Boolean;
public notEqExpr = functionExpr2 OpNotEq;

/**
 * Constructs a database expression to test whether the first operand is less than the second.
 * @arg expr1  a database expression for the first operand
 * @arg expr2  a database expression for the second operand
 * @return     a Boolean database expression to test whether the first operand is less than the second
 */
ltExpr :: Ord a => TypedExpr a -> TypedExpr a -> TypedExpr Boolean;
public ltExpr = functionExpr2 OpLt;

/**
 * Constructs a database expression to test whether the first operand is greater than the second.
 * @arg expr1  a database expression for the first operand
 * @arg expr2  a database expression for the second operand
 * @return     a Boolean database expression to test whether the first operand is greater than the second
 */
gtExpr :: Ord a => TypedExpr a -> TypedExpr a -> TypedExpr Boolean;
public gtExpr = functionExpr2 OpGt;

/**
 * Constructs a database expression to test whether the first operand is less than or equal to the second.
 * @arg expr1  a database expression for the first operand
 * @arg expr2  a database expression for the second operand
 * @return     a Boolean database expression to test whether the first operand is less than or equal to the second
 */
ltEqExpr :: Ord a => TypedExpr a -> TypedExpr a -> TypedExpr Boolean;
public ltEqExpr = functionExpr2 OpLtEq;

/**
 * Constructs a database expression to test whether the first operand is greater than or equal to the second.
 * @arg expr1  a database expression for the first operand
 * @arg expr2  a database expression for the second operand
 * @return     a Boolean database expression to test whether the first operand is greater than or equal to the second
 */
gtEqExpr :: Ord a => TypedExpr a -> TypedExpr a -> TypedExpr Boolean;
public gtEqExpr = functionExpr2 OpGtEq;

/**
 * Constructs a database expression to test whether both of the operand expressions are True.
 * @arg b1  a database expression for the first operand
 * @arg b2  a database expression for the second operand
 * @return     a Boolean database expression to test whether both of the operand expressions are True
 */
andExpr :: TypedExpr Boolean -> TypedExpr Boolean -> TypedExpr Boolean;
public andExpr !b1 b2 = 
    if (b1 == trueConstant) then b2
    else if (b2 == trueConstant) then b1
    else if (b1 == falseConstant || b2 == falseConstant) then falseConstant
    else functionExpr2 OpAnd b1 b2;

/**
 * Constructs a database expression to test whether either of the operand expressions are True.
 * @arg b1  a database expression for the first operand
 * @arg b2  a database expression for the second operand
 * @return     a Boolean database expression to test whether either of the operand expressions are True
 */
orExpr :: TypedExpr Boolean -> TypedExpr Boolean -> TypedExpr Boolean;
public orExpr b1 b2 = 
    if (b1 == falseConstant) then b2
    else if (b2 == falseConstant) then b1
    else if (b1 == trueConstant || b2 == trueConstant) then trueConstant
    else functionExpr2 OpOr b1 b2;

/**
 * Constructs a database expression to test whether the first string operand expression matches 
 * the pattern of the second operand expression.
 * @arg strExpr      a string database expression for the first operand
 * @arg patternExpr  a string database expression for the pattern against which the first operand will be tested
 * @return           a Boolean database expression to test whether first string operand expression matches 
 *                   the pattern of the second operand expression
 */
likeExpr :: TypedExpr String -> TypedExpr String -> TypedExpr Boolean;
public likeExpr = functionExpr2 OpLike;

/**
 * Constructs a database expression to test whether the value of the first operand is equal to the value
 * returned by one of the list operand expressions.
 * @arg leftExpr        a database expression for the first operand
 * @arg listValueExprs  a database expression for the values against the first operand will be tested
 * @return              a Boolean database expression to test whether the value of the first operand is one of 
 *                      the values returned by the list operand expression
 */
inExpr :: Eq a => TypedExpr a -> [TypedExpr a] -> TypedExpr Boolean;
public inExpr leftExpr listValueExprs = functionExpr2 OpIn leftExpr (listExpr listValueExprs);

/**
 * Constructs a database expression to test whether the value of the first operand is one of the values 
 * returned by the list operand expression.
 * @arg leftExpr        a database expression for the first operand
 * @arg listValuesExpr  a database expression for the values against the first operand will be tested
 * @return              a Boolean database expression to test whether the value of the first operand is one of 
 *                      the values returned by the list operand expression
 */
inExpr2 :: Eq a => TypedExpr a -> TypedExpr [a] -> TypedExpr Boolean;
public inExpr2 leftExpr listValuesExpr = functionExpr2 OpIn leftExpr listValuesExpr;

/**
 * Constructs a database expression to concatenate two string operand expressions.
 * @arg expr1  a string database expression for the first operand
 * @arg expr2  a string database expression for the second operand
 * @return     a string database expression to concatenate the string operand expressions
 */
concatExpr :: TypedExpr String -> TypedExpr String -> TypedExpr String;
public concatExpr = functionExpr2 OpCat;

/**
 * A helper function for constructing a numeric binary operator.
 * Do not expose this.
 */
numBinaryExpr :: Num a => DbFunction -> TypedExpr a -> TypedExpr a -> TypedExpr a;
private numBinaryExpr = functionExpr2;

/**
 * Constructs a database expression to add two numeric operand expressions.
 * @arg expr1  a numeric database expression for the first operand
 * @arg expr2  a numeric database expression for the second operand
 * @return     a numeric database expression to add the two numeric operand expressions
 */
public addExpr      = numBinaryExpr OpPlus;

/**
 * Constructs a database expression to subtract two numeric operand expressions.
 * @arg expr1  a numeric database expression for the first operand
 * @arg expr2  a numeric database expression for the second operand
 * @return     a numeric database expression to subtract the two numeric operand expressions
 */
public subtractExpr = numBinaryExpr OpMinus;

/**
 * Constructs a database expression to multiply two numeric operand expressions.
 * @arg expr1  a numeric database expression for the first operand
 * @arg expr2  a numeric database expression for the second operand
 * @return     a numeric database expression to multiply the two numeric operand expressions
 */
public multiplyExpr = numBinaryExpr OpMul;

/**
 * Constructs a database expression to divide two numeric operand expressions.
 * @arg expr1  a numeric database expression for the first operand
 * @arg expr2  a numeric database expression for the second operand
 * @return     a numeric database expression to divide the two numeric operand expressions
 */
public divideExpr   = numBinaryExpr OpDiv;

/**
 * Constructs a database expression to return the modulus of two numeric operand expressions.
 * @arg expr1  a numeric database expression for the first operand
 * @arg expr2  a numeric database expression for the second operand
 * @return     a numeric database expression to return the modulus of the two numeric operand expressions
 */
public modulusExpr  = numBinaryExpr OpMod;

/**
 * A helper function for constructing an integer binary operator.
 * Do not expose this.
 */
intBinaryExpr :: DbFunction -> TypedExpr Int -> TypedExpr Int -> TypedExpr Int;
private intBinaryExpr = functionExpr2;

/**
 * Constructs a database expression to perform a bitwise 'and' of two numeric operand expressions.
 * @arg expr1  an integer database expression for the first operand
 * @arg expr2  an integer database expression for the second operand
 * @return     an integer database expression to perform a bitwise 'and' of two numeric operand expressions
 */
public bitwiseAndExpr = intBinaryExpr OpBitAnd;

/**
 * Constructs a database expression to perform a bitwise 'or' of two numeric operand expressions.
 * @arg expr1  an integer database expression for the first operand
 * @arg expr2  an integer database expression for the second operand
 * @return     an integer database expression to perform a bitwise 'or' of two numeric operand expressions
 */
public bitwiseOrExpr  = intBinaryExpr OpBitOr;

/**
 * Constructs a database expression to perform a bitwise 'xor' of two numeric operand expressions.
 * @arg expr1  an integer database expression for the first operand
 * @arg expr2  an integer database expression for the second operand
 * @return     an integer database expression to perform a bitwise 'xor' of two numeric operand expressions
 */
public bitwiseXorExpr = intBinaryExpr OpBitXor;


//////////////////////////////////////////////////////////////////////////////////////////////////////
// Other operator expressions

/**
 * Constructs a database expression which test whether the value of one operand expression is between 
 * the value of two other operand expressions.
 * @arg leftExpr   a database expression to be tested
 * @arg lowerExpr  a database expression for the lower bound of the value range
 * @arg upperExpr  a database expression for the upper bound of the value range
 * @return         a Boolean database expression to test whether the value of one operand expression is between 
 *                 the value of two other operand expressions
 */
betweenExpr :: Ord a => TypedExpr a -> TypedExpr a -> TypedExpr a -> TypedExpr Boolean;
public betweenExpr leftExpr lowerExpr upperExpr = functionExpr3 OpBetween leftExpr lowerExpr upperExpr;

/**
 * Constructs a database expression for a simple case statement.
 * When this expression is evaluated, the result value of the matching WHEN clause will be returned.
 * If none of the WHEN values match the case value, then the ELSE value will be returned.
 * @arg caseExpr             a database expression for the value to be tested
 * @arg whenValueAndResults  a list of pairs of comparison values and the corresponding result values
 * @arg elseValue            a database expression for the value to be returned if none of the WHEN clauses match
 * @return                   a database expression for a simple case statement
 */
simpleCaseExpr :: Eq a => TypedExpr a -> [(TypedExpr a, TypedExpr b)] -> Maybe (TypedExpr b) -> TypedExpr b;
public simpleCaseExpr caseExpr whenValueAndResults elseValue = 
    let
        unTypedExprs = toUntypedExpr caseExpr 
                        : concatMap (\pr -> [toUntypedExpr (fst pr), toUntypedExpr (snd pr)]) whenValueAndResults 
                        ++ map toUntypedExpr (maybeToList elseValue);
    in
        TypedExpr (untypedFunctionExpr OpCase_Simple unTypedExprs);

/**
 * Construct a database expression for a searched case statement.
 * Each WHEN clause will contain a Boolean expression and a result value.
 * The result will be the result value for the first WHEN clause with a condition that returns True.
 * If none of the WHEN clause expressions return True, then the ELSE value will be returned.
 * @arg whenConditionAndResults  a list of pairs of Boolean condition expressions and result values
 * @arg elseValue                a database expression for the value to be returned if none of the WHEN clauses evaluate to True
 * @return                       a database expression for a searched case statement
 */
searchedCaseExpr :: [(TypedExpr Boolean, TypedExpr b)] -> Maybe (TypedExpr b) -> TypedExpr b;
public searchedCaseExpr whenConditionAndResults elseValue = 
    let
        unTypedExprs = concatMap (\pr -> [toUntypedExpr (fst pr), toUntypedExpr (snd pr)]) whenConditionAndResults 
                        ++ map toUntypedExpr (maybeToList elseValue);
    in
        TypedExpr (untypedFunctionExpr OpCase_Searched unTypedExprs);


//////////////////////////////////////////////////////////////////////////////////////////////////////
// Numeric functions

absExpr :: Num a => TypedExpr a -> TypedExpr a;
public absExpr = functionExpr1 AbsFunction;

acosExpr :: TypedExpr Double -> TypedExpr Double;
public acosExpr = functionExpr1 AcosFunction;

asinExpr :: TypedExpr Double -> TypedExpr Double;
public asinExpr = functionExpr1 AsinFucntion;

atanExpr :: TypedExpr Double -> TypedExpr Double;
public atanExpr = functionExpr1 AtanFunction;

atan2Expr :: TypedExpr Double -> TypedExpr Double -> TypedExpr Double;
public atan2Expr = functionExpr2 Atan2Function;

ceilingExpr :: Num a => TypedExpr a -> TypedExpr Int;
public ceilingExpr = functionExpr1 CeilingFunction;

cosExpr :: TypedExpr Double -> TypedExpr Double;
public cosExpr = functionExpr1 CosFunction;

cotExpr :: TypedExpr Double -> TypedExpr Double;
public cotExpr = functionExpr1 CotFunction;

degreesExpr :: TypedExpr Double -> TypedExpr Double;
public degreesExpr = functionExpr1 DegreesFunction;

expExpr :: Num a => TypedExpr a -> TypedExpr Double;
public expExpr = functionExpr1 ExpFunction;

floorExpr :: Num a => TypedExpr a -> TypedExpr Int;
public floorExpr = functionExpr1 FloorFunction;

logExpr :: Num a => TypedExpr a -> TypedExpr Double;
public logExpr = functionExpr1 LogFunction;

log10Expr :: Num a => TypedExpr a -> TypedExpr Double;
public log10Expr = functionExpr1 Log10Function;

modExpr :: TypedExpr Int -> TypedExpr Int -> TypedExpr Int;
public modExpr = functionExpr2 ModFunction;

piExpr :: TypedExpr Double;
public piExpr = functionExpr0 PiFunction;

powerExpr :: (Num a, Num b) => TypedExpr a -> TypedExpr b -> TypedExpr a;
public powerExpr = functionExpr2 PowerFunction;

radiansExpr :: Num a => TypedExpr a -> TypedExpr Double;
public radiansExpr = functionExpr1 RadiansFunction;

randExpr :: TypedExpr Int -> TypedExpr Double;
public randExpr = functionExpr1 RandFunction;

roundExpr :: TypedExpr Double -> TypedExpr Int -> TypedExpr Double;
public roundExpr = functionExpr2 RoundFunction;

signExpr :: Num a => TypedExpr a -> TypedExpr Int;
public signExpr = functionExpr1 SignFunction;

sinExpr :: TypedExpr Double -> TypedExpr Double;
public sinExpr = functionExpr1 SinFunction;

sqrtExpr :: Num a => TypedExpr a -> TypedExpr Double;
public sqrtExpr = functionExpr1 SqrtFunction;

tanExpr :: TypedExpr Double -> TypedExpr Double;
public tanExpr = functionExpr1 TanFunction;

/**
 * TODO: is this the correct signature?
 */
truncateExpr :: Num a => TypedExpr a -> TypedExpr Int;
public truncateExpr = functionExpr1 TruncateFunction;


//////////////////////////////////////////////////////////////////////////////////////////////////////
// Conversion functions

/**
 * Converts an integer value to a double value.
 * The assumption here is that the database will do an implicit conversion
 * between these 2 types, so no function will be applied in the generated SQL.
 * A function could be used here if necessary.
 */
intToDoubleExpr :: TypedExpr Int -> TypedExpr Double;
public intToDoubleExpr expr = toTypedExpr (toUntypedExpr expr);

/**
 * Converts a value to a string value.
 */
convertToStringExpr :: TypedExpr a -> TypedExpr String;
public convertToStringExpr = functionExpr1 ConvertToStringFunction;

/**
 * Converts a value to a int value.
 */
convertToIntExpr :: TypedExpr a -> TypedExpr Int;
public convertToIntExpr = functionExpr1 ConvertToIntFunction;

/**
 * Converts a value to a double value.
 */
convertToDoubleExpr :: TypedExpr a -> TypedExpr Double;
public convertToDoubleExpr = functionExpr1 ConvertToDoubleFunction;



//////////////////////////////////////////////////////////////////////////////////////////////////////
// String functions
asciiExpr :: TypedExpr String -> TypedExpr Int;
public asciiExpr = functionExpr1 AsciiFunction;

charExpr :: TypedExpr Int -> TypedExpr String;
public charExpr = functionExpr1 CharFunction;

differenceExpr :: TypedExpr String -> TypedExpr String -> TypedExpr Int;
public differenceExpr = functionExpr2 DifferenceFunction;

insertExpr :: TypedExpr String -> TypedExpr Int -> TypedExpr Int -> TypedExpr String -> TypedExpr String;
public insertExpr stringExpr start length insertStr = functionExpr4 InsertFunction stringExpr start length insertStr;

lcaseExpr :: TypedExpr String -> TypedExpr String;
public lcaseExpr = functionExpr1 LcaseFunction;

leftExpr :: TypedExpr String -> TypedExpr Int -> TypedExpr String;
public leftExpr = functionExpr2 LeftFunction;

lengthExpr :: TypedExpr String -> TypedExpr Int;
public lengthExpr = functionExpr1 LengthFunction;

locateExpr :: TypedExpr String -> TypedExpr String -> TypedExpr Int;
public locateExpr searchExpr stringExpr = functionExpr2 LocateFunction searchExpr stringExpr;

locate2Expr :: TypedExpr String -> TypedExpr String -> TypedExpr Int -> TypedExpr Int;
public locate2Expr searchExpr stringExpr start = functionExpr3 LocateFunction searchExpr stringExpr start;

ltrimExpr :: TypedExpr String -> TypedExpr String;
public ltrimExpr = functionExpr1 LtrimFunction;

repeatExpr :: TypedExpr String -> TypedExpr Int -> TypedExpr String;
public repeatExpr stringExpr count = functionExpr2 RepeatFunction stringExpr count;

replaceExpr :: TypedExpr String -> TypedExpr String -> TypedExpr String -> TypedExpr String;
public replaceExpr stringExpr searchStr replacementStr = functionExpr3 ReplaceFunction stringExpr searchStr replacementStr;

rightExpr :: TypedExpr String -> TypedExpr Int -> TypedExpr String;
public rightExpr = functionExpr2 RightFunction;

rtrimExpr :: TypedExpr String -> TypedExpr String;
public rtrimExpr = functionExpr1 RtrimFunction;

soundexExpr :: TypedExpr String -> TypedExpr String;
public soundexExpr = functionExpr1 SoundexFunction;

spaceExpr :: TypedExpr Int -> TypedExpr String;
public spaceExpr nSpaces = functionExpr1 SpaceFunction nSpaces;

substringExpr :: TypedExpr String -> TypedExpr Int -> TypedExpr Int -> TypedExpr String;
public substringExpr stringExpr start length = functionExpr3 SubstringFunction stringExpr start length;

ucaseExpr :: TypedExpr String -> TypedExpr String;
public ucaseExpr = functionExpr1 UcaseFunction;


//////////////////////////////////////////////////////////////////////////////////////////////////////
// Misc functions

databaseExpr :: TypedExpr String;
public databaseExpr = functionExpr0 DatabaseFunction;

ifNullExpr :: TypedExpr a -> TypedExpr a -> TypedExpr a;
public ifNullExpr = functionExpr2 IfNullFunction;

nullIfExpr :: TypedExpr a -> TypedExpr a -> TypedExpr a;
public nullIfExpr = functionExpr2 NullIfFunction;

userExpr :: TypedExpr String;
public userExpr = functionExpr0 UserFunction;


//////////////////////////////////////////////////////////////////////////////////////////////////////
// Date/Time functions

dayNameExpr :: TypedExpr Time -> TypedExpr String;
public dayNameExpr = functionExpr1 DayNameFunction;

dayOfWeekExpr :: TypedExpr Time -> TypedExpr Int;
public dayOfWeekExpr = functionExpr1 DayOfWeekFunction;

dayOfMonthExpr :: TypedExpr Time -> TypedExpr Int;
public dayOfMonthExpr = functionExpr1 DayOfMonthFunction;

dayOfYearExpr :: TypedExpr Time -> TypedExpr Int;
public dayOfYearExpr = functionExpr1 DayOfYearFunction;

hourExpr :: TypedExpr Time -> TypedExpr Int;
public hourExpr = functionExpr1 HourFunction;

minuteExpr :: TypedExpr Time -> TypedExpr Int;
public minuteExpr = functionExpr1 MinuteFunction;

monthExpr :: TypedExpr Time -> TypedExpr Int;
public monthExpr = functionExpr1 MonthFunction;

monthNameExpr :: TypedExpr Time -> TypedExpr String;
public monthNameExpr = functionExpr1 MonthNameFunction;

nowExpr :: TypedExpr Time;
public nowExpr = functionExpr0 NowFunction;

quarterExpr :: TypedExpr Time -> TypedExpr Int;
public quarterExpr = functionExpr1 QuarterFunction;

secondExpr :: TypedExpr Time -> TypedExpr Int;
public secondExpr = functionExpr1 SecondFunction;

// TODO: create helper functions for TimestampAddFunction and
// TimestampDiffFunction...

weekExpr :: TypedExpr Time -> TypedExpr Int;
public weekExpr = functionExpr1 WeekFunction;

yearExpr :: TypedExpr Time -> TypedExpr Int;
public yearExpr = functionExpr1 YearFunction;

dateTimeAddExpr :: TimeInterval -> TypedExpr Int -> TypedExpr Time -> TypedExpr Time;
public dateTimeAddExpr timeInterval =  functionExpr2 (DateTimeAddFunction timeInterval);

dateTimeDiffExpr :: TimeInterval -> TypedExpr Time -> TypedExpr Time -> TypedExpr Int;
public dateTimeDiffExpr timeInterval = functionExpr2 (DateTimeDiffFunction timeInterval);


//////////////////////////////////////////////////////////////////////////////////////////////////////
// Aggregate functions

untypedAggregationExpr :: DbFunction -> Expr -> Expr;
public untypedAggregationExpr aggrOp baseExpr = 
    if (isAggregationFunction aggrOp) then FunctionExpr aggrOp [baseExpr]
    else error "The specified function is not an aggregation function.";

countExpr :: TypedExpr a -> TypedExpr Int;
public countExpr = functionExpr1 AggrCount;

sumExpr :: Num a => TypedExpr a -> TypedExpr a;
public sumExpr = functionExpr1 AggrSum;

avgExpr :: Num a => TypedExpr a -> TypedExpr Double;
public avgExpr = functionExpr1 AggrAvg;

minExpr :: Ord a => TypedExpr a -> TypedExpr a;
public minExpr = functionExpr1 AggrMin;

maxExpr :: Ord a => TypedExpr a -> TypedExpr a;
public maxExpr = functionExpr1 AggrMax;

distinctCountExpr :: TypedExpr a -> TypedExpr Int;
public distinctCountExpr = functionExpr1 AggrDistinctCount;

distinctSumExpr :: Num a => TypedExpr a -> TypedExpr a;
public distinctSumExpr = functionExpr1 AggrDistinctSum;

distinctAvgExpr :: Num a => TypedExpr a -> TypedExpr Double;
public distinctAvgExpr = functionExpr1 AggrDistinctAvg;

countAllExpr :: TypedExpr Double;
public countAllExpr = functionExpr0 AggrCountAll;

stdDevExpr :: Num a => TypedExpr a -> TypedExpr Double;
public stdDevExpr = functionExpr1 AggrStdDev;

stdDevPExpr :: Num a => TypedExpr a -> TypedExpr Double;
public stdDevPExpr = functionExpr1 AggrStdDevP;

varianceExpr :: Num a => TypedExpr a -> TypedExpr Double;
public varianceExpr = functionExpr1 AggrVar;

variancePExpr :: Num a => TypedExpr a -> TypedExpr Double;
public variancePExpr = functionExpr1 AggrVarP;


/**
 * A database SELECT query.
 */
data public Query =
    private Query 
        options          :: [QueryOption]                 
        columns          :: [(Expr, String)]              
        restriction      :: (Maybe (TypedExpr Boolean))   
        orderings        :: [(Expr, Boolean)]             
        joins            :: [JoinNode]                    
        groups           :: [Expr]                        
        groupRestriction :: (Maybe (TypedExpr Boolean)) | 
    private Union 
        query1           :: Query     
        query2           :: Query
        unionAll         :: Boolean   
    deriving Eq, Show;

/**
 * Creates a new, empty query.
 */
newQuery :: Query;
public newQuery = Query [] [] Nothing [] [] [] Nothing;

/**
 * Combines the 2 queries into a Union query.
 */
unionQuery :: Query -> Query -> Boolean -> Query;
public unionQuery query1 query2 unionAll = 
    let
        query1Cols = getProjectedColumns query1;
        query2Cols = getProjectedColumns query2;

        // Remove any ordering from the first query.
        updatedQuery1 = removeOrdering query1;
    in
        // Check that the queries have the same number of columns.
        if (length query1Cols == length query2Cols) then Union updatedQuery1 query2 unionAll
        else error "Both queries in a Union must have the same number of columns";

/**
 * Produces a query which returns the intersection of the two specified queries.
 * The final result columns will be based on the first query.
 * The intersection will be performed on the corresponding columns in each
 * query.
 * It is ok for the queries to have different numbers of columns.
 */
intersectionQuery :: Query -> Query -> Query;
public intersectionQuery query1 query2 = 
    let
        origAliases = map snd (projectedColumnsWithAliases query1);

        // Set a known alias for the colums.
        itemColumnAliases = map (\i -> "COL_VALUE" ++ (intToString i)) (upFrom 1);

        // Wrap these subqueries in tables.
        subQueryTable1 = makeSubQueryTable (setColumnAliases query1 itemColumnAliases) "Q1";
        subQueryTable2 = makeSubQueryTable (setColumnAliases query2 itemColumnAliases) "Q2";

        nJoinColumns = length (zip (getProjectedColumns query1) (getProjectedColumns query2));
        joinInfos = map (\alias -> makeJoinInfo (stringField subQueryTable1 alias) (stringField subQueryTable2 alias) InnerJoin) (take nJoinColumns itemColumnAliases);

        resultCols = zip (map (untypedField subQueryTable1) itemColumnAliases) origAliases;
    in
        join2 (projectWithAliases newQuery resultCols) joinInfos;


/**
 * Produces a query which returns the intersection of the two specified queries.
 * The final result columns will be based on the first query.
 * The intersection will be performed on the specified expressions.
 */
intersectionQuery2 :: Query -> Query -> [(Expr, Expr)] -> Query;
public intersectionQuery2 query1 query2 compareExprs = 
    let
        origAliases = map snd (projectedColumnsWithAliases query1);

        compareExprs1 = if (isEmpty compareExprs) then getProjectedColumns query1
                        else map fst compareExprs;
        compareExprs2 = if (isEmpty compareExprs) then getProjectedColumns query2
                        else map snd compareExprs;

        // Ensure that all the comparison expressions are projected from both
        // queries.
        queryAllColumns1 = projectColumnsIfNecessary query1 compareExprs1;
        queryAllColumns2 = projectColumnsIfNecessary query2 compareExprs2;

        // Set a known alias for the colums.
        itemColumnAliases = map defaultColumnAlias (upFrom 0);

        // Wrap these subqueries in tables.
        subQueryTable1 = makeSubQueryTable (setColumnAliases queryAllColumns1 itemColumnAliases) "Q1";
        subQueryTable2 = makeSubQueryTable (setColumnAliases queryAllColumns2 itemColumnAliases) "Q2";

        // Find the join expression for each of the comparison expressions.
        lookupJoinExpr origQuery subQueryTable origExpr = 
            let
                indexInOrigQuery = fromJust (elemIndex origExpr (getProjectedColumns origQuery));
                alias = defaultColumnAlias indexInOrigQuery;
            in
                stringField subQueryTable alias;

        joinExprs1 = map (lookupJoinExpr queryAllColumns1 subQueryTable1) compareExprs1;
        joinExprs2 = map (lookupJoinExpr queryAllColumns2 subQueryTable2) compareExprs2;

        joinInfos = zipWith (\e1 e2 -> makeJoinInfo e1 e2 InnerJoin) joinExprs1 joinExprs2;

        resultCols = zip (map (untypedField subQueryTable1) itemColumnAliases) origAliases;
    in
        join2 (projectWithAliases newQuery resultCols) joinInfos;

/**
 * This is an alternate version of {@link intersectionQuery@}.
 * Instead of creating 2 subqueries and linking them, this function creates a
 * subquery for the second query
 * and links it directly to the first query (although special handling is needed
 * if the first query is uses {@link TopN@}).
 * This should give the same results as {@code intersectionQuery@}.
 * 
 * TODO: check which option is most efficient and get rid of the other one.
 */
alternateIntersectionQuery :: Query -> Query -> Query;
public alternateIntersectionQuery query1 query2 = 
    let
        origAliases = map snd (projectedColumnsWithAliases query1);

        // Set a known alias for the colums.
        itemColumnAliases = map defaultColumnAlias (upFrom 0);

        nJoinColumns = length (zip (getProjectedColumns query1) (getProjectedColumns query2));

        needToWrapQuery query = isTopNQuery query;
        wrapQueryIfNeeded query = if (needToWrapQuery query) then wrapQuery query else query;

        updatedQuery1 = wrapQueryIfNeeded query1;

        subQueryTable2 = makeSubQueryTable (setColumnAliases query2 itemColumnAliases) "";

        joinInfos = zipWith (\query1Col alias -> makeJoinInfo (toTypedExpr query1Col) (stringField subQueryTable2 alias) InnerJoin) (getProjectedColumns updatedQuery1) (take nJoinColumns itemColumnAliases);
    in
        setColumnAliases (join2 updatedQuery1 joinInfos) origAliases;


/**
 * Produces a query which returns the difference of the two specified queries.
 * The final result columns will be based on the first query.
 * The difference will be performed on the corresponding columns in each query.
 * It is ok for the queries to have different numbers of columns.
 */
differenceQuery :: Query -> Query -> Query;
public differenceQuery query1 query2 = 
    differenceQuery2 query1 query2 (zip (getProjectedColumns query1) (getProjectedColumns query2));


/**
 * Produces a query which returns the difference of the two specified queries.
 * The final result columns will be based on the first query.
 * The difference will be performed on the specified expressions.
 */
differenceQuery2 :: Query -> Query -> [(Expr, Expr)] -> Query;
public differenceQuery2 query1 query2 compareExprs = 
    let
        origAliases = map snd (projectedColumnsWithAliases query1);

        compareExprs1 = if (isEmpty compareExprs) then getProjectedColumns query1
                        else map fst compareExprs;
        compareExprs2 = if (isEmpty compareExprs) then getProjectedColumns query2
                        else map snd compareExprs;

        // Ensure that all the comparison expressions are projected from both
        // queries.
        queryAllColumns1 = projectColumnsIfNecessary query1 compareExprs1;
        queryAllColumns2 = projectColumnsIfNecessary query2 compareExprs2;

        // Take the first query, and add a restriction of the following form:
        //     NOT EXISTS (SELECT ... WHERE qry2Field1 <> qry1Field1 AND qry2Field2
        // <> qry1Field2 AND ....
        needToWrapQuery query = isTopNQuery query;
        wrapQueryIfNeeded query = if (needToWrapQuery query) then wrapQuery query else query;

        updatedQuery1 = wrapQueryIfNeeded queryAllColumns1;
        updatedQuery2 = wrapQueryIfNeeded queryAllColumns2;

        // Find the updated expression for each of the comparison expressions.
        lookupUpdatedExpr origQuery updatedQuery origExpr = 
            let
                lookupMap = zip (getProjectedColumns origQuery) (getProjectedColumns updatedQuery);
            in
                fromJust (List.lookup origExpr lookupMap);

        updatedCompareExprs1 = map (lookupUpdatedExpr queryAllColumns1 updatedQuery1) compareExprs1;
        updatedCompareExprs2 = map (lookupUpdatedExpr queryAllColumns2 updatedQuery2) compareExprs2;

        exclusionRestrictions = zipWith (\q2Col q1Col -> toTypedExpr (untypedBinaryExpr OpEq q2Col q1Col)) updatedCompareExprs2 updatedCompareExprs1;

        exclusionExpr = notExpr (existsExpr (toTypedExpr (subQueryExpr (restrict2 updatedQuery2 exclusionRestrictions))));

        restrictedQuery = restrict updatedQuery1 exclusionExpr;
        allResultExpr = getProjectedColumns restrictedQuery;
    in
        // Set the correct aliases and truncate the projected columns to match
        // the original list.
        projectWithAliases (removeProjectedColumns restrictedQuery) (zip allResultExpr origAliases);


/**
 * Returns a default column alias.
 * The column index is the zero-based index of the expression in the query's
 * projected columns.
 */
defaultColumnAlias :: Int -> String;
private defaultColumnAlias colIndex = "COL_VALUE" ++ (intToString (colIndex + 1));


/**
 * Adds the specified expression to the projected columns, if it isn't already
 * projected.
 */
projectColumnIfNecessary :: Query -> Expr -> Query;
private projectColumnIfNecessary !query !expr = 
    if (isElem expr (getProjectedColumns query)) then query
    else project query [expr];

/**
 * Adds the specified expressions to the projected columns, if they aren't
 * already projected.
 */
projectColumnsIfNecessary :: Query -> [Expr] -> Query;
private projectColumnsIfNecessary query exprs = foldLeftStrict projectColumnIfNecessary query exprs;


/**
 * Wraps the query in an outer query which projects the same columns as the
 * original.
 * The ordering from the original query is also preserved.
 */
wrapQuery :: Query -> Query;
public wrapQuery query = fst (wrapQuery2 query []);

/**
 * Wraps the query in an outer query which projects the same columns as the
 * original.
 * The ordering from the original query is also preserved.
 * The wrapped query will be returned along with wrapped versions of the
 * specified additional expressions.
 */
wrapQuery2 :: Query -> [Expr] -> (Query, [Expr]);
public wrapQuery2 query additionalExprs = 
    let
        origAliases = projectedColumnAliases query ++ repeat "";
        originalOrdering = orderingExpressions query;

        origProjectedExprs = getProjectedColumns query;
        origOrderingExprs = map fst originalOrdering;

        additionalProjectedExprs = deleteFirsts (removeDuplicates (origOrderingExprs ++ additionalExprs)) origProjectedExprs;

        itemColumnAliases = map defaultColumnAlias (upFrom 0);
        subQueryTable = makeSubQueryTable (setColumnAliases (project query additionalProjectedExprs) itemColumnAliases) "";

        allSubqueryProjectedExprs = origProjectedExprs ++ additionalProjectedExprs;
        wrappedQueryExprs = map (untypedField subQueryTable) itemColumnAliases;

        wrappedQueryProjectedExprs = take (length origProjectedExprs) wrappedQueryExprs;

        exprMap = zip allSubqueryProjectedExprs wrappedQueryExprs;
        lookupNewExpr origExpr = lookupWithDefault origExpr exprMap (error "Failed to find expression in wrapped query");

        // Preverse the ordering from the original query.
        newOrdering = map (\pr -> (lookupNewExpr (fst pr), snd pr)) originalOrdering;

        wrappedQuery = order2 (projectWithAliases newQuery (zip wrappedQueryProjectedExprs origAliases)) newOrdering;

        wrappedAdditionalExprs = map lookupNewExpr additionalExprs;
    in
        (wrappedQuery, wrappedAdditionalExprs);
   

/**
 * Returns a query field for the specified table.
 */
untypedField :: QueryTable -> String -> Expr;
public untypedField table fieldName = QueryField fieldName table;

stringField :: QueryTable -> String -> TypedExpr String;
public stringField table fieldName = TypedExpr (QueryField fieldName table);

booleanField :: QueryTable -> String -> TypedExpr Boolean;
public booleanField table fieldName = TypedExpr (QueryField fieldName table);

doubleField :: QueryTable -> String -> TypedExpr Double;
public doubleField table fieldName = TypedExpr (QueryField fieldName table);

intField :: QueryTable -> String -> TypedExpr Int;
public intField table fieldName = TypedExpr (QueryField fieldName table);

timeField :: QueryTable -> String -> TypedExpr Time;
public timeField table fieldName = TypedExpr (QueryField fieldName table);

binaryField :: QueryTable -> String -> TypedExpr (Array Byte);
public binaryField table fieldName = TypedExpr (QueryField fieldName table);


/**
 * Returns the query options.
 * For {@link Union@} queries, this will return the options for the first query.
 */
queryOptions :: Query -> [QueryOption];
public queryOptions query = 
    case query of
    Query {options} -> options;
    Union {query1}  -> queryOptions query1;
    ;

/**
 * Adds an option to the query.
 */
addOption :: Query -> QueryOption -> Query;
public addOption !query !newOption = 
    case (removeOption query newOption) of
    Query options columns restriction orderings joins groups groupRestriction ->
        Query (options ++ [newOption]) columns restriction orderings joins groups groupRestriction;

    Union query1 query2 unionAll -> 
        // Add the option to both queries.
        Union (addOption query1 newOption) (addOption query2 newOption) unionAll;
    ;

/**
 * Removes the option of the same type as the specified one (even if the exact
 * values don't match).
 */
removeOption :: Query -> QueryOption -> Query;
public removeOption query optionTypeToRemove = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction ->
        let
            remainingOptions = filter (\o -> not (isSameOptionType optionTypeToRemove o)) options;
        in
            Query remainingOptions columns restriction orderings joins groups groupRestriction;

    Union query1 query2 unionAll -> 
        // Remove the option from both queries.
        Union (removeOption query1 optionTypeToRemove) (removeOption query2 optionTypeToRemove) unionAll;
    ;

/**
 * Returns whether the specified options are of the same type (not necessarily
 * the same value).
 */
isSameOptionType :: QueryOption -> QueryOption -> Boolean;
isSameOptionType !option1 !option2 = 
    case option1 of
    Distinct -> 
        case option2 of
        Distinct -> True;
        _ -> False;
        ;
    TopN {} -> 
        case option2 of
        TopN {} -> True;
        _ -> False;
        ;
    ;

/**
 * Returns whether a {@link TopN@} option is specified for the query.
 */
isTopNQuery :: Query -> Boolean;
private isTopNQuery !query =
    case query of
    Query {options} -> any isTopNOption options; 

    // Check whether either query is a topN query.
    Union {query1, query2} -> isTopNQuery query1 || isTopNQuery query2;
    ;


/**
 * Adds the specified expression as a result column in the query.
 */
projectColumn :: Query -> TypedExpr a -> Query;
public projectColumn query newColumn = 
    project query [toUntypedExpr newColumn];

/**
 * Adds the specified expression as a result column in the query.
 */
projectColumnWithAlias :: Query -> TypedExpr a -> String -> Query;
public projectColumnWithAlias query newColumn columnAlias = 
    projectWithAliases query [(toUntypedExpr newColumn, columnAlias)];

/**
 * Adds the specified expressions as result columns in the query.
 */
project :: Query -> [Expr] -> Query;
public project query newColumns = 
    let
        newColumnsAndAliases = zip newColumns (repeat "");
    in
        projectWithAliases query newColumnsAndAliases;

/**
 * Adds the specified expressions as result columns with the corresponding
 * aliases in the query.
 * 
 * TODO: don't add the same field multiple times...
 */
projectWithAliases :: Query -> [(Expr, String)] -> Query;
public projectWithAliases query newColumns = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction ->
        Query options (columns ++ newColumns) restriction orderings joins groups groupRestriction;

    Union query1 query2 unionAll -> 
        // Product the column in both queries.
        Union (projectWithAliases query1 newColumns) (projectWithAliases query2 newColumns) unionAll;
    ;

/**
 * Returns the projected columns for the query.
 * For a {@link Union@} query, this will return only the projected columns for the first
 * query.
 * 
 * TODO: rename this to projectedColumns...
 */
getProjectedColumns :: Query -> [Expr];
public getProjectedColumns query = 
    case query of
    Query {columns} -> map fst columns;
    Union {query1}  -> getProjectedColumns query1;
    ;

/**
 * Returns the projected columns for the query.
 * For a {@link Union@} query, this will return only the projected columns for the first
 * query.
 */
projectedColumnsWithAliases :: Query -> [(Expr, String)];
public projectedColumnsWithAliases query = 
    case query of
    Query {columns} -> columns;
    Union {query1}  -> projectedColumnsWithAliases query1;
    ;

/**
 * Returns the aliases for the query's projected columns.
 */
projectedColumnAliases :: Query -> [String];
public projectedColumnAliases query = map snd (projectedColumnsWithAliases query);

/**
 * Removes all projected columns from the query.
 */
removeProjectedColumns :: Query -> Query;
public removeProjectedColumns query = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction -> 
        Query options [] restriction orderings joins groups groupRestriction;
    Union query1 query2 unionAll -> 
        // Remove the projected columns from both queries.
        Union (removeProjectedColumns query1) (removeProjectedColumns query2) unionAll;
    ;

/**
 * Removes the specified expression from the projected columns list.
 * For {@link Union@} queries, the specified expression will be removed from the both
 * queries along with the
 * corresponding columns in the other query.
 */
removeProjectedColumn :: Query -> Expr -> Query;
public removeProjectedColumn query exprToRemove = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction -> 
        Query options (filter (\c -> (fst c) != exprToRemove) columns) restriction orderings joins groups groupRestriction;

    Union query1 query2 unionAll -> 
        let
            exprIndicesInQuery qry = 
                case qry of
                Query {columns}        -> List.findIndices (\c -> fst c == exprToRemove) columns;
                Union {query1, query2} -> removeDuplicates (exprIndicesInQuery query1 ++ exprIndicesInQuery query2);
                ;

            // Determine the combined set of indices to be removed.
            indicesToRemove = exprIndicesInQuery query;

            // Remove the appropriate columns from a query.
            removeExprs qry =
                case qry of
                Query options columns restriction orderings joins groups groupRestriction ->
                    let
                        newColumns = map snd (filter (\pr -> not (isElem (fst pr) indicesToRemove)) (zip (upFrom 0) columns));
                    in
                        Query options newColumns restriction orderings joins groups groupRestriction;
                Union query1 query2 unionAll -> 
                    Union (removeExprs query1) (removeExprs query2) unionAll;
                ;
        in
            removeExprs query;
    ;

/**
 * Sets the aliases for the first N projected columns.
 * Any other existing aliases will be left untouched.
 */
setColumnAliases :: Query -> [String] -> Query;
public setColumnAliases query newAliases = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction -> 
        let
            oldAliases = map snd columns;
            projectedExprs = map fst columns;

            finalAliases = newAliases ++ (drop (length newAliases) oldAliases);
            newColumns = zip projectedExprs finalAliases;
        in
            Query options newColumns restriction orderings joins groups groupRestriction;

    Union query1 query2 unionAll -> 
        // Set the column aliases in both queries.
        Union (setColumnAliases query1 newAliases) (setColumnAliases query2 newAliases) unionAll;
    ;


/**
 * Adds a restriction on the rows returned by the query.
 */
restrict :: Query -> TypedExpr Boolean -> Query;
public restrict !query !newRestriction = 
    let
        // Returns a list of expressions which are ANDed together, if any.
        getAndedExprs :: TypedExpr Boolean -> [TypedExpr Boolean];
        getAndedExprs expr = 
            case (toUntypedExpr) expr of
            FunctionExpr {func, arguments} -> 
                case func of
                OpAnd -> concatMap (Prelude.compose getAndedExprs toTypedExpr) arguments;
                _ -> [expr];
                ;
            _ -> [expr];
            ;


        restrictHelper :: Query -> TypedExpr Boolean -> Query;
        restrictHelper !query !newRestriction = 
            case query of
            Query options columns restriction orderings joins groups groupRestriction -> 
                let
                    mergedRestriction = 
                        case restriction of
                        Nothing -> newRestriction;
                        Just restrictionValue -> andExpr restrictionValue newRestriction;
                        ;

                    mergedGroupRestriction = 
                        case groupRestriction of
                        Nothing -> newRestriction;
                        Just groupRestrictionValue -> andExpr groupRestrictionValue newRestriction;
                        ;
                in
                    // Don't change anything if the new criteria is simply
                    // 'True'.
                    if (newRestriction == trueConstant) then
                        query
                    else if (isGroupRestriction newRestriction) then
                        Query options columns restriction orderings joins groups (Just mergedGroupRestriction)
                    else
                        Query options columns (Just mergedRestriction) orderings joins groups groupRestriction;

            Union query1 query2 unionAll -> 
                // Restrict both queries.
                Union (restrict query1 newRestriction) (restrict query2 newRestriction) unionAll;
            ;
        in
            // Split up the restriction into separate ANDed expressions and apply
            // each individually.
            // This is needed in cases where the restriction expression contains
            // some record restrictions
            // and some group restrictions.
            foldLeftStrict restrictHelper query (getAndedExprs newRestriction);


/**
 * Adds the specified restrictions on the rows returned by the query.
 */
restrict2 :: Query -> [TypedExpr Boolean] -> Query;
public restrict2 query newRestrictions = 
    foldLeftStrict restrict query newRestrictions;

/**
 * Returns whether the restriction expression applies to groups or record
 * values.
 */
isGroupRestriction :: TypedExpr Boolean -> Boolean;
private isGroupRestriction restriction = exprUsesAggregation (toUntypedExpr restriction);

/**
 * Returns whether the expression uses aggregate functions.
 * 
 * TODO: is there anything else to look for?
 */
exprUsesAggregation :: Expr -> Boolean;
public exprUsesAggregation expr =
    case expr of
   (QueryField |
    ConstExpr |
    SubQueryExpr) {} -> False;
    ListExpr {listValues} -> any exprUsesAggregation listValues;
    FunctionExpr {func, arguments} -> isAggregationFunction func || (any exprUsesAggregation arguments);
    ;


/**
 * Returns the restriction expressions (including group restrictions) for the
 * query.
 * For a {@link Union@} query, this only returns the restrictions for the first query.
 */
restrictionExpressions :: Query -> [TypedExpr Boolean];
public restrictionExpressions query = 
    case query of
    Query {restriction, groupRestriction} -> 
        (Prelude.maybeToList restriction) ++ (Prelude.maybeToList groupRestriction);

    Union {query1} -> 
        restrictionExpressions query1;
    ;


/**
 * Adds sorting on the specified expression.
 */
order :: Ord a => Query -> TypedExpr a -> Boolean -> Query;
public order query sortExpr sortAscending = order2 query [(toUntypedExpr sortExpr, sortAscending)];

/**
 * Adds sorting on the specified fields.
 */
order2 :: Query -> [(Expr, Boolean)] -> Query;
public order2 query newOrderings = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction -> 
        Query options columns restriction (orderings ++ newOrderings) joins groups groupRestriction;
    Union query1 query2 unionAll -> 
        // Add ordering to only the 2nd query.
        Union query1 (order2 query2 newOrderings) unionAll;
    ;

/**
 * Returns the ordering info for the query.
 */
orderingExpressions :: Query -> [(Expr, Boolean)];
public orderingExpressions query = 
    case query of
    Query {orderings} ->  orderings;
    Union {query2} -> orderingExpressions query2;
    ;

/**
 * Removes all ordering from the query.
 */
removeOrdering :: Query -> Query;
public removeOrdering query = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction -> 
        Query options columns restriction [] joins groups groupRestriction;

    Union query1 query2 unionAll -> 
        // Remove ordering from both queries (even though the first one
        // shouldn't have any ordering to begin with).
        Union (removeOrdering query1) (removeOrdering query2) unionAll;
    ;


/**
 * Projects the specified expressions from the query, and group and order (ASC) on the expressions.
 */
projectGroupAndOrder :: Query -> [Expr] -> Query;
public projectGroupAndOrder !query !exprs = 
    order2 (group2 (project query exprs) exprs) (zip exprs $ repeat True);


/**
 * Adds a join between 2 tables.
 */
join :: Query -> JoinInfo -> Query;
public join !query newJoinInfo = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction -> 
        let
            newJoinNodes = applyJoinInfo joins newJoinInfo;
        in
            Query options columns restriction orderings newJoinNodes groups groupRestriction;

    Union query1 query2 unionAll -> 
        // Add the join to both queries.
        Union (join query1 newJoinInfo) (join query2 newJoinInfo) unionAll;
    ;

/**
 * Adds the specified joins to the query.
 */
join2 :: Query -> [JoinInfo] -> Query;
public join2 query newJoins = 
    foldLeft join query newJoins;

/**
 * Adds the specified join nodes to the query.
 */
addJoins :: Query -> [JoinNode] -> Query;
public addJoins query newJoins = 
    setJoins query (joins query ++ newJoins);

/**
 * Sets the join information for the query as a list of join node trees.
 * This will replace any existing join info.
 */
setJoins :: Query -> [JoinNode] -> Query;
public setJoins query newJoins = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction -> 
        Query options columns restriction orderings (cleanupJoinNodes newJoins) groups groupRestriction;

    Union query1 query2 unionAll -> 
        // Set the joins in both queries.
        Union (setJoins query1 newJoins) (setJoins query2 newJoins) unionAll;
    ;

/**
 * Returns the join information from the query.
 * For a {@link Union@} query, the joins from the first query will be returned.
 */
joins :: Query -> [JoinNode];
public joins query = 
    case query of
    Query {joins} -> joins;
    Union {query1} -> joins query1;
    ;

/**
 * Constructs a single join tree based on the list of join info items.
 * This will throw an error if a single set of joins cannot be produced from the
 * join info items
 * (which would likely mean that there are tables or groups of tables which are
 * not linked in some way).
 */
buildJoinTree :: [JoinInfo] -> JoinNode;
public buildJoinTree joinInfo = 
    let
        joinTrees = foldLeftStrict applyJoinInfo [] joinInfo;
    in
        if (isEmpty joinInfo) then
            error "No join info items were specified"
        else if (isSingletonList joinTrees) then
            head joinTrees
        else
            error "The join info items could not be combined into a single join tree";

/**
 * Apply a single join info item to the list of join nodes.
 * Returns the new list of top-level join nodes.
 */
applyJoinInfo :: [JoinNode] -> JoinInfo -> [JoinNode];
private applyJoinInfo !oldNodes !joinInfo = 
    case joinInfo of
    JoinInfo {leftTable, rightTable, fieldJoinExprs, joinType} ->
        let
            // Returns whether the join node subtree contains a node for the
            // specified table.
            joinSubtreeIncludesTable :: QueryTable -> JoinNode -> Boolean;
            joinSubtreeIncludesTable table node = 
                case node of
                JoinTable {table=joinTable} -> table == joinTable;
                JoinSubtree {leftNode, rightNode} ->
                    (joinSubtreeIncludesTable table leftNode) || (joinSubtreeIncludesTable table rightNode);
                ;

            // Determine which join trees contain the left and right tables.
            // The first item, if any, in each list will be the join tree
            // containing the appropriate table.
            leftResults  = snd (List.break (joinSubtreeIncludesTable leftTable) oldNodes);
            rightResults = snd (List.break (joinSubtreeIncludesTable rightTable) oldNodes);

            leftTableTree  = 
                case leftResults of
                [] -> JoinTable leftTable;
                leftResultsHead : _ -> leftResultsHead;
                ;

            rightTableTree = 
                case rightResults of
                [] -> JoinTable rightTable;
                rightResultsHead : _ -> rightResultsHead;
                ;

            // Check whether both tables are already used in the same join node
            // tree.
            tablesFromSameTree = (length leftResults == length rightResults) && not (isEmpty leftResults);

            // Combine the individual field join expressions into a single
            // linking expressions.
            linkingExpr :: TypedExpr Boolean;
            linkingExpr = 
                case fieldJoinExprs of
                [] -> error "No field join expressions were specified for a join.";
                _ -> List.foldRight1 andExpr fieldJoinExprs;    // TODO: is this correct?
                ;

            // Construct a new join node tree which includes the join between
            // the left and right tables.
            newNode = if (tablesFromSameTree) then 
                          addLinkExprInSubtree leftTableTree
                      else 
                          JoinSubtree leftTableTree rightTableTree linkingExpr joinType;

            // If the left and right tables already belong to the same join
            // tree, then the linking criteria
            // will need to be added to an existing join node in this tree.
            // This will be added to the first node (closest to the table nodes)
            // that has both tables in its subtree.
            addLinkExprInSubtree :: JoinNode -> JoinNode;
            addLinkExprInSubtree node = 
                case node of
                JoinTable {} -> node;
                JoinSubtree {leftNode, rightNode, linkingExpr=oldLinkingExpr, joinType} -> 
                    let
                        // TODO: perhaps the join types should be compared (and
                        // an error raised if they are not compatible).
                        //       It would also be important to check whether the join
                        // is reversed in this case.

                        // This will return whether this is the first node which
                        // has the 2 tables in common.
                        isCommonNodeForTables :: Boolean;
                        isCommonNodeForTables = 
                            case node of
                            JoinTable {} -> False;
                            JoinSubtree {leftNode, rightNode} -> 
                                (joinSubtreeIncludesTable leftTable leftNode) && (joinSubtreeIncludesTable rightTable rightNode)
                                || (joinSubtreeIncludesTable rightTable leftNode) && (joinSubtreeIncludesTable leftTable rightNode);
                            ;

                        combinedLinkingExpr = andExpr oldLinkingExpr linkingExpr;
                    in
                        if (isCommonNodeForTables) then JoinSubtree leftNode rightNode combinedLinkingExpr joinType
                        else JoinSubtree (addLinkExprInSubtree leftNode) (addLinkExprInSubtree rightNode) linkingExpr joinType;
                ;

            // Remove the appropriate node(s) from the old list of join trees.
            nodesToPreserve = filter (\node -> not (joinSubtreeIncludesTable leftTable node || joinSubtreeIncludesTable rightTable node)) oldNodes;

            newNodes = cleanupJoinNodes (newNode : nodesToPreserve);
        in
// TODO: remove this debugging code later...
//Debug.trace ("applyJoinInfo: " ++ (show leftTable) ++ " to " ++ (show
// rightTable) ++ "\n result = " ++ (showJoinNodes newNodes) ++ "\n\n")
// newNodes;
            newNodes;
    ;

/**
 * Connects up any separate join trees with common tables.
 * Also, clean up any unlinked tables which also are included in a join.
 */
cleanupJoinNodes :: [JoinNode] -> [JoinNode];
private cleanupJoinNodes joinNodes = 
    let
        allJoinTables :: [QueryTable];
        allJoinTables = concatMap getJoinTreeTables joinNodes;

        tablesWithSpecifiedAlias :: [QueryTable];
        tablesWithSpecifiedAlias = 
            filter (\t -> 
                       case t of
                       BaseTable {tableRef, tableAlias} -> getTableNameFromReference tableRef != tableAlias;
                       _ -> False;
                   )
                   allJoinTables;

        fixTableName table = fromMaybe table (find (equals table) tablesWithSpecifiedAlias);

        fixJoinTableNames join = 
            case join of
            JoinTable table ->
                JoinTable (fixTableName table);
            JoinSubtree leftNode rightNode linkingExpr joinType -> 
                JoinSubtree (fixJoinTableNames leftNode) (fixJoinTableNames rightNode) linkingExpr joinType;
            ;

        joinNodesWithFixedTableNames :: [JoinNode];
        joinNodesWithFixedTableNames = map fixJoinTableNames joinNodes;

        // Removed any unjoined tables which are included in a join.
        cleanupUnjoinedTables :: [JoinNode] -> [JoinNode];
        cleanupUnjoinedTables joinNodes = 
            let
                isUnlinkedTable node = 
                    case node of
                    JoinTable {} -> True;
                    _ -> False;
                    ;

                getUnlinkedTable node = node.JoinTable.table;

                isTableUsedInJoin table = 
                    let
                        joinSubtreeNodes = filter (compose not isUnlinkedTable) joinNodes;
                        tablesUsedInJoins = removeDuplicates (concatMap getJoinTreeTables joinSubtreeNodes);
                    in
                        isElem table tablesUsedInJoins;
            in
                filter (\n -> not (isUnlinkedTable n && isTableUsedInJoin (getUnlinkedTable n))) joinNodes;

        // Combine join trees with tables in common, where possible.
        consolidateJoinNodes :: [JoinNode] -> [JoinNode];
        consolidateJoinNodes nodes = 
            case nodes of
            [] -> [];
            n : ns -> 
                let
                    nTables  = getJoinTreeTables n;
                    nsTables = removeDuplicates (concatMap getJoinTreeTables ns);

                    tablesOverlap = not (isEmpty (intersect nTables nsTables));

                    // Attempt to break the first node into a list of JoinInfo
                    // items.
                    nodeJoinInfos :: [JoinInfo];
                    nodeJoinInfos = joinNodeToJoinInfo n;
                in
                    // If the first node has tables in common with one or more
                    // of the other nodes
                    // then attempt to break it into JoinInfo items and apply
                    // them to the remaining nodes.
                    if (tablesOverlap && not (isEmpty nodeJoinInfos)) then foldLeftStrict applyJoinInfo ns nodeJoinInfos
                    else n : consolidateJoinNodes ns;
            ;
    in
        consolidateJoinNodes (cleanupUnjoinedTables joinNodesWithFixedTableNames);


/**
 * Attempts to break a {@link JoinNode@} into one or more {@link typeConstructor = JoinInfo@}s.
 * An empty list will be returned if the join node could not be represented
 * using {@code JoinInfo@}s.
 * 
 * TODO: instead of converting JoinNodes to JoinInfo, it would be better to
 * combine JoinNodes directly...
 */
joinNodeToJoinInfo :: JoinNode -> [JoinInfo];
private joinNodeToJoinInfo joinNode = 
    case joinNode of
    JoinSubtree {leftNode, rightNode, linkingExpr, joinType} -> 
        let
            leftTables  = getJoinTreeTables leftNode;
            rightTables = getJoinTreeTables rightNode;

            linkExprTables = getExpressionTables False (toUntypedExpr linkingExpr);

            leftTable  = if (isSingletonList leftTables) then listToMaybe leftTables 
                         else find (\t -> isElem t linkExprTables) leftTables;
            rightTable = if (isSingletonList rightTables) then listToMaybe rightTables 
                         else find (\t -> isElem t linkExprTables) rightTables;

            leftJoinInfos  = joinNodeToJoinInfo leftNode;
            rightJoinInfos = joinNodeToJoinInfo leftNode;

            joinInfos = 
                case leftTable of
                Nothing -> [];
                Just leftTableValue ->
                    case rightTable of
                    Nothing -> [];
                    Just rightTableValue ->
                        [makeJoinInfo2 leftTableValue rightTableValue linkingExpr joinType];
                    ;
                ;
        in
            leftJoinInfos ++ rightJoinInfos ++ joinInfos;

    _ -> [];
    ;


/**
 * Forces the specified table to be included in the query, even if no fields
 * from it are used in the rest of the query.
 */
addUnjoinedTable :: Query -> QueryTable -> Query;
public addUnjoinedTable query newUnjoinedTable = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction -> 
        let
            // Only add the unjoined table if it doesn't already appear in the
            // join trees.
            joinTables = concatMap getJoinTreeTables joins;
            newJoins = if (isElem newUnjoinedTable joinTables) then joins
                       else joins ++ [JoinTable newUnjoinedTable];
        in
            Query options columns restriction orderings newJoins groups groupRestriction;

    Union query1 query2 unionAll -> 
        // Add the table to both queries.
        Union (addUnjoinedTable query1 newUnjoinedTable) (addUnjoinedTable query2 newUnjoinedTable) unionAll;
    ;

/**
 * Adds grouping to the query.
 */
groupUntyped :: Query -> Expr -> Query;
private groupUntyped !query newGroup = 
    group2 query [newGroup];

/**
 * Adds grouping to the query.
 */
group :: Ord a => Query -> TypedExpr a -> Query;
public group query newGroup = groupUntyped query (toUntypedExpr newGroup);

/**
 * Adds grouping on the specified fields.
 */
group2 :: Query -> [Expr] -> Query;
public group2 query groupFields = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction ->
        Query options columns restriction orderings joins (groups ++ groupFields) groupRestriction;

    Union query1 query2 unionAll -> 
        // Add grouping to both queries.
        Union (group2 query1 groupFields) (group2 query2 groupFields) unionAll;
    ;



/**
 * Returns a list of the tables used in the query.
 * This will only include fields used in subqueries if the option is specified.
 */
getQueryTables :: Boolean -> Query -> [QueryTable];
public getQueryTables includeSubqueryTables query = 
    case query of
    Query {columns, restriction, orderings, joins, groups, groupRestriction} ->
        let
            columnExprs = map fst columns;
            restrictionExprs = 
                case restriction of
                Nothing -> [];
                Just restrictionValue -> [toUntypedExpr restrictionValue];
                ;

            groupRestrictionExprs = 
                case groupRestriction of
                Nothing -> [];
                Just groupRestrictionValue -> [toUntypedExpr groupRestrictionValue];
                ;

            orderingExprs = map fst orderings;
            allExprs = columnExprs ++ restrictionExprs ++ orderingExprs ++ groups ++ groupRestrictionExprs;

            exprTables = concatMap (getExpressionTables includeSubqueryTables) allExprs;

            tableAndSubTables queryTable = 
                case queryTable of
               (BaseTable |
                OpaqueSubQueryTable) {} -> [queryTable];
                SubQueryTable {subquery} -> 
                    if (includeSubqueryTables) then queryTable : getQueryTables True subquery else [queryTable];
                ;
            joinTablesOnly = concatMap getJoinTreeTables joins;
            joinTablesAndSubTables = concatMap tableAndSubTables joinTablesOnly;
            joinTables = if (includeSubqueryTables) then joinTablesAndSubTables else joinTablesOnly;
        in
            removeDuplicates (exprTables ++ joinTables);

    Union {query1, query2} -> 
        removeDuplicates ((getQueryTables includeSubqueryTables query1) ++ (getQueryTables includeSubqueryTables query2));
    ;

/**
 * Returns all the tables used in the specified expression.
 */
getExpressionTables :: Boolean -> Expr -> [QueryTable];
public getExpressionTables includeSubqueryTables expr = 
    let
        expressionTablesHelper expr = 
            case expr of
            QueryField {fieldName, queryTable} -> 
                case queryTable of
               (BaseTable |
                OpaqueSubQueryTable) {} -> [queryTable];
                SubQueryTable {subquery} -> 
                    if includeSubqueryTables then queryTable : getQueryTables True subquery
                    else [queryTable];
                ;
            ConstExpr {} -> [];
            ListExpr  {listValues} -> concatMap expressionTablesHelper listValues;
            FunctionExpr {arguments} -> concatMap expressionTablesHelper arguments;
            SubQueryExpr {subquery} -> if (includeSubqueryTables) then getQueryTables True subquery else [];
            ;
    in
        removeDuplicates (expressionTablesHelper expr);


/**
 * Returns a list of columns that belong to the given table and that are
 * referenced from within the given query. Only references from joins
 * and QueryField expressions in the list of projected columns are returned.
 * 
 * NOTE: This method was written to support the UBO PoC, so it is not meant
 * to be generally useful.  See module AggregationInfo.
 * 
 * @arg query The query.
 * @arg targetTable The table we're searching for references to.
 * @return A list of expressions that represent the columns belonging to
 *         targetTable.
 */
getColumnsForTable :: Query -> QueryTable -> [Expr];
public getColumnsForTable query targetTable = 
    case query of
    Query {columns, joins} ->
        let
            // Search the list of columns for references to the given table.
            // Only look for QueryField references, not references contained in 
            // functions.
            columnExprs = map fst columns;

            exprFilter :: Expr -> Boolean;
            exprFilter expr = 
                case expr of
                QueryField {fieldName, queryTable} -> queryTable == targetTable; 
                _ -> False;
                ;
                
            filteredColumns = filter exprFilter columnExprs;
            
            // Search the list of joins for references to the given table.  
            // Include references inside functions because these are part of the
            // join expressions.
            getColumnsFromExpr :: Expr -> [Expr];
            getColumnsFromExpr expr = 
                case expr of 
                QueryField {queryTable} -> if (queryTable == targetTable) then [expr] else  [];
                FunctionExpr {arguments} -> concatMap getColumnsFromExpr arguments;
                _ -> [];
                ;
            
            getColumnsFromJoins :: JoinNode -> [Expr];
            getColumnsFromJoins joinNode = 
                case joinNode of
                JoinTable {} -> [];
                JoinSubtree {leftNode, rightNode, linkingExpr} -> 
                    let 
                        expr = toUntypedExpr linkingExpr;
                    in
                        (getColumnsFromExpr expr) 
                        ++ (getColumnsFromJoins leftNode)
                        ++ (getColumnsFromJoins rightNode);
                ;
                    
            filteredJoins = concatMap getColumnsFromJoins joins;
            
        in
            removeDuplicates (filteredColumns ++ filteredJoins);
    ;

    
/**
 * Returns all the leaf tables from the specified join tree.
 */
getJoinTreeTables :: JoinNode -> [QueryTable];
public getJoinTreeTables rootJoinNode = 
    let
        getTablesHelper node = 
            case node of
            JoinTable {table} -> [table];
            JoinSubtree {leftNode, rightNode} -> (getTablesHelper leftNode) ++ (getTablesHelper rightNode);
            ;
    in
        removeDuplicates (getTablesHelper rootJoinNode);


/**
 * Applies the specified table modification function to all tables in the query.
 */
modifyTablesInQuery :: (QueryTable -> QueryTable) -> Query -> Query;
public modifyTablesInQuery updateTableFn !query = 
    let
        updateTypedExprTables :: TypedExpr a -> TypedExpr a;
        updateTypedExprTables expr = toTypedExpr (modifyTablesInExpr updateTableFn (toUntypedExpr expr));

        updateOrderingTables :: (Expr, Boolean) -> (Expr, Boolean);
        updateOrderingTables ordering = (modifyTablesInExpr updateTableFn (fst ordering), snd ordering);
    in
        case query of
        Query options columns restriction orderings joins groups groupRestriction ->
            let
                newColumns = map (\pr -> (modifyTablesInExpr updateTableFn (fst pr), snd pr)) columns;
                newRestriction = 
                    case restriction of
                    Nothing -> Nothing;
                    Just restrictionValue -> Just (updateTypedExprTables restrictionValue);
                    ;
                newGroupRestriction = 
                    case groupRestriction of
                    Nothing -> Nothing;
                    Just groupRestrictionValue -> Just (updateTypedExprTables groupRestrictionValue);
                    ;
                newOrderings = map updateOrderingTables orderings;
                newJoins = map (modifyTablesInJoinNode updateTableFn) joins;
                newGroups = map (modifyTablesInExpr updateTableFn) groups;
            in
                Query options newColumns newRestriction newOrderings newJoins newGroups newGroupRestriction;

        Union query1 query2 unionAll -> 
            Union (modifyTablesInQuery updateTableFn  query1) (modifyTablesInQuery updateTableFn  query2) unionAll;
    ;

/**
 * Applies the specified table modification function to all tables in the expression.
 */
modifyTablesInExpr :: (QueryTable -> QueryTable) -> Expr -> Expr;
public modifyTablesInExpr updateTableFn !expr = 
    case expr of
    QueryField {fieldName, queryTable} -> QueryField fieldName (updateTableFn queryTable);
    ConstExpr {} -> expr;
    ListExpr {listValues} -> ListExpr (map (modifyTablesInExpr updateTableFn) listValues);
    FunctionExpr {func, arguments} -> FunctionExpr func (map (modifyTablesInExpr updateTableFn) arguments);
    SubQueryExpr {subquery} -> SubQueryExpr (modifyTablesInQuery updateTableFn subquery);
    ;

/**
 * Applies the specified table modification function to all tables in the typed expression.
 */
modifyTablesInTypedExpr :: (QueryTable -> QueryTable) -> TypedExpr a -> TypedExpr a;
public modifyTablesInTypedExpr updateTableFn !typedExpr = 
    toTypedExpr (modifyTablesInExpr updateTableFn (toUntypedExpr typedExpr));

/**
 * Applies the specified table modification function to all tables in the join node.
 */
modifyTablesInJoinNode :: (QueryTable -> QueryTable) -> JoinNode -> JoinNode;
public modifyTablesInJoinNode updateTableFn !join =
    let
        updateBooleanExprTables :: TypedExpr Boolean -> TypedExpr Boolean;
        updateBooleanExprTables expr = toTypedExpr (modifyTablesInExpr updateTableFn (toUntypedExpr expr));
    in
        case join of
        JoinTable table ->
            JoinTable (updateTableFn table);
        JoinSubtree leftNode rightNode linkingExpr joinType -> 
            JoinSubtree (modifyTablesInJoinNode updateTableFn leftNode) 
                        (modifyTablesInJoinNode updateTableFn rightNode) 
                        (updateBooleanExprTables linkingExpr) joinType;
        ;

/**
 * Applies the specified table modification function to all tables in the join set.
 */
modifyTablesInJoinSet :: (QueryTable -> QueryTable) -> JoinSet -> JoinSet;
public modifyTablesInJoinSet updateTableFn !joinSet = 
    case joinSet of
    JoinSet {name, joins} -> 
        JoinSet name (modifyTablesInJoinNode updateTableFn joins);
    ;

/**
 * Applies the specified query modification function to the query and any
 * subqueries that it contains.
 */
modifyQueries :: (Query -> Query) -> Query -> Query;
public modifyQueries updateQueryFn query = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction ->
        let
            updateTableQueries queryTable = 
                case queryTable of
               (BaseTable |
                OpaqueSubQueryTable) {} -> queryTable;
                SubQueryTable {subquery, tableAlias} -> SubQueryTable (modifyQueries updateQueryFn subquery) tableAlias;
                ;

            updateExprQueries expr = 
                case expr of
                QueryField fieldName queryTable -> QueryField fieldName (updateTableQueries queryTable);
                ConstExpr constantValue -> expr;
                ListExpr listValues -> ListExpr (map updateExprQueries listValues);
                FunctionExpr func arguments -> FunctionExpr func (map updateExprQueries arguments);
                SubQueryExpr subquery -> SubQueryExpr (modifyQueries updateQueryFn subquery);
                ;

            updateTypedExprQueries expr = toTypedExpr (updateExprQueries (toUntypedExpr expr));

            updateOrderingQueries ordering = (updateExprQueries (fst ordering), snd ordering);

            updateJoinQueries join = 
                case join of
                JoinTable table ->
                    JoinTable (updateTableQueries table);
                JoinSubtree leftNode rightNode linkingExpr joinType -> 
                    JoinSubtree (updateJoinQueries leftNode) (updateJoinQueries rightNode) (updateTypedExprQueries linkingExpr) joinType;
                ;

            newColumns = map (\pr -> (updateExprQueries (fst pr), snd pr)) columns;
            newRestriction = 
                case restriction of
                Nothing -> Nothing;
                Just restrictionValue -> Just (updateTypedExprQueries restrictionValue);
                ;
            newGroupRestriction = 
                case groupRestriction of
                Nothing -> Nothing;
                Just groupRestrictionValue -> Just (updateTypedExprQueries groupRestrictionValue);
                ;
            newOrderings = map updateOrderingQueries orderings;
            newJoins = map updateJoinQueries joins;
            newGroups = map updateExprQueries groups;
        in
            updateQueryFn (Query options newColumns newRestriction newOrderings newJoins newGroups newGroupRestriction);

    Union query1 query2 unionAll -> 
        updateQueryFn (Union (modifyQueries updateQueryFn query1) (modifyQueries updateQueryFn query2) unionAll);
    ;


/**
 * Removed any joins which are including any tables which are otherwise unused
 * in the query.
 * An unused table will not be removed if is being used to join other tables
 * that are used in the query.
 */
removeUnusedTables :: Query -> Query;
public removeUnusedTables query = removeUnusedTables2 [] query;

/**
 * Removed any joins which are including any tables which are otherwise unused
 * in the query.
 * An unused table will not be removed if is being used to join other tables
 * that are used in the query.
 * Tables used by the anchorFields expressions will not be removed either.
 */
removeUnusedTables2 :: [Expr] -> Query -> Query;
public removeUnusedTables2 anchorFields query = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction ->
        let
            // Get the list of tables used in the query, excluding the joins and
            // unjoined tables in the main query.
            queryTables :: [QueryTable];
            queryTables = getQueryTables False (Query options columns restriction orderings [] groups groupRestriction);

            // Get the list of tables used by the anchor field expressions.
            anchorFieldTables :: [QueryTable];
            anchorFieldTables = concatMap (getExpressionTables True) anchorFields;

            // Get the combined list of tables in use.
            tablesInUse :: [QueryTable];
            tablesInUse = removeDuplicates (queryTables ++ anchorFieldTables);
        in
            Query options columns restriction orderings (removeUnusedTablesInJoinSets tablesInUse joins) groups groupRestriction;

    Union query1 query2 unionAll -> 
        Union (removeUnusedTables2 anchorFields query1) (removeUnusedTables2 anchorFields query2) unionAll;
    ;


/**
 * Returns a modified list of join nodes containing only the joins required for the specified tables.
 * This function will call itself recursively until no more tables can be removed.
 */
removeUnusedTablesInJoinSets :: [QueryTable] -> [JoinNode] -> [JoinNode];
removeUnusedTablesInJoinSets tablesInUse !joins = 
    let
        joinTables = removeDuplicates (concatMap getJoinTreeTables joins);
        unusedJoinTables = deleteFirsts joinTables tablesInUse;

        subtreeNodesInTree joinTree = 
            case joinTree of
            JoinSubtree {leftNode, rightNode} -> joinTree : (subtreeNodesInTree leftNode) ++ (subtreeNodesInTree rightNode);
            _ -> [];
            ;
        allSubtreeNodes = concatMap subtreeNodesInTree joins;

        // Only allow this table to be removed if the only join node
        // that refers to it in the linking expression
        // is its parent subtree node (or none at all).
        canRemoveTable table = 
            let
                subtreeUsesTableInLinkExpr node = 
                    case node of
                    JoinSubtree {linkingExpr} -> isElem table (getExpressionTables False (toUntypedExpr linkingExpr));
                    _ -> False;
                    ;

                subtreesUsingTableInLinkExpr = filter subtreeUsesTableInLinkExpr allSubtreeNodes;

                nodeJoinsTable node = 
                    case node of
                    JoinSubtree {leftNode, rightNode} ->
                        let
                            childNodeIsTable childNode = 
                                case childNode of
                                JoinTable childTable -> childTable == table;
                                _ -> False;
                                ;
                        in
                            (childNodeIsTable leftNode) || (childNodeIsTable rightNode);
                    _ -> False;
                    ;
            in
                isEmpty subtreesUsingTableInLinkExpr 
                    || isEmpty (tail subtreesUsingTableInLinkExpr) && nodeJoinsTable (head subtreesUsingTableInLinkExpr);

        tablesToRemove = filter canRemoveTable unusedJoinTables;

        removeTablesFromJoinTree :: JoinNode -> Maybe JoinNode;
        removeTablesFromJoinTree joinTree = 
            case joinTree of
            JoinTable {table} -> if (isElem table tablesToRemove) then Nothing else Just joinTree;
            JoinSubtree {leftNode, rightNode, linkingExpr, joinType} -> 
                let
                    newLeft = removeTablesFromJoinTree leftNode;
                    newRight = removeTablesFromJoinTree rightNode;
                in
                    case newLeft of
                    Nothing ->
                        newRight;
                    Just newLeftValue ->
                        case newRight of
                        Nothing ->
                            newLeft;
                        Just newRightValue ->
                            Just (JoinSubtree newLeftValue newRightValue linkingExpr joinType);
                        ;
                    ;
            ;

        newJoins = List.mapJust removeTablesFromJoinTree joins;
    in
        if (isEmpty tablesToRemove) then joins
        else removeUnusedTablesInJoinSets tablesInUse newJoins;

/**
 * Returns the best set of joins for the fields in the specified query.
 * An error will be thrown if an appropriate join set cannot be found.
 * If multiple join sets can be used for the query tables, then an error will be returned unless each 
 * of the compatible join sets uses the same joins to connect these tables (ignoring any joins unrelated to the 
 * tables in the query).
 * If a single table is required, then an arbitrary join set (containing this table) will be returned.
 * If no tables are needed, then {@link Nothing@} is returned.
 */
getBestJoinSetForQueryFields :: [JoinSet] -> Query -> [Expr] -> Maybe (UniqueIdentifier JoinSet) -> Maybe JoinSet;
public getBestJoinSetForQueryFields !joinSets !sqlQuery !anchorFieldExpressions !preferredJoinSetID = 
    let
        // Take anchor fields into account when determining which tables are in use.
        qryWithAnchorFields = project sqlQuery anchorFieldExpressions;

        // Don't include subquery tables or tables from within subqueries.
        queryTables = filter (\t -> not (isSubqueryTable t)) (getQueryTables False qryWithAnchorFields);

        // Returns True if the join set contains all the query tables.
        joinSetContainsQueryTables :: JoinSet -> Boolean;
        joinSetContainsQueryTables joinSet = 
            let
                joinTree = joinSetJoinTree joinSet;
                joinTreeTables = getJoinTreeTables joinTree;
            in
                // Check whether all the query tables are included in the join tree tables list.
                isEmpty (List.deleteFirsts queryTables joinTreeTables);

        // Determine which of the join sets contain all the necessary tables.
        compatibleJoinSets :: [JoinSet];
        compatibleJoinSets = filter joinSetContainsQueryTables joinSets;

        // Try to find the preferred join set (if any) in the list of compatible sets.
        preferredJoinSet :: Maybe JoinSet;
        preferredJoinSet = 
            case preferredJoinSetID of
            Nothing -> Nothing;
            Just preferredJoinSetID -> UniqueIdentifier.findMatchingUniquelyNamedItemById compatibleJoinSets preferredJoinSetID;
            ;
    in
        // Return Nothing if no tables are involved.
        if (isEmpty queryTables) then
            Nothing
        else if (List.isSingletonList queryTables) then 
            // Use an arbitrary join set if only 1 table is used.
            Prelude.listToMaybe compatibleJoinSets
        else if (isEmpty compatibleJoinSets) then
            // Throw an error if there are multiple tables and no appropriate join set could be found.
            error ("The dictionary does not contain a join set that includes all the specified fields."
                ++ "\nQuery: " ++ show sqlQuery
                ++ "\nAnchorFieldExpressions: " ++ show anchorFieldExpressions
                ++ "\nTables: " ++ show queryTables
                ++ "\nJoin Sets: " ++ show joinSets
                )
        else if (List.isSingletonList compatibleJoinSets) then
            // If a single join set is compatible, then use it.
            Prelude.listToMaybe compatibleJoinSets
        else if (isJust preferredJoinSet) then
            // If there are multiple compatible join sets, then check whether one of them is the preferred one (if any).
            preferredJoinSet
        else
            // There are multiple compatible join sets (and no preferred one is specified).
            // Reduce each of these to the joins involving the query tables.
            // If the remaining joins are equivalent in each set, then it is safe to return an arbitrary one of these, 
            // since they will all be the same as far as this query is concerned.
            // If the join sets use different joins to connect the tables in the query, then throw an error since
            // there is no way to know which join path is indended.
            let
                // Reduce each compatible join set such that it only includes the query tables.
                reducedJoinSets :: [[JoinNode]];
                reducedJoinSets = 
                    map (removeUnusedTablesInJoinSets queryTables # List.list1 # joinSetJoinTree) compatibleJoinSets;
            in
                // Check whether each compatible join set uses the same joins to connect the query tables.
                // TODO: perhaps more care needs to be taken when comparing whether 2 join nodes are equivalent...
                //       In some cases, the order and/or direction of the joins can be ignored.
                if (List.lengthAtLeast 2 (List.removeDuplicates reducedJoinSets)) then 
                    error "There is more than one join set compatible with the specified query."
                else 
                    Prelude.listToMaybe compatibleJoinSets;

/**
 * Adds the necessary grouping to the query to make it valid if there is any
 * grouping or aggregation.
 */
fixQueryForGroupBy :: Query -> Query;
private fixQueryForGroupBy query = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction ->
        let
            getExprAggregationExprs expr = 
                case expr of
                ListExpr {listValues} -> 
                    concatMap getExprAggregationExprs listValues;
                FunctionExpr {func, arguments} -> 
                    if (isAggregationFunction func) then [expr]
                    else concatMap getExprAggregationExprs arguments;
                _ -> [];
                ;

            allExprs = map fst columns ++ map fst orderings ++ map toUntypedExpr (maybeToList groupRestriction);
            aggregateExprs = concatMap getExprAggregationExprs allExprs;

            groupByNeeded = not (isEmpty groups) || not (isEmpty aggregateExprs);

            addGroupExprs !curGrouping !expr = 
                // If the expression is already grouped then nothing else is
                // necessary.
                if (isElem expr curGrouping) then 
                    curGrouping
                else
                    case expr of
                    QueryField {} -> curGrouping ++ [expr];
                    ConstExpr {} -> curGrouping;
                    ListExpr {listValues} -> foldLeftStrict addGroupExprs curGrouping listValues;
                    FunctionExpr {func, arguments} -> 
                        if (isAggregationFunction func) then curGrouping
                        else foldLeftStrict addGroupExprs curGrouping arguments;
                    SubQueryExpr {} -> curGrouping;
                    ;

            newGrouping = foldLeftStrict addGroupExprs groups allExprs;
        in
            if (groupByNeeded) then Query options columns restriction orderings joins newGrouping groupRestriction
            else query;

    Union query1 query2 unionAll -> 
        Union (fixQueryForGroupBy query1) (fixQueryForGroupBy query2) unionAll;
    ;

/**
 * Removes any constant expressions from the grouping and ordering lists.
 */
removeConstantGroupingAndOrdering :: Query -> Query;
removeConstantGroupingAndOrdering !query = 
    case query of
    Query options columns restriction orderings joins groups groupRestriction ->
        let
            newGroups :: [Expr];
            newGroups = filter (not # isExprConstant) groups;

            newOrderings :: [(Expr, Boolean)];
            newOrderings = filter (\!ord -> not (isExprConstant (field1 ord))) orderings;
        in
            // Handle the (common) case where nothing needs to be changed.
            if (length newGroups == length groups || length newOrderings == length orderings) then query
            else Query options columns restriction newOrderings joins newGroups groupRestriction;

    Union query1 query2 unionAll -> 
        Union (removeConstantGroupingAndOrdering query1) (removeConstantGroupingAndOrdering query2) unionAll;
    ;


/**
 * Returns whether the expression is a constant value or an expression composed of only constant values.
 */
isExprConstant :: Expr -> Boolean;
isExprConstant !expr = 
    case expr of
    QueryField {} -> False;
    ConstExpr {} -> True;
    ListExpr {listValues} -> 
        // Check whether all of the list values are constant.
        List.all isExprConstant listValues;
    FunctionExpr {arguments} -> 
        // Check whether all of the function argument values are constant.
        List.all isExprConstant arguments;
    SubQueryExpr {} -> 
        // For now, just assume that subqueries are never constant.
        // TODO: should the case where the subquery contains only constant values be handled?
        False;
    ;



//////////////////////////////////////////////////////////////////
// SQL Builder

/**
 * This is a helper object which is passed through the SQL builder code to keep
 * track of intermediate state.
 */
data public SqlBuilderState = 
    private SqlBuilderState 
        outerQueryTables :: [QueryTable];

/**
 * Creates an empty SQL builder state object.
 */
private newSqlBuilderState = SqlBuilderState [];

getStateOuterQueryTables :: SqlBuilderState -> [QueryTable];
private getStateOuterQueryTables !builderState = builderState.SqlBuilderState.outerQueryTables;

addQueryTablesToState :: SqlBuilderState -> [QueryTable] -> SqlBuilderState;
private addQueryTablesToState builderState newTables = 
    case builderState of
    SqlBuilderState {outerQueryTables} -> SqlBuilderState (removeDuplicates (outerQueryTables ++ newTables));
    ;


/**
 * This type holds various functions needed for converting primitive values to
 * text for the SQL query.
 */
data public PrimitiveValueBuilder = 
    private PrimitiveValueBuilder
        intToSqlFn          :: (Int -> Document)                         // (intVal)
        doubleToSqlFn       :: (Double -> Document)                      // (doubleVal)
        stringToSqlFn       :: (String -> Document)                      // (stringVal)
        timeToSqlFn         :: (Time -> TimeZone -> Document)            // (timeVal, timeZone)
        booleanToSqlFn      :: (Boolean -> Document)                     // (boolVal)
        nullToSqlFn         :: Document 
        timeIntervalToSqlFn :: (TimeInterval -> Document)                // (timeInterval)
        ;

/**
 * Constructs a new SQL primitive value builder with the specified functions.
 */
makePrimitiveValueBuilder :: (Int -> Document)                    // intToSql
                                                                  // (intVal)
                             -> (Double -> Document)              // doubleToSql
                                                                  // (doubleVal)
                             -> (String -> Document)              // stringToSql
                                                                  // (stringVal)
                             -> (Time -> TimeZone -> Document)    // timeToSql
                                                                  // (timeVal
                                                                  // timeZone)
                             -> (Boolean -> Document)             // booleanToSql
                                                                  // (boolVal)
                             -> Document                          // nullToSql
                             -> (TimeInterval -> Document)        // timeIntervalToSql(timeInterval)
                             -> PrimitiveValueBuilder;
public makePrimitiveValueBuilder = PrimitiveValueBuilder;


/**
 * The SQL Builder holds the various functions needed to construct the SQL query
 * text from a {@link typeConstructor = Query@}.
 * Different instances of this should be created for the different SQL
 * 'flavours'.
 */
data public SqlBuilder = 
    private SqlBuilder 
        prepareQueryFn :: 
            // (builderState query)
            (SqlBuilderState -> Query -> Query)        

        constructQueryFn :: 
            // (builderState selectBody fromBody whereBody 
            //               groupByBody havingBody orderByBody)
            (SqlBuilderState -> Document -> Document -> Document -> 
                                Document -> Document -> Document -> Document)

                    
        constructUnionQueryFn :: 
            // (builderState query1Text query2Text unionAll)
            (SqlBuilderState -> Document -> Document -> Boolean -> Document)

        buildSelectClauseFn ::
            // (builderState options exprsAndAliases)
            (SqlBuilderState -> [QueryOption] -> [(Expr, String)] -> Document)   
            
        buildFromClauseFn ::
            // (builderState joins)
            (SqlBuilderState -> [JoinNode] -> Document)
            
        buildWhereClauseFn ::
            // (builderState restrictions joins)
            (SqlBuilderState -> (Maybe Expr) -> [JoinNode] -> Document)
            
        buildOrderByClauseFn ::
            // (builderState orderExpressions)
            (SqlBuilderState -> [(Expr, Boolean)] -> Document)
            
        buildGroupByClauseFn ::
            // (builderState groupExpressions)
            (SqlBuilderState -> [Expr] -> Document)
        
        buildHavingClauseFn ::
            // (builderState groupRestrictions)
            (SqlBuilderState -> (Maybe Expr) -> Document)
            
        buildCreateDatabaseStatementFn ::
            // (databaseRef skipIfDatabaseExists)
            (DatabaseReference -> Boolean -> Document)

        buildDropDatabaseStatementFn ::
            // (databaseRef onlyIfDatabaseExists)
            (DatabaseReference -> Boolean -> Document)

        buildCreateTableStatementFn ::
            // (tableDesc skipIfTableExists)
            (TableDescription -> Boolean -> Document)

        buildCreateViewStatementFn :: 
            // (viewRef viewDefinition)
            (TableReference -> Query -> Boolean -> Document)

        buildDropTableStatementFn ::
            // (tableRef onlyIfTableExists)
            (TableReference -> Boolean -> Document)
            
        buildDropViewStatementFn ::
            // (viewRef onlyIfViewExists)
            (TableReference -> Boolean -> Document)
            
        buildInsertValuesStatementFn ::
            // (tableRef maybeDestColumns rowValues)
            (TableReference -> Maybe [String] -> [Expr] -> Document)

        buildInsertQueryValuesStatementFn :: 
            // (tableRef maybeDestColumns insertQuery)
            (TableReference -> Maybe [String] -> Query -> Document)

        buildUpdateValuesStatementFn :: 
            // (builderState tableRef destColumns newValues condition)
            (SqlBuilderState -> TableReference -> [String] -> [Expr] -> TypedExpr Boolean -> Document)

        buildDeleteRowsStatementFn :: 
            // (builderState tableRef, condition)
            (SqlBuilderState -> TableReference -> TypedExpr Boolean -> Document)

        buildCommitStatementFn ::
            Document
            
        buildFieldDescriptionFn ::
            // (fieldDesc)
            (FieldDescription -> Document)
            
        buildFieldTypeFn ::
            // (dataType)
            (SqlType -> Document)

        parameterToSqlFn ::
            (Parameter -> Document)
        
        listToSqlFn ::
            // (builderState exprList)
            (SqlBuilderState -> [Expr] -> Document)
            
        functionToSqlFn ::
            // (builderState func argExprs)
            (SqlBuilderState -> DbFunction -> [Expr] -> Document)

        addParensFn ::
            // (exprText)
            (Document -> Document)
            
        quoteIdentifierFn ::
            // (indentifierText)
            (String -> Document)

        buildTableAndAliasTextFn ::
            // (queryTable)
            (SqlBuilderState -> QueryTable -> Document)

        makeSafeNameFn ::
            // (name)
            (String -> String)

        primitiveValueBuilder ::
            PrimitiveValueBuilder
        
        ;

/**
 * Constructs a new SQL builder with the specified functions.
 */
makeSqlBuilder :: (SqlBuilderState -> Query -> Query)                                    // prepareQuery(builderState
                                                                                         // query)
                   
                   -> (SqlBuilderState -> Document -> Document -> Document -> 
                                      Document -> Document -> Document -> Document)      // constructQuery
                                                                                         // (builderState
                                                                                         // selectBody
                                                                                         // fromBody
                                                                                         // whereBody
                                                                                         // groupByBody
                                                                                         // havingBody
                                                                                         // orderByBody)
                   -> (SqlBuilderState -> Document -> Document -> Boolean -> Document)   // constructUnionQuery
                                                                                         // (builderState
                                                                                         // query1Text
                                                                                         // query2Text
                                                                                         // unionAll)

                   -> (SqlBuilderState -> [QueryOption] -> [(Expr, String)] -> Document) // buildSelectClause
                                                                                         // (builderState
                                                                                         // options
                                                                                         // exprsAndAliases)
                   -> (SqlBuilderState -> [JoinNode] -> Document)                        // buildFromClause
                                                                                         // (builderState
                                                                                         // joins)
                   -> (SqlBuilderState -> (Maybe Expr) -> [JoinNode] -> Document)        // buildWhereClause
                                                                                         // (builderState
                                                                                         // restrictions
                                                                                         // joins)
                   -> (SqlBuilderState -> [(Expr, Boolean)] -> Document)                 // buildOrderByClause
                                                                                         // (builderState
                                                                                         // orderExpressions)
                   -> (SqlBuilderState -> [Expr] -> Document)                            // buildGroupByClause
                                                                                         // (builderState
                                                                                         // groupExpressions)
                   -> (SqlBuilderState -> (Maybe Expr) -> Document)                      // buildHavingClause
                                                                                         // (builderState
                                                                                         // groupRestrictions)

                   -> (DatabaseReference -> Boolean -> Document)                         // buildCreateDatabaseStatement
                                                                                         // (databaseRef
                                                                                         // skipIfDatabaseExists)
                   -> (DatabaseReference -> Boolean -> Document)                         // buildDropDatabaseStatement
                                                                                         // (databaseRef
                                                                                         // onlyIfDatabaseExists)
                   -> (TableDescription -> Boolean -> Document)                          // buildCreateTableStatement
                                                                                         // (table
                                                                                         // fieldDescriptions
                                                                                         // constraints
                                                                                         // skipIfTableExists)
                   -> (TableReference -> Query -> Boolean -> Document)                   // buildCreateViewStatement
                                                                                         // (viewRef
                                                                                         // viewDefinition)
                   -> (TableReference -> Boolean -> Document)                            // buildDropTableStatement
                                                                                         // (table
                                                                                         // onlyIfTableExists)
                   -> (TableReference -> Boolean -> Document)                            // buildDropViewStatement
                                                                                         // (viewRef
                                                                                         // onlyIfViewExists)
                   -> (TableReference -> Maybe [String] -> [Expr] -> Document)           // buildInsertValuesStatement
                                                                                         // (table
                                                                                         // rowValues)
                   -> (TableReference -> Maybe [String] -> Query -> Document)            // buildInsertQueryValuesStatement
                                                                                         // (table
                                                                                         // insertQuery)
                   
                   -> (SqlBuilderState -> TableReference -> [String] -> [Expr] -> TypedExpr Boolean -> Document) // buildUpdateValuesStatementFn
                                                                                         // (table
                                                                                         // destColumns
                                                                                         // newValues
                                                                                         // condition
            
                   -> (SqlBuilderState -> TableReference -> TypedExpr Boolean -> Document) // buildDeleteRowsStatementFn 
                                                                                         // (table
                                                                                         // condition)
                   -> Document
                   -> (FieldDescription -> Document)                                     // buildFieldDescription
                                                                                         // (fieldDesc)
                   -> (SqlType -> Document)                                              // buildFieldType
                                                                                         // (dataType)

                   -> (Parameter -> Document)
                   -> (SqlBuilderState -> [Expr] -> Document)                            // listToSql
                                                                                         // (builderState
                                                                                         // exprList)
                   -> (SqlBuilderState -> DbFunction -> [Expr] -> Document)              // functionToSql
                                                                                         // (builderState
                                                                                         // func
                                                                                         // argExprs)

                   -> (Document -> Document)                                             // addParens
                                                                                         // (exprText)
                   -> (String -> Document)                                               // quoteIdentifier
                                                                                         // (indentifierText)

                   -> (SqlBuilderState -> QueryTable -> Document)                        // buildTableAndAliasText
                                                                                         // (queryTable)

                   -> (String -> String)                                                 // makeSafeName
                                                                                         // (name)

                   -> PrimitiveValueBuilder                                              // primitiveValueBuilder
                   -> SqlBuilder;
public makeSqlBuilder = SqlBuilder;

/**
 * This function gives the SQL builder a chance to alter the structure of the
 * query in order to simplify building of the query text.
 */
prepareToBuildQueryText :: SqlBuilder -> SqlBuilderState -> Query -> Query;
private prepareToBuildQueryText !sqlBuilder builderState query = 
    (sqlBuilder.SqlBuilder.prepareQueryFn) builderState query;
 
/**
 * Constructs a complete SQL query from the component parts.
 */
constructQuery :: SqlBuilder -> SqlBuilderState -> Document -> Document -> Document -> Document -> Document -> Document -> Document;
private constructQuery !sqlBuilder builderState selectBody fromBody whereBody groupByBody havingBody orderByBody = 
    (sqlBuilder.SqlBuilder.constructQueryFn) builderState selectBody fromBody whereBody groupByBody havingBody orderByBody;

constructUnionQuery :: SqlBuilder -> SqlBuilderState -> Document -> Document -> Boolean -> Document;
private constructUnionQuery !sqlBuilder builderState query1Text query2Text unionAll = 
    (sqlBuilder.SqlBuilder.constructUnionQueryFn) builderState query1Text query2Text unionAll;


/**
 * Constructs the text of the SELECT clause for the query, not including the
 * 'SELECT' keyword (or equivalent).
 */
buildSelectClause  :: SqlBuilder -> SqlBuilderState -> [QueryOption] -> [(Expr, String)] -> Document;
private buildSelectClause !sqlBuilder builderState options exprsAndAliases = 
    (sqlBuilder.SqlBuilder.buildSelectClauseFn) builderState options exprsAndAliases;

/**
 * Constructs the text of the FROM clause for the query, not including the 'FROM'
 * keyword (or equivalent).
 */
buildFromClause :: SqlBuilder -> SqlBuilderState -> [JoinNode] -> Document;
private buildFromClause !sqlBuilder builderState joins = 
    (sqlBuilder.SqlBuilder.buildFromClauseFn) builderState joins;

/**
 * Constructs the text of the WHERE clause for the query, not including the
 * 'WHERE' keyword (or equivalent).
 */
buildWhereClause :: SqlBuilder -> SqlBuilderState -> (Maybe Expr) -> [JoinNode] -> Document;
private buildWhereClause !sqlBuilder builderState restrictions joins = 
    (sqlBuilder.SqlBuilder.buildWhereClauseFn) builderState restrictions joins;

/**
 * Constructs the text of the ORDER BY clause for the query, not including the
 * 'ORDER BY' keyword (or equivalent).
 */
buildOrderByClause :: SqlBuilder -> SqlBuilderState -> [(Expr, Boolean)] -> Document;
private buildOrderByClause !sqlBuilder builderState orderExpressions = 
    (sqlBuilder.SqlBuilder.buildOrderByClauseFn) builderState orderExpressions;

/**
 * Constructs the text of the GROUP BY clause for the query, not including the
 * 'GROUP BY' keyword (or equivalent).
 */
buildGroupByClause :: SqlBuilder -> SqlBuilderState -> [Expr] -> Document;
private buildGroupByClause !sqlBuilder builderState groupExpressions = 
    (sqlBuilder.SqlBuilder.buildGroupByClauseFn) builderState groupExpressions;

/**
 * Constructs the text of the HAVING clause for the query, not including the
 * 'HAVING' keywork (or equivalent).
 */
buildHavingClause :: SqlBuilder -> SqlBuilderState -> (Maybe Expr) -> Document;
private buildHavingClause !sqlBuilder builderState groupRestrictions = 
    (sqlBuilder.SqlBuilder.buildHavingClauseFn) builderState groupRestrictions;

/**
 * Returns the primitive value builder associated with the SQL builder.
 */
primitiveValueBuilder :: SqlBuilder -> PrimitiveValueBuilder;
private primitiveValueBuilder !sqlBuilder = sqlBuilder.SqlBuilder.primitiveValueBuilder;

/**
 * Builds the SQL text for an int constant.
 */
intToSql :: SqlBuilder -> Int -> Document;
private intToSql !sqlBuilder intVal = 
    (primitiveValueBuilder sqlBuilder).PrimitiveValueBuilder.intToSqlFn intVal;

/**
 * Builds the SQL text for a double constant.
 */
doubleToSql :: SqlBuilder -> Double -> Document;
private doubleToSql !sqlBuilder doubleVal = 
    (primitiveValueBuilder sqlBuilder).PrimitiveValueBuilder.doubleToSqlFn doubleVal;

/**
 * Builds the SQL text for a string constant.
 */
stringToSql :: SqlBuilder -> String -> Document;
private stringToSql !sqlBuilder stringVal = 
    (primitiveValueBuilder sqlBuilder).PrimitiveValueBuilder.stringToSqlFn stringVal;

/**
 * Builds the SQL text for a time constant.
 */
timeToSql :: SqlBuilder -> Time -> TimeZone -> Document;
private timeToSql !sqlBuilder timeVal timeZone = 
    (primitiveValueBuilder sqlBuilder).PrimitiveValueBuilder.timeToSqlFn timeVal timeZone;

/**
 * Builds the SQL text for a boolean constant.
 */
booleanToSql :: SqlBuilder -> Boolean -> Document;
private booleanToSql !sqlBuilder boolVal = 
    (primitiveValueBuilder sqlBuilder).PrimitiveValueBuilder.booleanToSqlFn boolVal;

/**
 * Builds the SQL text for a null value constant.
 */
nullToSql :: SqlBuilder -> Document;
private nullToSql !sqlBuilder = 
    (primitiveValueBuilder sqlBuilder).PrimitiveValueBuilder.nullToSqlFn;

/**
 * Builds the SQL text for a time interval constant.
 */
timeIntervalToSql :: SqlBuilder -> TimeInterval -> Document;
public timeIntervalToSql !sqlBuilder timeInterval = 
    (primitiveValueBuilder sqlBuilder).PrimitiveValueBuilder.timeIntervalToSqlFn timeInterval;

/**
 * Builds the SQL text for a list of expressions.
 */
parameterToSql :: SqlBuilder -> Parameter -> Document;
private parameterToSql !sqlBuilder !parameter =
    sqlBuilder.SqlBuilder.parameterToSqlFn parameter;

/**
 * Builds the SQL text for a list of expressions.
 */
listToSql :: SqlBuilder -> SqlBuilderState -> [Expr] -> Document;
private listToSql !sqlBuilder builderState exprList = 
    (sqlBuilder.SqlBuilder.listToSqlFn) builderState exprList;

/**
 * Builds the SQL text for a SQL function application.
 */
functionToSql :: SqlBuilder -> SqlBuilderState -> DbFunction -> [Expr] -> Document;
private functionToSql !sqlBuilder builderState func argExprs = 
    (sqlBuilder.SqlBuilder.functionToSqlFn) builderState func argExprs;

/**
 * Adds parentheses around some expression text.
 */
addParens :: SqlBuilder -> Document -> Document;
public addParens !sqlBuilder exprText = 
    (sqlBuilder.SqlBuilder.addParensFn) exprText;

/**
 * Adds quotes to a name (such as a table).
 */
quoteIdentifier :: SqlBuilder -> String -> Document;
public quoteIdentifier !sqlBuilder indentifierText = 
    (sqlBuilder.SqlBuilder.quoteIdentifierFn) indentifierText;

/**
 * Builds a table name and optional table alias.
 */
buildTableAndAliasText :: SqlBuilder -> SqlBuilderState -> QueryTable -> Document;
public buildTableAndAliasText !sqlBuilder builderState queryTable = 
    (sqlBuilder.SqlBuilder.buildTableAndAliasTextFn) builderState queryTable;


/**
 * Returns a 'safe' version of the specified name.
 */
makeSafeSqlName :: SqlBuilder -> String -> String;
public makeSafeSqlName !sqlBuilder name = 
    (sqlBuilder.SqlBuilder.makeSafeNameFn) name;

/**
 * Returns 'safe' versions of the specified names.
 * The names will all be distinct.
 */
makeSafeSqlNames :: SqlBuilder -> [String] -> [String] -> [String];
public makeSafeSqlNames sqlBuilder namesInUse names = 
    let
        safeNames = map (makeSafeSqlName sqlBuilder) names;
    in
        makeUniqueNames namesInUse safeNames;

/**
 * Returns an updated version of the name list where each name is unique.
 * The name comparisons are not case sensitive.
 * The names will be made unique by appending an integer to the end of the name.
 * 
 * TODO: perhaps this should take into account the maximum length for various
 * names for the database...
 */
makeUniqueNames :: [String] -> [String] -> [String];
public makeUniqueNames namesAlreadyInUse names = 
    let
        makeUniqueNamesHelper :: Set String -> [String] -> [String];
        makeUniqueNamesHelper namesInUse names = 
            case names of
            [] -> [];
            n : ns -> 
                let
                    uniqueName = getUniqueName namesInUse n 0;
                    updatedNamesInUse = Set.insert (toLowerCase uniqueName) namesInUse;
                in
                    uniqueName : makeUniqueNamesHelper updatedNamesInUse ns;
            ;

        getUniqueName :: Set String -> String -> Int -> String;
        getUniqueName namesInUse name attemptN = 
            let
                attemptedName = if (attemptN == 0) then name else name ++ (intToString attemptN);
            in
                if (isEmpty attemptedName) then
                    attemptedName
                else if (Set.member (toLowerCase attemptedName) namesInUse) then 
                    getUniqueName namesInUse name (attemptN + 1)
                else 
                    attemptedName;
    in
        makeUniqueNamesHelper (Set.fromList (map toLowerCase namesAlreadyInUse)) names;


/**
 * Builds the query text for a single expression.
 * Note that this should only be called to generate text for top-level
 * expressions.
 * For expressions embedded in a SQL query or other expressions, call
 * {@link expressionText2@} instead and provide the appropriate {@code builderState@}.
 */
expressionText :: SqlBuilder -> Expr -> String;
public expressionText builder expr = 
    let
        displayWidth = 1 :: Int;
        doc = expressionText2 builder newSqlBuilderState expr;
    in
        PrettyPrinter.pretty displayWidth doc;

/**
 * Builds the query text for a single expression.
 */
expressionText2 :: SqlBuilder -> SqlBuilderState -> Expr -> Document;
public expressionText2 builder builderState expr = 
    let
        // TODO: how should this info be supplied?
        timeZone = TimeZone.currentTimeZone;
    in
        case expr of
        QueryField {fieldName, queryTable} -> 
            let
                tableAlias = quoteIdentifier builder (getQueryTableAlias queryTable);
                fieldNameText = quoteIdentifier builder fieldName;
            in
                if (isEmpty tableAlias) then fieldNameText
                else tableAlias ++ text "." ++ fieldNameText;

        ConstExpr {constantValue} ->
            case constantValue of
            NullValue -> nullToSql builder;
            StringValue {strValue} -> stringToSql builder strValue;
            NumberValue {numValue} -> doubleToSql builder numValue;
            BooleanValue {boolValue} -> booleanToSql builder boolValue;
            TimeValue {timeValue} -> timeToSql builder timeValue timeZone;
            _ -> error "Unknown constant value type";
        ;
        
        ParameterExpr {parameter} ->
            parameterToSql builder parameter;

        ListExpr {listValues} ->
            listToSql builder builderState listValues;

        FunctionExpr {func, arguments} ->
            functionToSql builder builderState func arguments;

        SubQueryExpr {subquery} ->
            addParens builder (nest 4 (line ++ queryText2 builder builderState (fixSubqueryOrdering subquery)) ++ line);
    ;


/**
 * Returns whether the function is really an operator (in-fix).
 */
isOperator :: DbFunction -> Boolean;
public isOperator func = operatorPrecedence func > 0;

/**
 * Returns the precedence of the specified operator.
 * An operation with a higher precendence value will be done first.
 */
operatorPrecedence :: DbFunction -> Int;
public operatorPrecedence func = 
    case func of
    OpNot    -> 5;
    OpBitNot -> 7;
    OpNegate -> 7;

    OpEq     -> 4;
    OpLt     -> 4;
    OpLtEq   -> 4;
    OpGt     -> 4;
    OpGtEq   -> 4;
    OpNotEq  -> 4;

    OpAnd    -> 2;
    OpOr     -> 1;

    OpLike   -> 4;
    OpIn     -> 4;

    OpCat    -> 5;

    OpPlus   -> 5;
    OpMinus  -> 5;
    OpMul    -> 6;
    OpDiv    -> 6;
    OpMod    -> 6;

    OpBetween -> 4;
    OpCase_Simple -> 4;
    OpCase_Searched -> 4;

    OpBitAnd -> 3;
    OpBitOr  -> 3;
    OpBitXor -> 3;

    OpExists -> 9;

    OpIsNull -> 8;
    OpIsNotNull -> 8;

    _ -> 0; // Not an operator.
    ;

exprOperatorPrecedence :: Expr -> Int;
public exprOperatorPrecedence expr = 
    case expr of
    FunctionExpr {func} -> operatorPrecedence func;
    _ -> 0; // Not an operator.
    ;


/**
 * Removes ordering for the subquery unless it is required (as with a {@link TopN@}
 * query).
 */
private fixSubqueryOrdering subquery = if (isTopNQuery subquery) then subquery else removeOrdering subquery;


/**
 * Builds the query text for a table name (including quotes where needed).
 */
tableNameText :: SqlBuilder -> SqlBuilderState -> QueryTable -> Document;
public tableNameText builder builderState queryTable = 
    case queryTable of
    BaseTable {tableRef} ->
        quoteIdentifier builder (getTableNameFromReference tableRef); // TODO:
                                                                      // quote
                                                                      // each
                                                                      // part of
                                                                      // the
                                                                      // qualified
                                                                      // name...
    SubQueryTable {subquery} -> 
        addParens builder (nest 4 (line ++ queryText2 builder builderState (fixSubqueryOrdering subquery)) ++ line);

    OpaqueSubQueryTable {subqueryText} -> 
        addParens builder (nest 4 (line ++ multilineText subqueryText) ++ line);
    ;

/**
 * Generates the SQL text for the specified database query.
 */
queryText :: SqlBuilder -> Boolean -> Query -> String;
public queryText builder !forDisplay query = 
    let
        displayWidth = 1 :: Int;
        width = if forDisplay then displayWidth :: Int else Prelude.maxBound;
    in
        PrettyPrinter.pretty width $ queryTextDocument builder query;

/**
 * Generates the SQL text document for the specified database query.
 */
queryTextDocument :: SqlBuilder -> Query -> Document;
public queryTextDocument builder query = 
    let
        builderState = newSqlBuilderState;
        fixedGroupingQuery = modifyQueries fixQueryForGroupBy query;
        removedConstantsQuery = modifyQueries removeConstantGroupingAndOrdering fixedGroupingQuery;

        preparedQuery = modifyQueries (prepareToBuildQueryText builder builderState) removedConstantsQuery;
    in
        queryText2 builder builderState preparedQuery;

/**
 * Generates the SQL text for the specified database query.
 */
queryText2 :: SqlBuilder -> SqlBuilderState -> Query -> Document;
private queryText2 builder builderState query = 
    case (checkValidQuery query) of
    Query {options, columns, restriction, orderings, joins, groups, groupRestriction} ->
        let
            // For a subquery, exclude any tables which are used in outer
            // queries.
            allQueryTables = getQueryTables False query;
            outerQueryTables = getStateOuterQueryTables builderState;
            queryTables = deleteFirsts allQueryTables outerQueryTables;

            newBuilderState = addQueryTablesToState builderState queryTables;

            untypedRestriction = 
                case restriction of
                Nothing -> Nothing;
                Just restrictionValue -> Just (toUntypedExpr restrictionValue);
                ;
            untypedGroupRestriction = 
                case groupRestriction of
                Nothing -> Nothing;
                Just groupRestrictionValue -> Just (toUntypedExpr groupRestrictionValue);
                ;

            // Include extra JoinTables for any tables in use in the query that
            // aren't already included in the joins.
            updatedJoins = 
                let
                    joinTables = removeDuplicates (concatMap getJoinTreeTables joins);
                    tablesNotInJoins = deleteFirsts queryTables joinTables;
                in
                    joins ++ (map JoinTable tablesNotInJoins);

            // Avoid including the same expression multiple times in the GROUP
            // BY or ORDER BY clause.
            updatedGrouping  = removeDuplicates groups;
            updatedOrderings = removeDuplicatesBy (\o1 o2 -> fst o1 == fst o2) orderings;

            selectBody  = buildSelectClause builder newBuilderState options columns;
            fromBody    = buildFromClause builder newBuilderState updatedJoins;
            whereBody   = buildWhereClause builder newBuilderState untypedRestriction updatedJoins;
            groupByBody = buildGroupByClause builder newBuilderState updatedGrouping;
            havingBody  = buildHavingClause builder newBuilderState untypedGroupRestriction;
            orderByBody = buildOrderByClause builder newBuilderState updatedOrderings;
        in
            constructQuery builder newBuilderState selectBody fromBody whereBody groupByBody havingBody orderByBody;

    Union {query1, query2, unionAll} -> 
        let
            // Enclose any child UNION in quotes if its union type doesn't match
            // the outer one.
            childQueryText childQuery = 
                let
                    baseQueryText = queryText2 builder builderState childQuery;
                in
                    case childQuery of
                    Union {unionAll=innerUnionAll} ->
                        if (innerUnionAll != unionAll) then addParens builder baseQueryText 
                        else baseQueryText;
                    _ -> baseQueryText;
                    ;
            query1Text = queryText2 builder builderState query1;
            query2Text = childQueryText query2;
        in
            constructUnionQuery builder builderState query1Text query2Text unionAll;
    ;


///**
// * Assigns unique table aliases to each table in the query.
// */
//makeUniqueQueryTableAliases :: Query -> Query;
//public makeUniqueQueryTableAliases query = 
//    let
//        // Get the list of all base alias and ID combinations from the query.
//        allQueryTables :: [QueryTable];
//        allQueryTables = getQueryTables True query;
//
//        aliasInfoForTable :: QueryTable -> (String, Long);
//        aliasInfoForTable table = 
//            case table of
//            (BaseTable| SubQueryTable | OpaqueSubQueryTable) {baseAlias, tableID} -> (baseAlias, tableID);
//            ;
//
//        tableAliasInfo :: [(String, Long)];
//        tableAliasInfo = removeDuplicates (map aliasInfoForTable allQueryTables);
//
//        newTableAliasInfoMap :: [((String, Long), Long)];
//        newTableAliasInfoMap = map (\aliasInfo -> (aliasInfo, nextTableID)) tableAliasInfo;
//
//        lookupNewTableAlias :: String -> Long -> Long;
//        lookupNewTableAlias baseAlias oldTableID = lookupWithDefault (baseAlias, oldTableID) 
//                                                                     newTableAliasInfoMap
//                                                                     (error ("Failed to find new table alias for '" ++ baseAlias ++ "'"));
//        updateQueryTableFn table = 
//            case table of
//            BaseTable table baseAlias tableID -> 
//                BaseTable table baseAlias (lookupNewTableAlias baseAlias tableID);
//            SubQueryTable subquery baseAlias tableID -> 
//                SubQueryTable (modifyTablesInQuery updateQueryTableFn subquery) baseAlias (lookupNewTableAlias baseAlias tableID);
//            OpaqueSubQueryTable subqueryText baseAlias tableID -> 
//                OpaqueSubQueryTable subqueryText baseAlias (lookupNewTableAlias baseAlias tableID);
//            ;
//    in
//        modifyTablesInQuery updateQueryTableFn query;


/**
 * Throws an error if the query is not valid.
 */
checkValidQuery :: Query -> Query;
private checkValidQuery query = 
    // TODO: check other aspects of the query...
    checkValidGroupByQuery (checkValidResultColumns query);


/**
 * Checks that there is at least one return column.
 * 
 * TODO: also check that the return columns are of valid types.... (Is a
 * ListExpr valid as a return column?)
 */
checkValidResultColumns :: Query -> Query;
private checkValidResultColumns query = 
    case query of
    Query {columns} ->
        if (isEmpty columns) then error "At least one return column must be specified in the query."
        else query;
    Union {query1, query2, unionAll} -> 
        Union (checkValidResultColumns query1) (checkValidResultColumns query2) unionAll;
    ;

/**
 * If there is any grouping fields in the query, then this will
 * check that all the return column expressions are group on or
 * are aggregate expressions.
 */
checkValidGroupByQuery :: Query -> Query;
private checkValidGroupByQuery query = 
    case query of
    Query {columns, groups} ->
        let
            isGroupingExpression expr = isElem expr groups;

            expressionOk expr = 
                // First check whether this is one of the grouping
                // expressions for the query.
                if (isGroupingExpression expr) then True
                else
                    case expr of
                    QueryField {} -> 
                        // This is only ok if this is a grouping expression
                        // (which has already been checked).
                        False;

                    ConstExpr {} ->
                        // Constant expressions are always ok.
                        True;

                    ListExpr  {listValues} ->
                        all expressionOk listValues;    // TODO: is this
                                                        // correct?

                    FunctionExpr {func, arguments} ->
                        // Aggregate expressions are always ok.
                        if (isAggregationFunction func) then True
                        else all expressionOk arguments;

                    SubQueryExpr {} -> 
                        // TODO: is this ok?
                        True;
                    ;

            columnExprs  = map fst columns;
            allColumnsOk = all expressionOk columnExprs;
        in
            if (isEmpty groups || allColumnsOk) then query
            else error "Invalid grouping query specified.";

    Union {query1, query2, unionAll} -> 
        Union (checkValidGroupByQuery query1) (checkValidGroupByQuery query2) unionAll;
    ;


/**
 * SQL statements to modify tables and/or values.
 */
data public Statement = 
    private CreateDatabaseStatement // CREATE DATABASE is not part of the SQL-92 standard, but most DB servers support it
        databaseRef          :: DatabaseReference
        skipIfDatabaseExists :: Boolean
    |
    private DropDatabaseStatement // DROP DATABASE is not part of the SQL-92 standard, but most DB servers support it
        databaseRef          :: DatabaseReference
        onlyIfDatabaseExists :: Boolean
    |
    private CreateTableStatement 
        tableDesc         :: TableDescription 
        skipIfTableExists :: Boolean
    |
    private CreateViewStatement
        viewRef           :: TableReference 
        viewDefinition    :: Query
        skipIfViewExists  :: Boolean
    |
    private DropTableStatement 
        tableRef          :: TableReference 
        onlyIfTableExists :: Boolean
    |
    private DropViewStatement
        viewRef           :: TableReference 
        onlyIfViewExists  :: Boolean
    |
    private InsertValuesStatement 
        tableRef          :: TableReference 
        maybeDestColumns  :: (Maybe [String])
        rowValues         :: [Expr]
    |
    private InsertQueryValuesStatement 
        tableRef          :: TableReference 
        maybeDestColumns  :: (Maybe [String])
        insertQuery       :: Query
    |
    private UpdateValuesStatement
        tableRef          :: TableReference 
        destColumns       :: [String]
        newValues         :: [Expr]
        condition         :: (TypedExpr Boolean)
    |
    private DeleteRowsStatement
        tableRef          :: TableReference
        condition         :: (TypedExpr Boolean)
    |
    private CommitStatement
    |
    private CompoundStatement 
        statements        :: [Statement]
    ;

makeCreateDatabaseStatement :: DatabaseReference -> Boolean -> Statement;
public makeCreateDatabaseStatement = CreateDatabaseStatement;

makeDropDatabaseStatement :: DatabaseReference -> Boolean -> Statement;
public makeDropDatabaseStatement = DropDatabaseStatement;

makeCreateTableStatement :: TableDescription -> Boolean -> Statement;
public makeCreateTableStatement = CreateTableStatement;

makeCreateViewStatement :: TableReference -> Query -> Boolean -> Statement;
public makeCreateViewStatement = CreateViewStatement;

makeDropTableStatement :: TableReference -> Boolean -> Statement;
public makeDropTableStatement = DropTableStatement;

makeDropViewStatement :: TableReference -> Boolean -> Statement;
public makeDropViewStatement = DropViewStatement;

makeInsertValuesStatement :: TableReference -> [Expr] -> Statement;
public makeInsertValuesStatement tableRef rowValues = 
    InsertValuesStatement tableRef Nothing rowValues;

makeInsertValuesByColumnStatement :: TableReference -> [String] -> [Expr] -> Statement;
public makeInsertValuesByColumnStatement tableRef destColumns rowValues = 
    InsertValuesStatement tableRef (Just destColumns) rowValues;

makeInsertQueryValuesStatement :: TableReference -> Query -> Statement;
public makeInsertQueryValuesStatement tableRef insertQuery = 
    InsertQueryValuesStatement tableRef Nothing insertQuery;
                     
makeInsertQueryValuesByColumnStatement :: TableReference -> [String] -> Query -> Statement;
public makeInsertQueryValuesByColumnStatement tableRef destColumns insertQuery = 
    InsertQueryValuesStatement tableRef (Just destColumns) insertQuery;

makeUpdateValuesStatement :: TableReference -> [String] -> [Expr] -> TypedExpr Boolean -> Statement;
public makeUpdateValuesStatement tableRef destColumns newValues condition = 
    UpdateValuesStatement tableRef destColumns newValues condition;

makeDeleteRowsStatement :: TableReference -> TypedExpr Boolean -> Statement;
public makeDeleteRowsStatement tableRef condition =
    DeleteRowsStatement tableRef condition;

makeCommitStatement :: Statement;
public makeCommitStatement = CommitStatement;

/**
 * Creates a compound statement from a list of statements.  This function
 * will attempt to flatten any compound statements contained in the argument
 * list.
 */
makeCompoundStatement :: [Statement] -> Statement;
public makeCompoundStatement statements =
    let
       makeCompoundStatementHelper :: Statement -> [Statement];
       makeCompoundStatementHelper stmt =
           case stmt of
           CompoundStatement {statements} -> statements;
           _ -> [stmt];
           ;
    in
        CompoundStatement (concatMap makeCompoundStatementHelper statements); 

/**
 * Linearizes the structure of the given statement by extracting all
 * statements nested in any compound statement.  This function will be
 * invoked recursively on all compound statements.  If the given statement
 * is not a compound statement, then it will be returned as is.  
 * @arg statement
 * @return A linearized/flattened list of statement.
 */
linearizeStatement :: Statement -> [Statement];
public linearizeStatement statement =
    let
        serializeStatementFoldFn :: Statement -> [Statement] -> [Statement];
        serializeStatementFoldFn !stmt stmtList =
            case stmt of
            CompoundStatement {statements} ->
                foldRight serializeStatementFoldFn stmtList statements;
            _ ->
                stmt : stmtList;
            ;
    in
        foldRight serializeStatementFoldFn [] [statement];

/**
 * Breaks a compound statement into multiple compound statements with a smaller
 * statement count.  This function assumes that it is not possible to create
 * nested compound statements.
 */
splitCompoundStatement :: Statement -> Int -> [Statement];
public splitCompoundStatement stmt maxCount =
    case stmt of
    CompoundStatement {statements} ->
        List.map makeCompoundStatement (chop maxCount statements);
    _ -> [stmt];
    ;

/**
 * Generates the SQL text for a statement.
 */
statementText :: SqlBuilder -> Boolean -> Statement -> String;
public statementText !builder !forDisplay statement = 
    case builder of
    SqlBuilder {buildCreateDatabaseStatementFn,
                buildDropDatabaseStatementFn,
                buildCreateTableStatementFn,
                buildCreateViewStatementFn,
                buildDropTableStatementFn,
                buildDropViewStatementFn,
                buildInsertValuesStatementFn,
                buildInsertQueryValuesStatementFn,
                buildUpdateValuesStatementFn,
                buildDeleteRowsStatementFn,
                buildCommitStatementFn} ->
        let
            displayWidth = 1 :: Int;
            width = if forDisplay then displayWidth :: Int else Prelude.maxBound;

            docForStatement statement = 
                case statement of
                CreateDatabaseStatement {databaseRef, skipIfDatabaseExists} ->
                    buildCreateDatabaseStatementFn databaseRef skipIfDatabaseExists;
                DropDatabaseStatement {databaseRef, onlyIfDatabaseExists} ->
                    buildDropDatabaseStatementFn databaseRef onlyIfDatabaseExists;
                CreateTableStatement {tableDesc, skipIfTableExists} -> 
                    buildCreateTableStatementFn tableDesc skipIfTableExists;
                CreateViewStatement {viewRef, viewDefinition, skipIfViewExists} -> 
                    buildCreateViewStatementFn viewRef viewDefinition skipIfViewExists;
                DropTableStatement {tableRef, onlyIfTableExists} -> 
                    buildDropTableStatementFn tableRef onlyIfTableExists;
                DropViewStatement {viewRef, onlyIfViewExists} -> 
                    buildDropViewStatementFn viewRef onlyIfViewExists;
                InsertValuesStatement {tableRef, maybeDestColumns, rowValues} -> 
                    buildInsertValuesStatementFn tableRef maybeDestColumns rowValues;
                InsertQueryValuesStatement {tableRef, maybeDestColumns, insertQuery} -> 
                    buildInsertQueryValuesStatementFn tableRef maybeDestColumns insertQuery;
                UpdateValuesStatement {tableRef, destColumns, newValues, condition} -> 
                    buildUpdateValuesStatementFn newSqlBuilderState tableRef destColumns newValues condition;
                DeleteRowsStatement {tableRef, condition} -> 
                    buildDeleteRowsStatementFn newSqlBuilderState tableRef condition;
                CommitStatement ->
                    buildCommitStatementFn;
                CompoundStatement {statements} -> 
                    PrettyPrinter.group (PrettyPrinter.stack (map docForStatement statements));
                ;
        in
            PrettyPrinter.pretty width (docForStatement statement);
    ;

/**
 * Generates the text for a table field description.
 */
fieldDescriptionText :: SqlBuilder -> FieldDescription -> Document;
public fieldDescriptionText !builder fieldDesc = 
    (builder.SqlBuilder.buildFieldDescriptionFn) fieldDesc;

/**
 * Generates the text for a field data type.
 */
fieldTypeText :: SqlBuilder -> SqlType -> Document;
public fieldTypeText !builder !dataType = 
    (builder.SqlBuilder.buildFieldTypeFn) dataType;


/**
 * @arg query The query for which we want the groups.
 * @return The list of groups for the given query, or if the query is a union
 *         then the groups for the first query in the union.
 */
getGroups :: Query -> [Expr];
public getGroups query =
    case query of
    Query {groups, columns} -> 
        let
            filter expr = 
                case expr of 
                QueryField {} -> [expr];
                _ -> [];
                ;
                
            cols = concatMap (\col -> filter col.#1) columns;
        in 
            groups ++ cols;
    Union {query1} -> getGroups query1;
    ;


/**
 * @return True when a given function is a function of two parameters
 */
isBinaryFunction :: DbFunction -> Boolean;
public isBinaryFunction dbFun = 
    case dbFun of
    (OpEq 
    | OpLt 
    | OpLtEq 
    | OpGt 
    | OpGtEq 
    | OpNotEq 
    | OpAnd 
    | OpOr 
    | OpLike 
    | OpIn 
    | OpCat 
    | OpPlus 
    | OpMinus 
    | OpMul 
    | OpDiv 
    | OpMod 
    | OpBitAnd 
    | OpBitOr 
    | OpBitXor) -> True;   
    _ -> False;
    ;

/**
 * It applies ConvertToTime function to the passed in expression. Use it when you want the end result to be evaluated to the explicit cast call.
 * 
 * @return function expr
 */
convertToTimeExpr :: TypedExpr a -> TypedExpr Time;
public convertToTimeExpr = functionExpr1 ConvertToTimeFunction;

   
/**
 * Use it to check if the expression's part uses binary function.
 * 
 * @return True when expression uses binary function
 * @see function = isBinaryFunction 
 */
exprUsesBinaryFunction :: Expr -> Boolean;
public exprUsesBinaryFunction expr = 
    case expr of
    QueryField fieldName queryTable -> False;
    ConstExpr  constantValue -> False;
    ListExpr  listValues -> any exprUsesBinaryFunction listValues;
    FunctionExpr func arguments -> isBinaryFunction func || (any exprUsesBinaryFunction arguments);
    SubQueryExpr subquery -> False;
    ;

/**
 * The function recurses the Expr Boolean and makes sure that every item involved in operation against time constant 
 * is casted to datetime format explictly.
 *
 * Use it to make expression to be evaluated to explicit casts.
 * 
 * @arg expr
 * @return transformed expr
 * @see function = convertToTimeExpr
 */ 
convertDateQueryFieldsToTimeExprs :: TypedExpr Boolean -> TypedExpr Boolean;
public convertDateQueryFieldsToTimeExprs expr = 
    //TODO: get more metadata into the field object
    let
        convertNonTimeConstExpr :: Expr -> Expr;
        convertNonTimeConstExpr exprToConvert = 
            if (isTimeConstExpr exprToConvert) then
                exprToConvert
            else
                toUntypedExpr(convertToTimeExpr (toTypedExpr exprToConvert));
        
        convertionHelper :: Expr -> Expr;
        convertionHelper untypedExpr = 
            case untypedExpr of
    //            ListExpr listValue -> 
    
                //for binary functions, if only one arg is time const make sure 
                //all others are casted
                FunctionExpr dbFunc args ->
                    if (isBinaryFunction dbFunc) then 
                        let
                            lhs = convertionHelper (head args);
                            rhs = convertionHelper (head (tail args));
        
                            convertedExprs = map convertNonTimeConstExpr args;
                        in
                            if ((any isQueryFieldExpr args) && (any isTimeConstExpr args)) then
                                untypedFunctionExpr dbFunc convertedExprs
                            else
                                untypedFunctionExpr dbFunc [lhs, rhs]
                    else 
                        untypedExpr;
                _ -> untypedExpr;
            ;
    in
        toTypedExpr (convertionHelper (toUntypedExpr expr));
        
///**
// * The {@code replaceRestrictionExprs@} replaces a restriction of a query with a passed in values. 
// *  
// * @arg query
// * @arg newRestriction
// * @arg newGrpRestriction
// * @return transformed query
// * @see typeConstructor = Query 
// */           
//replaceRestrictionExprs :: Query -> Maybe (TypedExpr Boolean) -> Maybe (TypedExpr Boolean) -> Query;
//replaceRestrictionExprs query newRestriction newGrpRestriction = 
//    case query of
//        Query options columns restriction orderings joins groups groupRestriction ->
//            Query options columns newRestriction orderings joins groups newGrpRestriction;
//
//        _ -> error "unsupported query type for change of restrictions";
//    ;

/**
 * The {@code transformQueryRestrictionExpr@} takes a conversion function and executes it against 
 * the restriction expression of a query.
 * 
 * @arg conversionFunction
 * @arg query
 * @return transformed query
 */      
transformQueryRestrictionExpr :: (TypedExpr Boolean -> TypedExpr Boolean) -> Query -> Query;
public transformQueryRestrictionExpr conversionFunction query =
    case query of
    Query options columns restriction orderings joins groups groupRestriction -> 
        case restriction of
        Nothing -> query;
        Just restrictionExpr -> 
            let
                newRestriction = Just (conversionFunction restrictionExpr);
            in
                Query options columns newRestriction orderings joins groups groupRestriction;
        ;

    Union query1 query2 unionAll -> 
        // transform the restriction expressions in both queries.
        Union (transformQueryRestrictionExpr conversionFunction query1) 
              (transformQueryRestrictionExpr conversionFunction query2) 
              unionAll;
    ;


/**
 * The {@code isSubQueryExpr@} tests expression if it is of SubQueryExpr type.
 * 
 * @arg expr
 * @return True when Expr is a {@code SubQueryExpr@}
 * @see dataConstructor = SubQueryExpr  
 */
isSubQueryExpr :: Expr -> Boolean;
public isSubQueryExpr expr =
    case expr of
    SubQueryExpr {} -> True;
    _ -> False;
    ;

/**
 * The {@code isSubQueryExpr@} retrieves the {@code Query@} type from untyped expression. 
 * 
 * Throws error when argument is not of SubQueryType
 * 
 * @arg expr
 * @return Query part of the SubQueryExpr
 * @see dataConstructor = SubQueryExpr 
 * @see function = isSubQueryExpr
 */
getSubQueryFromExpr :: Expr -> Query;
public getSubQueryFromExpr expr =
    case expr of
    SubQueryExpr query -> query;
    _ -> error "unable to extract query from non SubQueryExpr";
    ;

/**
 * The {@code isSubQueryExpr@} tests passed in query if it going to retrieve single column and value in the result set.
 * 
 * @arg query to test
 * @return True when expected resultset is using single column with applied aggregate function and the query has no groupings.
 */
isSingletonResultQuery :: Query -> Boolean;
public isSingletonResultQuery query =
    let
        cols :: [Expr];
        cols = getProjectedColumns query;

        headCol :: Expr;
        headCol = head cols;

        dbFunc :: DbFunction;
        dbFunc = getFunctionFromFunctionExpr headCol;
    in
        List.isSingletonList cols 
            && isFunctionExpr headCol 
            && isEmpty (getGroups query)
            && isAggregationFunction dbFunc;

/**
 * The {@code assignMissingColumnAliases@} is a transformation function to assign the missing aliases for all columns 
 * of the passed in query
 * 
 * Use it in conjunction with {@code modifyQueries@} function which can help to perfrom the transaformation 
 * for all subqueries
 * 
 * @arg query to transform
 * @return transformed query
 * @see function = modifyQueries
 */
assignMissingColumnAliases :: Query -> Query;
protected assignMissingColumnAliases query =
    case query of
    Query options columns restriction orderings joins groups groupRestriction ->
        let
            assignDefaultAlias :: (Expr, String) -> Int -> (Expr, String);
            assignDefaultAlias column aliasIndex = 
                case column of
                (columnExpr, columnAlias) -> 
                    let                         
                        newAlias = 
                            if (columnAlias == "") then
                                defaultColumnAlias aliasIndex
                            else
                                columnAlias; 
                    in
                        (columnExpr, newAlias);
                ;

            newColumns :: [(Expr, String)];
            newColumns = List.mapIndexed assignDefaultAlias columns;
        in
            Query options newColumns restriction orderings joins groups groupRestriction;

    Union query1 query2 unionAll ->              
        Union (assignMissingColumnAliases query1) (assignMissingColumnAliases query2) unionAll;

    _ -> error "unsupported type passed to assign missing aliases";
    ;

/**
 * The {@code convertQueryColumnsToCartesianJoins@} is a transformation function pushing the sub-queries 
 * nested as select items down to the from clause to perform cartesian join between datasources.
 *
 * It is useful on platforms like Teradata that do not support nested subqueries in select items. 
 * The conversion will be applied to the passed in query and all its subqueries. 
 * After all missign aliases have been assigned.
 *
 * It expects all aliases to be assigned therefore make sure {@code assignMissingColumnAliases@} is 
 * applied before this transform.
 * 
 * Use it in conjunction with {@code modifyQueries@} function which can help to perfrom 
 * the transaformation for all subqueries
 * 
 * @arg query to transform
 * @return transformed query
 * @see function = modifyQueries, assignMissingColumnAliases 
 */
convertQueryColumnsToCartesianJoins :: Query -> Query;    
protected convertQueryColumnsToCartesianJoins !query =
    let
        convertToCartesianQuery :: Query -> Query;
        convertToCartesianQuery !queryToConvert =
            case queryToConvert of
            Query options columns restriction orderings joins groups groupRestriction ->
                let
                    // For a subquery column, replace it with a reference to a subquery table field.
                    // Ensure that the generated table aliases are unique, even from the other ones generated here.
                    updateSubQueryColumns :: [String] -> [(Expr, String)] -> [(Expr, String)];
                    updateSubQueryColumns reservedAliases !columns = 
                        case columns of
                        [] -> [];
                        headColumn : tailColumns -> 
                            case headColumn of
                            (columnExpr, columnAlias) -> 
                                if (isSubQueryExpr columnExpr) then
                                    let
                                        subQuery :: Query;
                                        subQuery = getSubQueryFromExpr columnExpr;
                                    in
                                        if (isSingletonResultQuery subQuery) then
                                            let
                                                singletonAlias :: String;
                                                singletonAlias = head $ projectedColumnAliases subQuery;

                                                // Find a unique alias for this table within the query.
                                                queryTableAlias :: String;
                                                queryTableAlias = makeUniqueTableAliasForQuery query reservedAliases "Q";

                                                newQueryTable :: QueryTable;
                                                newQueryTable = makeSubQueryTable subQuery queryTableAlias;

                                                // Apply MIN function on singleton query to avoid grouping.
                                                // Use MIN in case the data type is non-numeric.
                                                newColumnExpr :: Expr;
                                                newColumnExpr = 
                                                    untypedFunctionExpr AggrMin [untypedField newQueryTable singletonAlias];
                                            in
                                                (newColumnExpr, columnAlias) : updateSubQueryColumns (queryTableAlias : reservedAliases) tailColumns
                                        else
                                            headColumn : updateSubQueryColumns reservedAliases tailColumns
                                else
                                    headColumn : updateSubQueryColumns reservedAliases tailColumns;
                            ;
                        ;

                    newColumns :: [(Expr, String)];
                    newColumns = updateSubQueryColumns [] columns;
                in
                    Query options newColumns restriction orderings joins groups groupRestriction;

            Union query1 query2 unionAll ->              
                Union (convertToCartesianQuery query1) (convertToCartesianQuery query2) unionAll;

            _ -> error "invalid query type when converting joins";
            ;
    in
        convertToCartesianQuery query;

/**
 * Constructs a table alias from the base name which is distinct within the query.
 */
makeUniqueTableAliasForQuery :: Query -> [String] -> String -> String;
makeUniqueTableAliasForQuery !query !otherReservedAliases !baseAlias = 
    let
        // Get the list of all base alias and ID combinations from the query.
        allQueryTables :: [QueryTable];
        allQueryTables = getQueryTables True query;

        allUsedTableAliases :: Set String;
        allUsedTableAliases = Set.fromList (otherReservedAliases ++ map getQueryTableAlias allQueryTables);

        potentialAliases :: [String];
        potentialAliases = baseAlias : map (\!indx -> baseAlias ++ intToString indx) (upFrom 2);
    in
        head $ filter (\potentialAlias -> not $ Set.member potentialAlias allUsedTableAliases) potentialAliases;

/**
 * Convert a range of values for a field or expression into the equivalent restriction expression.
 * @arg makeConstantFn  a function to produce a database constant expression from a value
 * @arg field           the database field or expression to be restricted
 * @arg range           the range of values to which the field will be restricted
 * @return              a Boolean expression restricting the field to the specified range
 */
rangeToRestrictionExpr :: Ord a => (a -> TypedExpr a) -> TypedExpr a -> Range a -> TypedExpr Boolean;
public rangeToRestrictionExpr makeConstantFn field !range = 
    let
        startValue = makeConstantFn (leftEndpoint range);
        startOperator = if (includesLeftEndpoint range) then gtEqExpr else gtExpr;
        startRestriction = startOperator field startValue;

        endValue = makeConstantFn (rightEndpoint range);
        endOperator = if (includesRightEndpoint range) then ltEqExpr else ltExpr;
        endRestriction = endOperator field endValue;
    in
        if (hasLeftEndpoint range) then
            if (hasRightEndpoint range) then andExpr startRestriction endRestriction
            else startRestriction
        else
            if (hasRightEndpoint range) then endRestriction
            else trueConstant;


/////////////////////////////////////////////////////////////////////////////////////////
// Output CAL Queries and Expressions (and dependant types) to Java.
/////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////
// Output QueryTables.
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.QueryTable" 
    JQueryTable deriving Outputable;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.QueryTable$BaseTable"
    jMakeBaseTable :: String -> String -> JQueryTable;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.QueryTable$SubQueryTable"
    jMakeSubQueryTable :: String -> JQuery -> JQueryTable;

instance Outputable QueryTable where
    output = outputQueryTableAsJObject;
    ;

outputQueryTable :: QueryTable -> JQueryTable;
outputQueryTable !queryTable =
    case queryTable of
    BaseTable {tableRef, tableAlias} -> 
        jMakeBaseTable tableAlias (getTableNameFromReference tableRef);

    SubQueryTable {subquery, tableAlias} -> 
        jMakeSubQueryTable tableAlias (outputQuery subquery);

    OpaqueSubQueryTable {subqueryText, tableAlias} -> 
        // The Java model doesn't have a class for an opaque subquery table.
        // TODO: would it be possible to parse the query and construct a regular query table object instead?
        error "case not implemented";
    ;

outputQueryTableAsJObject :: QueryTable -> JObject;
outputQueryTableAsJObject !queryTable = output $ outputQueryTable queryTable;


/////////////////////////////////////////////////////////////////////////////////////////
// Output QueryOptions.
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.QueryOption" 
    JQueryOption deriving Outputable;

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.Sql.QueryOption.makeDistinctOption"
    jMakeDistinctOption :: JQueryOption;
foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.Sql.QueryOption.makeTopNOption"
    jMakeTopNOption :: Int -> Boolean -> Boolean -> JQueryOption;

instance Outputable QueryOption where
    output = outputQueryOptionAsJObject;
    ;

outputQueryOption :: QueryOption -> JQueryOption;
outputQueryOption !queryOption =
    case queryOption of
    Distinct {} -> jMakeDistinctOption;
    TopN {n, percent, withTies} -> jMakeTopNOption n percent withTies;
    ;

outputQueryOptionAsJObject :: QueryOption -> JObject;
outputQueryOptionAsJObject !queryOption = output $ outputQueryOption queryOption;


/////////////////////////////////////////////////////////////////////////////////////////
// Output JoinTypes.
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.JoinType" 
    JJoinType deriving Outputable;

foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.JoinType.INNER_JOIN"       jINNER_JOIN       :: JJoinType;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.JoinType.LEFT_OUTER_JOIN"  jLEFT_OUTER_JOIN  :: JJoinType;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.JoinType.RIGHT_OUTER_JOIN" jRIGHT_OUTER_JOIN :: JJoinType;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.JoinType.FULL_OUTER_JOIN"  jFULL_OUTER_JOIN  :: JJoinType;

instance Outputable JoinType where
    output = outputJoinTypeAsJObject;
    ;

outputJoinType :: JoinType -> JJoinType;
outputJoinType !joinType =
    case joinType of
    InnerJoin      -> jINNER_JOIN;
    LeftOuterJoin  -> jLEFT_OUTER_JOIN;
    RightOuterJoin -> jRIGHT_OUTER_JOIN;
    FullOuterJoin  -> jFULL_OUTER_JOIN;
    ;

outputJoinTypeAsJObject :: JoinType -> JObject;
outputJoinTypeAsJObject !joinType = output $ outputJoinType joinType;


/////////////////////////////////////////////////////////////////////////////////////////
// Output JoinNodes.
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.JoinNode" 
    JJoinNode deriving Outputable;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.JoinNode$JoinTable"
    jMakeJoinTableNode :: JQueryTable -> JJoinNode;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.JoinNode$JoinSubtree"
    jMakeJoinSubtreeNode :: JJoinNode -> JJoinNode -> JExpression -> JJoinType -> JJoinNode;

instance Outputable JoinNode where
    output = outputJoinNodeAsJObject;
    ;

outputJoinNode :: JoinNode -> JJoinNode;
outputJoinNode !joinNode =
    case joinNode of
    JoinTable {table} -> 
        jMakeJoinTableNode $ outputQueryTable table;
    JoinSubtree {leftNode, rightNode, linkingExpr, joinType} -> 
        jMakeJoinSubtreeNode (outputJoinNode leftNode) 
                             (outputJoinNode rightNode) 
                             (outputExpression $ toUntypedExpr linkingExpr) 
                             (outputJoinType joinType);
    ;

outputJoinNodeAsJObject :: JoinNode -> JObject;
outputJoinNodeAsJObject !joinNode = output $ outputJoinNode joinNode;


/////////////////////////////////////////////////////////////////////////////////////////
// Output DbFunctions.
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction" 
    JDatabaseFunction deriving Outputable;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Function"
    jMakeDatabaseFunction :: String -> JDatabaseFunction;

foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.NOT_OPERATOR"                   jNotOperator                :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.BITWISE_NOT_OPERATOR"           jBitwiseNotOperator         :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.NEGATE_OPERATOR"                jNegateOperator             :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.ISNULL_OPERATOR"                jIsNullOperator             :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.ISNOTNULL_OPERATOR"             jIsNotNullOperator          :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.EXISTS_OPERATOR"                jExistsOperator             :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.EQUAL_OPERATOR"                 jEqualOperator              :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.LESS_THAN_OPERATOR"             jLessThanOperator           :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.LESS_THAN_OR_EQUAL_OPERATOR"    jLessThanOrEqualOperator    :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.GREATER_THAN_OPERATOR"          jGreaterThanOperator        :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.GREATER_THAN_OR_EQUAL_OPERATOR" jGreaterThanOrEqualOperator :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.NOT_EQUAL_OPERATOR"             jNotEqualOperator           :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.AND_OPERATOR"                   jAndOperator                :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.OR_OPERATOR"                    jOrOperator                 :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.LIKE_OPERATOR"                  jLikeOperator               :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.IN_OPERATOR"                    jInOperator                 :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.CONCAT_OPERATOR"                jConcatOperator             :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.PLUS_OPERATOR"                  jPlusOperator               :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.MINUS_OPERATOR"                 jMinusOperator              :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.MULTIPLY_OPERATOR"              jMultiplyOperator           :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.DIVIDE_OPERATOR"                jDivideOperator             :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.MODULUS_OPERATOR"               jModulusOperator            :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.BITWISE_AND_OPERATOR"           jBitwiseAndOperator         :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.BITWISE_OR_OPERATOR"            jBitwiseOrOperator          :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.BITWISE_XOR_OPERATOR"           jBitwiseXOrOperator         :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.BETWEEN_OPERATOR"               jBetweenOperator            :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.SIMPLE_CASE_OPERATOR"           jSimpleCaseOperator         :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Operator.SEARCHED_CASE_OPERATOR"         jSearchedCaseOperator       :: JDatabaseFunction;

foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Conversion.CONVERSION_TO_STRING"         jConvertToString            :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Conversion.CONVERSION_TO_INT"            jConvertToInt               :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Conversion.CONVERSION_TO_DOUBLE"         jConvertToDouble            :: JDatabaseFunction;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Sql.DatabaseFunction$Conversion.CONVERSION_TO_TIME"           jConvertToTime              :: JDatabaseFunction;

instance Outputable DbFunction where
    output = outputDbFunctionAsJObject;
    ;

outputDbFunction :: DbFunction -> JDatabaseFunction;
outputDbFunction !func = 
    case func of
    // Handle operators specially.
    OpNot           -> jNotOperator;
    OpBitNot        -> jBitwiseNotOperator;
    OpNegate        -> jNegateOperator;
    OpIsNull        -> jIsNullOperator;
    OpIsNotNull     -> jIsNotNullOperator;
    OpExists        -> jExistsOperator;
    OpEq            -> jEqualOperator;
    OpLt            -> jLessThanOperator;
    OpLtEq          -> jLessThanOrEqualOperator;
    OpGt            -> jGreaterThanOperator;
    OpGtEq          -> jGreaterThanOrEqualOperator;
    OpNotEq         -> jNotEqualOperator;
    OpAnd           -> jAndOperator;
    OpOr            -> jOrOperator;
    OpLike          -> jLikeOperator;
    OpIn            -> jInOperator;
    OpCat           -> jConcatOperator;
    OpPlus          -> jPlusOperator;
    OpMinus         -> jMinusOperator;
    OpMul           -> jMultiplyOperator;
    OpDiv           -> jDivideOperator;
    OpMod           -> jModulusOperator;
    OpBitAnd        -> jBitwiseAndOperator;
    OpBitOr         -> jBitwiseOrOperator;
    OpBitXor        -> jBitwiseXOrOperator;
    OpBetween       -> jBetweenOperator;
    OpCase_Simple   -> jSimpleCaseOperator;
    OpCase_Searched -> jSearchedCaseOperator;

    // Handle conversion functions specially as well.
    ConvertToStringFunction -> jConvertToString;
    ConvertToIntFunction    -> jConvertToInt;
    ConvertToDoubleFunction -> jConvertToDouble;
    ConvertToTimeFunction   -> jConvertToTime;

    // For other functions, just output the default function name.
    _ -> jMakeDatabaseFunction $ defaultFunctionName func;
    ;

outputDbFunctionAsJObject :: DbFunction -> JObject;
outputDbFunctionAsJObject !func = output $ outputDbFunction func;


/////////////////////////////////////////////////////////////////////////////////////////
// Output Expressions.
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.SqlExpression" 
    JExpression deriving Outputable;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlExpression$QueryField"
    jMakeQueryFieldExpression :: String -> JQueryTable -> JExpression;

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.Sql.SqlExpression$ConstantExpression$NullConstant.nullConstant"
    jMakeNullConstantExpression :: JExpression;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlExpression$ConstantExpression$StringConstant"
    jMakeStringConstantExpression :: String -> JExpression;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlExpression$ConstantExpression$NumericConstant"
    jMakeNumericConstantExpression :: Double -> JExpression;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlExpression$ConstantExpression$BooleanConstant"
    jMakeBooleanConstantExpression :: Boolean -> JExpression;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlExpression$ConstantExpression$TimeConstant"
    jMakeTimeConstantExpression :: Time -> JExpression;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlExpression$ParameterExpression"
    jMakeParameterExpression :: JParameter -> JExpression;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlExpression$ListExpression"
    jMakeListExpression :: JList -> JExpression;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlExpression$FunctionExpression"
    jMakeFunctionExpression :: JDatabaseFunction -> JList -> JExpression;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlExpression$SubQueryExpression"
    jMakeSubQueryExpression :: JQuery -> JExpression;

instance Outputable Expr where
    output = outputExprAsJObject;
    ;

outputExpression :: Expr -> JExpression;
outputExpression !expr = 
    case expr of
    QueryField {fieldName, queryTable} -> 
        jMakeQueryFieldExpression fieldName (outputQueryTable queryTable);
    ConstExpr {constantValue} -> 
        case constantValue of
        NullValue                -> jMakeNullConstantExpression;
        StringValue  {strValue}  -> jMakeStringConstantExpression strValue;
        NumberValue  {numValue}  -> jMakeNumericConstantExpression numValue;
        BooleanValue {boolValue} -> jMakeBooleanConstantExpression boolValue;
        TimeValue    {timeValue} -> jMakeTimeConstantExpression timeValue;
        ;
    ParameterExpr {parameter} -> 
        jMakeParameterExpression (outputParameter parameter);
    ListExpr {listValues} -> 
        jMakeListExpression (outputList listValues);
    FunctionExpr {func, arguments} -> 
        jMakeFunctionExpression (outputDbFunction func) (outputList arguments);
    SubQueryExpr {subquery} -> 
        jMakeSubQueryExpression (outputQuery subquery);
    ;

outputExprAsJObject :: Expr -> JObject;
outputExprAsJObject !expr = output $ outputExpression expr;


/////////////////////////////////////////////////////////////////////////////////////////
// Output Queries.
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.SqlQuery" 
    JQuery deriving Outputable;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlQuery$SelectQuery"
    jMakeSelectQuery :: JList -> JList -> JExpression -> JList -> JList -> JList -> JExpression -> JQuery;

foreign unsafe import jvm "constructor org.openquark.cal.foreignsupport.module.Sql.SqlQuery$UnionQuery"
    jMakeUnionQuery :: JQuery -> JQuery -> Boolean -> JQuery;

data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.QueryColumn" 
    JQueryColumn deriving Outputable;

foreign unsafe import jvm "constructor"
    jMakeQueryColumn :: JExpression -> String -> JQueryColumn;

data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.SqlOrdering" 
    JSqlOrdering deriving Outputable;

foreign unsafe import jvm "constructor"
    jMakeSqlOrdering :: JExpression -> Boolean -> JSqlOrdering;

instance Outputable Query where
    output = outputQueryAsJObject;
    ;

outputQuery :: Query -> JQuery;
outputQuery !query = 
    case query of
    Query {options, columns, restriction, orderings, joins, groups, groupRestriction} -> 
        jMakeSelectQuery (outputList options)
                         (outputListWith columns outputProjectedColumn)
                         (outputExpression $ toUntypedExpr $ fromMaybe trueConstant restriction)
                         (outputListWith orderings outputOrdering)
                         (outputList joins)
                         (outputList groups)
                         (outputExpression $ toUntypedExpr $ fromMaybe trueConstant groupRestriction);
    Union {query1, query2, unionAll} -> 
        jMakeUnionQuery (outputQuery query1) (outputQuery query2) unionAll;
    ;

outputQueryAsJObject :: Query -> JObject;
outputQueryAsJObject !query = output $ outputQuery query;

outputProjectedColumn :: (Expr, String) -> JObject;
outputProjectedColumn !column = 
    case column of
    (expr, alias) -> output $ jMakeQueryColumn (outputExpression expr) alias;
    ;

outputOrdering :: (Expr, Boolean) -> JObject;
outputOrdering !ordering = 
    case ordering of
    (expr, ascending) -> output $ jMakeSqlOrdering (outputExpression expr) ascending;
    ;


/////////////////////////////////////////////////////////////////////////////////////////
// Output Parameters.
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Sql.SqlParameter" 
    JParameter deriving Outputable;

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.Sql.SqlParameter.makeParameter"
    jMakeUnnamedParameter :: JParameter;
foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.Sql.SqlParameter.makeParameter"
    jMakeNamedParameter :: String -> JParameter;

instance Outputable Parameter where
    output = outputParameterAsJObject;
    ;

outputParameter :: Parameter -> JParameter;
outputParameter !parameter =
    case parameter of
    UnnamedParameter -> jMakeUnnamedParameter;
    NamedParameter {name} -> jMakeNamedParameter name;
    ;

outputParameterAsJObject :: Parameter -> JObject;
outputParameterAsJObject !parameter = output $ outputParameter parameter;


