/*
 * Copyright (c) 2007 BUSINESS OBJECTS SOFTWARE LIMITED
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *  
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *  
 *     * Neither the name of Business Objects nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


/*
 * SqlBuilder.cal
 * Creation date: Jan 27, 2004.
 * By: Richard Webster
 */

/**
 * This module contains implementations of {@link typeConstructor = SqlBuilder@} for several kinds of RDBMS. 
 * These are generally variations on the {@link defaultSqlBuilder@}.
 * 
 * There is a function {@link bestSqlBuilderForDatabase@} that attempts to choose a {@link typeConstructor = SqlBuilder@} based on an identifying string.
 * 
 * @author Richard Webster
 */
    

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

module Cal.Data.SqlBuilder;

import Cal.Core.Prelude using
    typeConstructor = Boolean, Char, Double, Int, Maybe, String;
    dataConstructor = False, True, Nothing, Just;
    function = 
        compose, concat, doubleToString, empty, error, field1, field2, field3, 
        fromJust, fst, intToString, isEmpty, isJust, isNothing, maxBound, not, snd, toDouble;
    ;
import Cal.Core.Char;    
import Cal.Collections.List using
    function = 
        all, any, chop, concatMap, find, head, isElem, isElemBy, isSingletonList,
        join, length, map, mapIndexed, subscript, tail;
    ;      
import Cal.Core.String using
    function = equalsIgnoreCase, fromList, replaceAllString, substring, toList, toUpperCase;
    ;        
import Cal.Utilities.Locale;
import Cal.Utilities.Time;
import Cal.Data.Sql using
    typeConstructor = 
        Expr, JoinNode, Query, QueryOption, QueryTable, SqlBuilder, SqlBuilderState;
    function = 
        exprOperatorPrecedence, expressionText2, operatorPrecedence, 
        toUntypedExpr;
    ;
import Cal.Utilities.PrettyPrinter using
    typeConstructor = Document;
    function = 
        fillSeparatedList, group, line, nest, singleSpace, spread, stack, text;
    ;
import Cal.Data.SqlType using
    typeConstructor = SqlType;
    dataConstructor = 
        SqlType_TinyInt, SqlType_SmallInt, SqlType_Integer, SqlType_BigInt, SqlType_Decimal, SqlType_Numeric, 
        SqlType_Real, SqlType_Float, SqlType_Double, SqlType_Bit, SqlType_Boolean, SqlType_Char, SqlType_VarChar,
        SqlType_LongVarChar, SqlType_Clob, SqlType_Binary, SqlType_VarBinary, SqlType_LongVarBinary, SqlType_Blob, 
        SqlType_Date, SqlType_Time, SqlType_TimeStamp, SqlType_Datalink;
    ;
import Cal.Data.DatabaseMetadata using
    dataConstructor = 
        PrimaryKeyConstraint, UniqueConstraint, ForeignKeyConstraint;
    function = 
        getDatabaseNameFromReference, getFieldName, getFieldDataType, getTableConstraints, getTableFields, 
        getTableNameFromReference, getTableReference, isFieldNullable;
    ;
import Cal.Utilities.Math;
import Cal.Core.Debug using
    function = show;
    ;


/**
 * Returns the best {@link typeConstructor = SqlBuilder@} for the type of database type name specified.
 * If no match can be found, then the default {@link typeConstructor = SqlBuilder@} will be returned.
 */
bestSqlBuilderForDatabase :: String -> SqlBuilder;
public bestSqlBuilderForDatabase !databaseTypeName = 
    let
        // This associates a SQL builder with a database type prefix (not case sensitive).
        prefixToSqlBuilderMap :: [(String, SqlBuilder)];
        prefixToSqlBuilderMap = [("Access", msAccessSqlBuilder),
                                 ("Microsoft Access", msAccessSqlBuilder),
                                 ("MS Access", msAccessSqlBuilder),
                                 ("Excel", msJetSqlBuilder),
                                 ("Microsoft Excel", msJetSqlBuilder),
                                 ("MS Excel", msJetSqlBuilder),
                                 ("SQL Server", msSqlServerSqlBuilder),
                                 ("Microsoft SQL Server", msSqlServerSqlBuilder),
                                 ("MS SQL Server", msSqlServerSqlBuilder),
                                 ("Oracle", oracleSqlBuilder),
                                 ("Teradata", ncrTeradataSqlBuilder),
                                 ("DB2", db2SqlBuilder),
                                 ("Apache Derby", derbySqlBuilder)
//                                 ("Informix", informixSqlBuilder),
//                                 ("Sybase", sybaseSqlBuilder),
                                 ];

        maybeMatchingItem = find (\pr -> String.startsWith (toUpperCase (fst pr)) (toUpperCase databaseTypeName)) prefixToSqlBuilderMap;
    in
        if (isNothing maybeMatchingItem) then defaultSqlBuilder 
        else snd (fromJust maybeMatchingItem);

/**
 * Creates a default primitive value builder.
 */
public defaultPrimitiveValueBuilder = Sql.makePrimitiveValueBuilder 
                                            default_intToSql
                                            default_doubleToSql
                                            default_stringToSql
                                            default_timeToSql
                                            default_booleanToSql
                                            default_nullToSql
                                            default_timeIntervalToSql;

/**
 * Creates a default implementation of a {@link typeConstructor = SqlBuilder@}.
 */
public defaultSqlBuilder = Sql.makeSqlBuilder default_prepareQuery 

                            (default_constructQuery defaultSqlBuilder)
                            (default_constructUnionQuery defaultSqlBuilder)

                            (default_buildSelectClause defaultSqlBuilder)
                            (default_buildFromClause defaultSqlBuilder)
                            (default_buildWhereClause defaultSqlBuilder)
                            (default_buildOrderByClause defaultSqlBuilder)
                            (default_buildGroupByClause defaultSqlBuilder)
                            (default_buildHavingClause defaultSqlBuilder)

                            (default_buildCreateDatabaseStatement defaultSqlBuilder)
                            (default_buildDropDatabaseStatement defaultSqlBuilder)
                            (default_buildCreateTableStatement defaultSqlBuilder)
                            (default_buildCreateViewStatement defaultSqlBuilder)
                            (default_buildDropTableStatement defaultSqlBuilder)
                            (default_buildDropViewStatement defaultSqlBuilder)
                            (default_buildInsertValuesStatement defaultSqlBuilder)
                            (default_buildInsertQueryValuesStatement defaultSqlBuilder)
                            (default_buildUpdateValuesStatement defaultSqlBuilder)
                            (default_buildDeleteRowsStatement defaultSqlBuilder)
                            (default_buildCommitStatement defaultSqlBuilder)
                            (default_buildFieldDescription defaultSqlBuilder)
                            default_buildFieldType

                            (default_parameterToSql defaultSqlBuilder)
                            (default_listToSql defaultSqlBuilder)
                            (default_functionToSql defaultSqlBuilder)

                            default_addParens
                            default_quoteIdentifier

                            (default_buildTableAndAliasText defaultSqlBuilder)
                            default_makeSafeName

                            defaultPrimitiveValueBuilder;

private default_prepareQuery builderState query = query;

private default_constructQuery builder builderState selectBody fromBody whereBody groupByBody havingBody orderByBody = 
    let
        selectDoc  = group (text "SELECT" ++ nest 4 (line ++ selectBody));
        fromDoc    = if (isEmpty fromBody)   then empty else group (text "FROM"     ++ nest 4 (line ++ fromBody));
        whereDoc   = if (isEmpty whereBody)   then empty else group (text "WHERE"    ++ nest 4 (line ++ whereBody));
        groupByDoc = if (isEmpty groupByBody) then empty else group (text "GROUP BY" ++ nest 4 (line ++ groupByBody));
        havingDoc  = if (isEmpty havingBody)  then empty else group (text "HAVING"   ++ nest 4 (line ++ havingBody));
        orderByDoc = if (isEmpty orderByBody) then empty else group (text "ORDER BY" ++ nest 4 (line ++ orderByBody));
    in
        group (stack [selectDoc, fromDoc, whereDoc, groupByDoc, havingDoc, orderByDoc]);

private default_constructUnionQuery builder builderState query1Text query2Text !unionAll = 
    let
        unionKeyword = if unionAll then "UNION ALL" else "UNION";
    in
        group (stack [query1Text, text unionKeyword, query2Text]);

    
/**
 * Constructs a comma-separated list of expressions.
 */
private buildExpressionList builder builderState exprs = 
    let
        exprTextVals = map (expressionText2 builder builderState) exprs;
    in
        join (text ", ") exprTextVals;

private fillExpressionList builder builderState exprs = 
    let
        exprTextVals = map (expressionText2 builder builderState) exprs;
    in
        fillSeparatedList True "," exprTextVals;

private default_buildSelectClause builder builderState options columns = 
    let
        isDistinct = isElem Sql.Distinct options;
        distinctOptionText = if (isDistinct) then text "DISTINCT" else empty;

        maybeTopNInfo :: Maybe (Int, Boolean, Boolean);
        maybeTopNInfo = 
            case (find Sql.isTopNOption options) of
            Nothing -> Nothing;
            Just topNOptionValue -> 
                case topNOptionValue of
                Sql.TopN {n, percent, withTies} -> Just (n, percent, withTies);
                ;
            ;
        // TODO: there should be an easy way for the SQL builder to change how the TOP N text is generated.
        //       For example, Access doesn't seem to support the 'WITH TIES' option, so it should be omitted (or perhaps an error thrown).
        topNOptionText = 
            let
                nText = intToString (field1 (fromJust maybeTopNInfo));
                percent = field2 (fromJust maybeTopNInfo);
                withTies = field3 (fromJust maybeTopNInfo);

                optionalPercentText = if (percent) then " PERCENT" else "";
                optionalWithTies = if (withTies) then " WITH TIES" else "";
            in
                case maybeTopNInfo of
                Nothing -> empty;
                Just _ ->
                    text ("TOP " ++ nText ++ optionalPercentText ++ optionalWithTies);
                ;
                
        prefixText = spread [distinctOptionText, topNOptionText];

        columnText column = 
            let
                columnExpr  = fst column;
                columnAlias = snd column;

                columnExprText  = expressionText2 builder builderState columnExpr;
                columnAliasText = if (isEmpty columnAlias) then empty
                                  else text "AS " ++ Sql.quoteIdentifier builder columnAlias;
            in
                spread [columnExprText, columnAliasText];

        columnTextVals = map columnText columns;
    in
        stack [prefixText, fillSeparatedList True "," columnTextVals];

private default_buildOrderByClause builder builderState orderExprs = 
    let
        orderExprText orderExpr = 
            let
                exprText = expressionText2 builder builderState (fst orderExpr);
                sortDirectionText = if (snd orderExpr) then "ASC" else "DESC";
            in
                spread [exprText, text sortDirectionText];
    in
        fillSeparatedList True "," (map orderExprText orderExprs);

private default_buildGroupByClause = fillExpressionList;

private default_buildFromClause builder builderState joins = 
    fillSeparatedList True "," (map (joinNodeText True builder builderState True) joins);

private default_buildWhereClause builder builderState restriction joins =
    case restriction of
    Nothing -> empty;
    Just restrictionValue ->
        nest 4 (expressionText2 builder builderState restrictionValue);
    ;

private default_buildHavingClause builder builderState groupRestriction =
    case groupRestriction of
    Nothing -> empty;
    Just groupRestrictionValue -> nest 4 (expressionText2 builder builderState groupRestrictionValue);
    ;
    
default_buildTableAndAliasText :: SqlBuilder -> SqlBuilderState -> QueryTable -> Document;
private default_buildTableAndAliasText = buildTableAndAliasTextHelper True;

buildTableAndAliasTextHelper :: Boolean -> SqlBuilder -> SqlBuilderState -> QueryTable -> Document;
private buildTableAndAliasTextHelper includeAsKeywordWithAlias builder builderState table = 
    let
        qualName = Sql.tableNameText builder builderState table;
        tableAlias = Sql.getQueryTableAlias table;
        quotedAlias = Sql.quoteIdentifier builder tableAlias;

        aliasSeparator = if includeAsKeywordWithAlias then " AS " else " ";
    in
        // Don't bother including the table alias if it is the same as the table name.
        if (Sql.getQueryTableName table == tableAlias) then qualName
        else qualName ++ text aliasSeparator ++ quotedAlias;


joinNodeText :: Boolean -> SqlBuilder -> SqlBuilderState -> Boolean -> JoinNode -> Document;
private joinNodeText addJoinParens builder builderState !rootNode joinNode = 
    case joinNode of
    Sql.JoinTable {table} -> 
        Sql.buildTableAndAliasText builder builderState table;

    Sql.JoinSubtree {leftNode, rightNode, linkingExpr, joinType} ->
        let
            leftText  = joinNodeText addJoinParens builder builderState False leftNode;
            rightText = joinNodeText addJoinParens builder builderState False rightNode;

            // MS Access doesn't accept a 'BETWEEN' expression unless it is wrapped in parens.
            // To be safe, use parens around the linking expression for anything more than a simple binary comparison operation.
            baseLinkExprText = expressionText2 builder builderState (toUntypedExpr linkingExpr);
            linkExprText = if (isSimpleBinaryComaprisonExpr (toUntypedExpr linkingExpr)) then baseLinkExprText
                           else Sql.addParens builder baseLinkExprText;

            subtreeText = leftText ++ nest 4 (line ++ (joinTypeText joinType) ++ singleSpace ++ rightText ++ nest 4 (line ++ text "ON " ++ linkExprText));
        in
            // Add parens unless this is the root join node.
            if (rootNode || not addJoinParens) then subtreeText
            else Sql.addParens builder subtreeText;
    ;

/**
 * Returns whether the expression compares two simple values using a comparison operator.
 */
isSimpleBinaryComaprisonExpr :: Expr -> Boolean;
private isSimpleBinaryComaprisonExpr expr = 
    let
        args = Sql.getArgumentsFromFunctionExpr expr;
    in
        Sql.isOperatorExpr expr && length args == 2 && not (any Sql.isOperatorExpr args);


/**
 * Returns the symbol for a join type.
 */
private joinTypeText !joinType = 
    case joinType of
    Sql.InnerJoin      -> text "INNER JOIN";
    Sql.LeftOuterJoin  -> text "LEFT OUTER JOIN";
    Sql.RightOuterJoin -> text "RIGHT OUTER JOIN";
    Sql.FullOuterJoin  -> text "FULL OUTER JOIN";
    ;


timestampPattern :: String;
private timestampPattern = "'{ts '''yyyy-MM-dd HH:mm:ss.S'''}'";

private default_intToSql    = compose text intToString;
private default_doubleToSql = compose text formatNumber;

formatNumber :: Double -> String;
formatNumber !numVal = 
    // If this is a whole number, then format it as a long integer.
    if (Math.fractionalPart numVal == 0.0 
        && numVal <= toDouble (Prelude.maxBound :: Int)
        && numVal >= toDouble (Prelude.minBound :: Int)) then 
            Prelude.longToString (Math.roundDoubleToLong numVal)
    else doubleToString numVal;

/**
 * Escapes any single quotes in the string value.
 */
private default_stringToSql strVal = text ("'" ++ (replaceAllString strVal "'" "''") ++ "'");

private default_timeToSql timeVal timeZone = 
    text (Time.formatTime timeVal timeZone Time.gregorianCalendar timestampPattern Locale.defaultLocale);

private default_booleanToSql !boolVal = 
    if boolVal then text "1=1" else text "1=0";

private default_nullToSql = text "NULL";

private default_timeIntervalToSql !timeInterval = 
    case timeInterval of
    Sql.YearInterval    -> text "yyyy"; 
    Sql.QuarterInterval -> text "q";
    Sql.MonthInterval   -> text "m";
    Sql.DayInterval     -> text "d";
    Sql.HourInterval    -> text "hh";
    Sql.MinuteInterval  -> text "n";
    Sql.SecondInterval  -> text "s";
    ;

private default_parameterToSql builder parameter =
    if (Sql.isUnnamedParameter parameter) then text "?"
    else error "Named parameters are currently not supported!";

private default_listToSql builder builderState listValues = 
    text "(" ++ buildExpressionList builder builderState listValues ++ text ")";

private default_functionToSql = default_functionToSql2 default_functionNameText;

private default_functionToSql2 functionNameTextFn builder builderState func arguments = 
    let
        nArgs = length arguments;

        arg1Expr = if (nArgs < 1) then error "The wrong number of function arguments was provided"
                   else head arguments;
        arg2Expr = if (nArgs < 2) then error "The wrong number of function arguments was provided"
                   else head (tail arguments);
        arg3Expr = if (nArgs < 3) then error "The wrong number of function arguments was provided"
                   else subscript arguments 2;

        arg1Text = expressionText2 builder builderState arg1Expr;
        arg2Text = expressionText2 builder builderState arg2Expr;
        arg3Text = expressionText2 builder builderState arg3Expr;

        arg1TextParens = nest 4 (text "(" ++ arg1Text ++ text ")");
        arg2TextParens = nest 4 (text "(" ++ arg2Text ++ text ")");
        arg3TextParens = nest 4 (text "(" ++ arg3Text ++ text ")");

        unaryOperationText operatorText operatorInFront = 
            let
                unaryOperatorPrecedence = operatorPrecedence func;
                argOperatorPrecedence  = exprOperatorPrecedence arg1Expr;

                // Only include parens where needed.
                argText = if (argOperatorPrecedence > 0 && unaryOperatorPrecedence > argOperatorPrecedence) then arg1TextParens
                          else arg1Text;
            in
                if (operatorInFront) then
                    text operatorText ++ argText
                else
                    argText ++ text operatorText;

        binaryOperationText = binaryOperationText2 False;

        binaryOperationText2 multiline operatorText = 
            let
                binaryOperatorPrecedence = operatorPrecedence func;
                leftOperatorPrecedence  = exprOperatorPrecedence arg1Expr;
                rightOperatorPrecedence = exprOperatorPrecedence arg2Expr;

                // Only include parens where needed.
                leftText  = if (leftOperatorPrecedence  > 0 && binaryOperatorPrecedence > leftOperatorPrecedence)  then arg1TextParens else arg1Text;
                rightText = if (rightOperatorPrecedence > 0 && binaryOperatorPrecedence >= rightOperatorPrecedence) then arg2TextParens else arg2Text;
            in
                if (multiline) then
                    leftText ++ line ++ text operatorText ++ singleSpace ++ rightText
                else
                    spread [leftText, text operatorText, rightText];

        betweenOperationText = 
            let
                binaryOperatorPrecedence = operatorPrecedence func;
                leftOperatorPrecedence  = exprOperatorPrecedence arg1Expr;
                startValOperatorPrecedence = exprOperatorPrecedence arg2Expr;
                endValOperatorPrecedence = exprOperatorPrecedence arg3Expr;

                // Only include parens where needed.
                leftText  = if (leftOperatorPrecedence  > 0 && binaryOperatorPrecedence > leftOperatorPrecedence)  then arg1TextParens else arg1Text;
                startValText = if (startValOperatorPrecedence > 0 && binaryOperatorPrecedence > startValOperatorPrecedence) then arg2TextParens else arg2Text;
                endValText = if (endValOperatorPrecedence > 0 && binaryOperatorPrecedence > endValOperatorPrecedence) then arg3TextParens else arg3Text;
            in
                spread [leftText, text "BETWEEN", startValText, text "AND", endValText];

        // The simpleCase flag will be True for a 'simple' CASE statement, and False for a 'searched' CASE statement.
        caseOperationText simpleCase = 
            let
                argPairs = chop 2 (if simpleCase then tail arguments else arguments);
                textForPair pr = 
                    let
                        fstArgText = expressionText2 builder builderState (head pr);
                        sndArgText = expressionText2 builder builderState (head (tail pr));
                    in
                        if (isSingletonList pr) then line ++ text "ELSE" ++ singleSpace ++ nest 4 fstArgText
                        else line ++ text "WHEN" ++ singleSpace ++ nest 4 fstArgText ++ singleSpace ++ text "THEN" ++ singleSpace ++ nest 4 sndArgText;

                caseArgText = if simpleCase then singleSpace ++ arg1Text else empty;
            in
                text "CASE" ++ caseArgText ++ nest 4 (concatMap textForPair argPairs) ++ line ++ text "END";

        distinctSummaryText baseAggrFunction = text (functionNameTextFn baseAggrFunction) ++ text "(" ++ text "DISTINCT" ++ singleSpace ++ arg1Text ++ text ")";
    in
        // The conversion functions need special handling.
        case func of
        Sql.OpNot    -> unaryOperationText "NOT " True;
        Sql.OpBitNot -> unaryOperationText "~" True;
        Sql.OpNegate -> unaryOperationText "-" True;
        Sql.OpIsNull    -> unaryOperationText " IS NULL" False;
        Sql.OpIsNotNull -> unaryOperationText " IS NOT NULL" False;
        Sql.OpExists    -> unaryOperationText "EXISTS " True;

        Sql.OpEq     -> binaryOperationText "=";
        Sql.OpLt     -> binaryOperationText "<";
        Sql.OpLtEq   -> binaryOperationText "<=";
        Sql.OpGt     -> binaryOperationText ">";
        Sql.OpGtEq   -> binaryOperationText ">=";
        Sql.OpNotEq  -> binaryOperationText "<>";
        Sql.OpAnd    -> binaryOperationText2 True "AND";
        Sql.OpOr     -> binaryOperationText2 True "OR";
        Sql.OpLike   -> binaryOperationText "LIKE";
        Sql.OpIn     -> binaryOperationText "IN";
        Sql.OpCat    -> binaryOperationText "+";
        Sql.OpPlus   -> binaryOperationText "+";
        Sql.OpMinus  -> binaryOperationText "-";
        Sql.OpMul    -> binaryOperationText "*";
        Sql.OpDiv    -> binaryOperationText "/";
        Sql.OpMod    -> binaryOperationText "MOD";
        Sql.OpBitAnd -> binaryOperationText "&";
        Sql.OpBitOr  -> binaryOperationText "|";
        Sql.OpBitXor -> binaryOperationText "^";

        Sql.OpBetween -> betweenOperationText;
        Sql.OpCase_Simple -> caseOperationText True;
        Sql.OpCase_Searched -> caseOperationText False;

        Sql.ConvertToStringFunction -> text "CONVERT(" ++ arg1Text ++ text ", SQL_VARCHAR)";
        Sql.ConvertToIntFunction    -> text "CONVERT(" ++ arg1Text ++ text ", SQL_INTEGER)";
        Sql.ConvertToDoubleFunction -> text "CONVERT(" ++ arg1Text ++ text ", SQL_DECIMAL)";

        Sql.AggrDistinctCount -> distinctSummaryText Sql.AggrCount;
        Sql.AggrDistinctSum -> distinctSummaryText Sql.AggrSum;
        Sql.AggrDistinctAvg -> distinctSummaryText Sql.AggrAvg;

        Sql.AggrCountAll -> text (functionNameTextFn Sql.AggrCount) ++ text "(*)";

        (Sql.DateTimeAddFunction 
            | Sql.DateTimeDiffFunction) {timeInterval} -> 
            let
                argExpressionText = Sql.timeIntervalToSql builder timeInterval 
                                        ++ text ", " 
                                        ++ buildExpressionList builder builderState arguments;
            in
                text (functionNameTextFn func) ++ text "(" ++ argExpressionText ++ text ")";

        _ -> if (isEmpty arguments) then text (functionNameTextFn func)
             else text (functionNameTextFn func) ++ text "(" ++ buildExpressionList builder builderState arguments ++ text ")";
        ;

private default_functionNameText func = 
    Sql.defaultFunctionName func;

enclose :: String -> String -> String -> String;
private enclose !l r x = l ++ x ++ r;

default_addParens :: Document -> Document;
private default_addParens txt = 
    text "(" ++ txt ++ text ")";

/**
 * Adds quotes, if needed to the specified identifier.
 * For a qualified table name, this will quote each piece of the name separately.
 */
private default_quoteIdentifier = quoteIdentifierHelper default_quotesNeeded "[" "]";

/**
 * Adds quotes, if needed to the specified identifier.
 * For a qualified table name, this will quote each piece of the name separately.
 */
quoteIdentifierHelper :: (String -> Boolean) -> String -> String -> String -> Document;
private quoteIdentifierHelper quotesNeededFn openQuote closeQuote txt =
    let
        separator = ".";
        namePieces = String.splitString separator txt;
        quotedPieces = map (\name -> if (quotesNeededFn name) then enclose openQuote closeQuote name else name) namePieces;
        newIdentifier = join separator quotedPieces;
    in
        text newIdentifier;

/**
 * Returns whether the specified identifier needs to be quoted.
 */
quotesNeededHelper :: (Char -> Boolean) -> (Char -> Boolean) -> String -> Boolean;
private quotesNeededHelper isValidFirstSqlChar isValidSqlChar !txt = 
    let
        txtChars = toList txt;
        firstCharValid = isValidFirstSqlChar (head txtChars);
        otherCharsValid = all isValidSqlChar (tail txtChars);

        allCharsValid = (isEmpty txtChars) || firstCharValid && otherCharsValid;
    in
        not allCharsValid;

/**
 * Returns whether the specified identifier needs to be quoted.
 */
default_quotesNeeded :: String -> Boolean;
private default_quotesNeeded !txt = 
	// Just quote all identifiers because we don't check for reserved keywords
	True;
//        quotesNeededHelper default_isValidFirstSqlChar default_isValidSqlChar txt;

private default_isValidFirstSqlChar !char = Char.isLetter char || char == '_';
private default_isValidSqlChar !char = (Char.isLetterOrDigit char) || (char == '.') || (char == '_');


/**
 * Returns a SQL-safe version of the specified name.
 */
default_makeSafeName :: String -> String;
private default_makeSafeName !name = 
    let
        nameChars = toList name;

        makeSafeChar nameChar = if (default_isValidSqlChar nameChar) then Char.toUpperCase nameChar else '_';
        safeChars = map makeSafeChar nameChars;

        // Ensure that the name doesn't start with an invalid character.
        newNameChars = 
            if (isEmpty safeChars || not (default_isValidFirstSqlChar (head safeChars))) then '_' : safeChars
            else safeChars;
    in
        fromList newNameChars;

/**
 * Returns a SQL-safe version of the specified name and trim the trailing
 * characters if the length of the name exceeds the specified maximum length.
 * @arg safeNameFn
 * @arg maxLength
 * @arg name
 */
default_makeSafeNameWithLengthCheck :: (String -> String) -> Int -> String -> String;
default_makeSafeNameWithLengthCheck safeNameFn !maxLength !name =
    let
        safeName :: String;
        safeName = safeNameFn name;
    in
        if (String.length safeName <= maxLength) then safeName
        else String.substring safeName 0 maxLength;

/**
 * Limits the length of the projected column aliases in the query.
 */
limitColumnAliasLength :: Int -> Query -> Query;
private limitColumnAliasLength maxColumnAliasLen query = 
    let
        oldAliases = Sql.projectedColumnAliases query;

        makeUniqueTruncatedName :: Int -> String -> [String] -> String;
        makeUniqueTruncatedName counter baseName namesInUse = 
            let
                counterText = if (counter == 0) then "" else intToString counter;
                nextName = substring baseName 0 (maxColumnAliasLen - String.length counterText) ++ counterText;
            in
                // Leave the alias alone if it isn't longer than the limit.
                // TODO: would it make sense to check for uniqueness anyway?
                if (String.length baseName <= maxColumnAliasLen) then 
                    baseName
                else if (isElemBy equalsIgnoreCase nextName namesInUse) then 
                    makeUniqueTruncatedName (counter + 1) baseName namesInUse
                else 
                    nextName;

        makeNewAliases :: [String] -> [String] -> [String];
        makeNewAliases !origAliases namesInUse = 
            case origAliases of
            [] -> [];
            alias : tailAliases -> 
                let
                    uniqueTruncatedName = makeUniqueTruncatedName 0 alias namesInUse;
                in
                    uniqueTruncatedName : makeNewAliases tailAliases (uniqueTruncatedName : namesInUse);
            ;

        newAliases :: [String];
        newAliases = makeNewAliases oldAliases [];
    in
        Sql.setColumnAliases query newAliases;

// TODO: make use of the 'skipIfDatabaseExists' flag
private default_buildCreateDatabaseStatement builder databaseRef skipIfDatabaseExists =
    let
        databaseNameText = getDatabaseNameFromReference databaseRef;
    in
        text "CREATE DATABASE" ++ singleSpace ++ Sql.quoteIdentifier builder databaseNameText;

// TODO: make use of the 'onlyIfDatabaseExists' flag
private default_buildDropDatabaseStatement builder databaseRef onlyIfDatabaseExists =
    let
        databaseNameText = getDatabaseNameFromReference databaseRef;
    in
        text "DROP DATABASE" ++ singleSpace ++ Sql.quoteIdentifier builder databaseNameText;
    
// TODO: make use of the 'skipIfTableExists' flag...
private default_buildCreateTableStatement builder tableDesc skipIfTableExists = 
    let
        tableRef = getTableReference tableDesc;
        fieldDescriptions = getTableFields tableDesc;
        constraints = getTableConstraints tableDesc;
        tableNameText = getTableNameFromReference tableRef;

        fieldDefinitions = map (Sql.fieldDescriptionText builder) fieldDescriptions;
        constraintDefinitions = mapIndexed constraintDescriptionText constraints;

        constraintName suffix constraintN = 
            text (Sql.makeSafeSqlName builder (tableNameText ++ "_" ++ suffix ++ (if (constraintN == 0) then "" else intToString constraintN)));

        constraintDescriptionText constraint constraintN = 
            case constraint of
            PrimaryKeyConstraint {primaryKeyFieldNames} -> 
                if (isEmpty primaryKeyFieldNames) then empty
                else text "CONSTRAINT" ++ singleSpace ++ constraintName "PK" constraintN ++ singleSpace ++ text "PRIMARY KEY" ++ singleSpace 
                    ++ text "(" ++ join (text ", ") (map (Sql.quoteIdentifier builder) primaryKeyFieldNames) ++ text ")";

            UniqueConstraint {uniqueFieldNames} -> 
                if (isEmpty uniqueFieldNames) then empty
                else text "CONSTRAINT" ++ singleSpace ++ constraintName "UNQ" constraintN ++ singleSpace ++ text "UNIQUE" ++ singleSpace 
                    ++ text "(" ++ join (text ", ") (map (Sql.quoteIdentifier builder) uniqueFieldNames) ++ text ")";

            ForeignKeyConstraint {foreignTableRef, referencedFields} -> 
                if (isEmpty referencedFields) then empty
                else text "CONSTRAINT" ++ singleSpace ++ constraintName "FK" constraintN ++ singleSpace ++ text "FOREIGN KEY" ++ singleSpace 
                    ++ text "(" ++ join (text ", ") (map (\pr -> Sql.quoteIdentifier builder (fst pr)) referencedFields) ++ text ")"
                    ++ singleSpace ++ text "REFERENCES" ++ singleSpace ++ Sql.quoteIdentifier builder (getTableNameFromReference foreignTableRef) ++ singleSpace 
                    ++ text "(" ++ join(text ", ") (map (\pr -> Sql.quoteIdentifier builder (snd pr)) referencedFields) ++ text ")";
            ;
    in
        text "CREATE TABLE" ++ singleSpace ++ Sql.quoteIdentifier builder tableNameText
            ++ line ++ text "("
            ++ nest 4 (line ++ fillSeparatedList True "," (fieldDefinitions ++ constraintDefinitions))
            ++ line ++ text ")";

private default_buildFieldDescription builder fieldDesc = 
    let
        fieldTypeText = Sql.fieldTypeText builder (getFieldDataType fieldDesc);
        nullableText = if (isFieldNullable fieldDesc) then "NULL" else "NOT NULL";
    in
        spread [Sql.quoteIdentifier builder (getFieldName fieldDesc), fieldTypeText, text nullableText];

// The default SQL built for field types is roughly based on ANSI SQL.
default_buildFieldType :: SqlType -> Document;
private default_buildFieldType !dataType = 
    case dataType of
    SqlType_TinyInt            -> text $ "SMALLINT";        // ANSI SQL doesn't seem to have a TinyInt type, so use the SmallInt type instead.
    SqlType_SmallInt           -> text $ "SMALLINT";
    SqlType_Integer            -> text $ "INTEGER";
    SqlType_BigInt             -> text $ "DECIMAL(19, 0)";  // ANSI SQL doesn't seem to have a BigInt type, so use the Decimal type instead.
    SqlType_Decimal {precision, scale} -> text $ "DECIMAL(" ++ intToString precision ++ ", " ++ intToString scale ++ ")";
    SqlType_Numeric {precision, scale} -> text $ "NUMERIC(" ++ intToString precision ++ ", " ++ intToString scale ++ ")";
    SqlType_Real               -> text $ "REAL";
    SqlType_Float              -> text $ "FLOAT";
    SqlType_Double             -> text $ "DOUBLE PRECISION";
    SqlType_Bit                -> text $ "BIT";
    SqlType_Boolean            -> text $ "BOOLEAN";
    SqlType_Char {length}      -> text $ "CHARACTER(" ++ intToString length ++ ")";
    SqlType_VarChar {length}   -> text $ "CHARACTER VARYING(" ++ intToString length ++ ")";
    SqlType_LongVarChar        -> text $ "CLOB";    // TODO: is this the best option here?
    SqlType_Clob               -> text $ "CLOB";
    SqlType_Binary {length}    -> text $ "BIT(" ++ intToString length ++ ")";
    SqlType_VarBinary {length} -> text $ "BIT VARYING(" ++ intToString length ++ ")";
    SqlType_LongVarBinary      -> text $ "BLOB";    // TODO: is this the best option here?
    SqlType_Blob               -> text $ "BLOB";
    SqlType_Date               -> text $ "DATE";
    SqlType_Time               -> text $ "TIME";
    SqlType_TimeStamp          -> text $ "TIMESTAMP";
    _ -> error ("Unsupported data type '" ++ show dataType ++ "'.");
    ;

private default_buildCreateViewStatement builder viewRef viewDefinition skipIfViewExists = 
    group $ 
        text "CREATE VIEW " 
            ++ singleSpace ++ Sql.quoteIdentifier builder (getTableNameFromReference viewRef)
            ++ singleSpace ++ text "AS"
            ++ nest 4 (line ++ Sql.queryTextDocument builder viewDefinition);

// TODO: make use of the 'onlyIfTableExists' flag...
private default_buildDropTableStatement builder tableRef onlyIfTableExists = 
    text "DROP TABLE" ++ singleSpace ++ Sql.quoteIdentifier builder (getTableNameFromReference tableRef);

private default_buildDropViewStatement builder viewRef onlyIfViewExists = 
    text "DROP VIEW" ++ singleSpace ++ Sql.quoteIdentifier builder (getTableNameFromReference viewRef);

private default_buildInsertValuesStatement builder tableRef maybeDestColumns rowValues = 
    let
        destColumnText = 
            case maybeDestColumns of
            Nothing -> empty;
            Just destColumns -> 
                text "(" ++ join (text ", ") (map (Sql.quoteIdentifier builder) destColumns) ++ text ")";
            ;
    in
        spread [text "INSERT INTO",
                Sql.quoteIdentifier builder (getTableNameFromReference tableRef),
                destColumnText,
                text "VALUES",
                text ("(" ++ join ", " (map (Sql.expressionText builder) rowValues) ++ ")")
               ];

private default_buildInsertQueryValuesStatement builder tableRef maybeDestColumns insertQuery =
    let
        destColumnText = 
            case maybeDestColumns of
            Nothing -> empty;
            Just destColumns -> 
                text "(" ++ join (text ", ") (map (Sql.quoteIdentifier builder) destColumns) ++ text ")";
            ;
    in
        group $ 
            spread [text "INSERT INTO",
                    Sql.quoteIdentifier builder (getTableNameFromReference tableRef),
                    destColumnText]
            ++ nest 4 (line ++ Sql.queryTextDocument builder insertQuery);

private default_buildUpdateValuesStatement builder builderState tableRef destColumns newValues condition = 
    let
        colValueText :: String -> Expr -> Document;
        colValueText colName newValue = 
            Sql.quoteIdentifier builder colName ++ text " = " ++ Sql.expressionText2 builder builderState newValue;

        colValuesText :: Document;
        colValuesText = 
            join (text ", ") (List.zipWith colValueText destColumns newValues);

        whereLineText :: Document;
        whereLineText = 
            // Don't include a WHERE clause if the restriction is 'True'.
            if (condition == Sql.trueConstant) then empty
            else line ++ text "WHERE" ++ singleSpace ++ Sql.expressionText2 builder builderState (toUntypedExpr condition);
    in
        group $ 
            text "UPDATE" ++ singleSpace ++ Sql.quoteIdentifier builder (getTableNameFromReference tableRef)
            ++ nest 4 (
                line ++ text "SET" ++ singleSpace ++ colValuesText
                ++ whereLineText
            );

private default_buildDeleteRowsStatement builder builderState tableRef condition = 
    let
        whereLineText :: Document;
        whereLineText = 
            // Don't include a WHERE clause if the restriction is 'True'.
            if (condition == Sql.trueConstant) then empty
            else nest 4 (line ++ text "WHERE" ++ singleSpace ++ Sql.expressionText2 builder builderState (toUntypedExpr condition));
    in
        group $ 
            spread [text "DELETE FROM",
                    Sql.quoteIdentifier builder (getTableNameFromReference tableRef)]
            ++ whereLineText;

private default_buildCommitStatement builder = text "COMMIT";


//////////////////////////////////////////////////////////////////////////////////////////////
// ODBC SQL Builders
//////////////////////////////////////////////////////////////////////////////////////////////

/**
 * The ODBC SQL builder generates queries which will work with typical ODBC datasources.
 * More specialized versions might be needed for certain ODBC drivers and/or database servers.
 */
public odbcSqlBuilder = Sql.makeSqlBuilder default_prepareQuery 
                            (default_constructQuery odbcSqlBuilder)
                            (default_constructUnionQuery odbcSqlBuilder)
                            (default_buildSelectClause odbcSqlBuilder)
                            (default_buildFromClause odbcSqlBuilder)
                            (default_buildWhereClause odbcSqlBuilder)
                            (default_buildOrderByClause odbcSqlBuilder)
                            (default_buildGroupByClause odbcSqlBuilder)
                            (default_buildHavingClause odbcSqlBuilder)

                            (default_buildCreateDatabaseStatement odbcSqlBuilder)
                            (default_buildDropDatabaseStatement odbcSqlBuilder)
                            (default_buildCreateTableStatement odbcSqlBuilder)
                            (default_buildCreateViewStatement odbcSqlBuilder)
                            (default_buildDropTableStatement odbcSqlBuilder)
                            (default_buildDropViewStatement odbcSqlBuilder)
                            (default_buildInsertValuesStatement odbcSqlBuilder)
                            (default_buildInsertQueryValuesStatement odbcSqlBuilder)
                            (default_buildUpdateValuesStatement odbcSqlBuilder)
                            (default_buildDeleteRowsStatement odbcSqlBuilder)
                            (default_buildCommitStatement odbcSqlBuilder)
                            (default_buildFieldDescription odbcSqlBuilder)
                            default_buildFieldType

                            (default_parameterToSql odbcSqlBuilder)
                            (default_listToSql odbcSqlBuilder)
                            (odbc_functionToSql odbcSqlBuilder)

                            default_addParens
                            default_quoteIdentifier

                            (default_buildTableAndAliasText odbcSqlBuilder)
                            default_makeSafeName

                            odbc_primitiveValueBuilder;

private odbc_primitiveValueBuilder = 
    Sql.makePrimitiveValueBuilder 
        default_intToSql
        default_doubleToSql
        default_stringToSql
        default_timeToSql
        default_booleanToSql
        default_nullToSql
        odbc_timeIntervalToSql;

private odbc_timeIntervalToSql !timeInterval = 
    case timeInterval of
    Sql.YearInterval    -> text "SQL_TSI_YEAR"; 
    Sql.QuarterInterval -> text "SQL_TSI_QUARTER";
    Sql.MonthInterval   -> text "SQL_TSI_MONTH";
    Sql.DayInterval     -> text "SQL_TSI_DAY";
    Sql.HourInterval    -> text "SQL_TSI_HOUR";
    Sql.MinuteInterval  -> text "SQL_TSI_MINUTE";
    Sql.SecondInterval  -> text "SQL_TSI_SECOND";
    ;

/**
 * Generates SQL function SQL is the form:  {fn WEEK(Table1.Field1)}
 */
private odbc_functionToSql builder builderState func arguments = 
    let
        baseFunctionSql = default_functionToSql2 odbc_functionNameText builder builderState func arguments;
    in
        // Aggregate functions should not include the function escape sequence.
        if (Sql.isAggregationFunction func || Sql.isOperator func) then baseFunctionSql
        else text "{fn " ++ baseFunctionSql ++ text "}";

/**
 * Override the default names of some of the functions for ODBC.
 */
private odbc_functionNameText func =
    case func of
    Sql.DayOfMonthFunction -> "DAYOFMONTH";
    _ -> default_functionNameText func;
    ;


/**
 * For ODBC-Access, there are some problems using the square brackets as quotes inside of the 
 * ODBC function escape syntax, so use back-quotes instead.
 */
public odbcAccessSqlBuilder = Sql.makeSqlBuilder default_prepareQuery 
                            (default_constructQuery odbcAccessSqlBuilder)
                            (default_constructUnionQuery odbcAccessSqlBuilder)
                            (default_buildSelectClause odbcAccessSqlBuilder)
                            (default_buildFromClause odbcAccessSqlBuilder)
                            (default_buildWhereClause odbcAccessSqlBuilder)
                            (default_buildOrderByClause odbcAccessSqlBuilder)
                            (default_buildGroupByClause odbcAccessSqlBuilder)
                            (default_buildHavingClause odbcAccessSqlBuilder)

                            (default_buildCreateDatabaseStatement odbcSqlBuilder)
                            (default_buildDropDatabaseStatement odbcSqlBuilder)
                            (default_buildCreateTableStatement odbcAccessSqlBuilder)
                            (default_buildCreateViewStatement odbcAccessSqlBuilder)
                            (default_buildDropTableStatement odbcAccessSqlBuilder)
                            (default_buildDropViewStatement odbcAccessSqlBuilder)
                            (default_buildInsertValuesStatement odbcAccessSqlBuilder)
                            (default_buildInsertQueryValuesStatement odbcAccessSqlBuilder)
                            (default_buildUpdateValuesStatement odbcAccessSqlBuilder)
                            (default_buildDeleteRowsStatement odbcAccessSqlBuilder)
                            (default_buildCommitStatement odbcAccessSqlBuilder)
                            (default_buildFieldDescription odbcAccessSqlBuilder)
                            default_buildFieldType

                            (default_parameterToSql odbcAccessSqlBuilder)
                            (default_listToSql odbcAccessSqlBuilder)
                            (odbc_functionToSql odbcAccessSqlBuilder)

                            default_addParens
                            odbcAccess_quoteIdentifier

                            (default_buildTableAndAliasText odbcAccessSqlBuilder)
                            default_makeSafeName

                            msAccess_primitiveValueBuilder;

private odbcAccess_quoteIdentifier = quoteIdentifierHelper default_quotesNeeded "`" "`";


//////////////////////////////////////////////////////////////////////////////////////////////
// MS Jet/Access SQL Builder
//////////////////////////////////////////////////////////////////////////////////////////////

/**
 * The Microsoft Jet SQL builder generates queries which will work with the MS Jet database engine 
 * (which supports MS Access, Excel, Text, and others).
 * Special syntax is used for a few SQL functions.
 */
public msAccessSqlBuilder = msJetSqlBuilder;

public msJetSqlBuilder = Sql.makeSqlBuilder msAccess_prepareQuery 
                            (default_constructQuery msAccessSqlBuilder)
                            (default_constructUnionQuery msAccessSqlBuilder)
                            (default_buildSelectClause msAccessSqlBuilder)
                            (default_buildFromClause msAccessSqlBuilder)
                            (default_buildWhereClause msAccessSqlBuilder)
                            (default_buildOrderByClause msAccessSqlBuilder)
                            (default_buildGroupByClause msAccessSqlBuilder)
                            (default_buildHavingClause msAccessSqlBuilder)

                            (msAccess_buildCreateDatabaseStatement msAccessSqlBuilder)
                            (msAccess_buildDropDatabaseStatement msAccessSqlBuilder)
                            (default_buildCreateTableStatement msAccessSqlBuilder)
                            (default_buildCreateViewStatement msAccessSqlBuilder)
                            (default_buildDropTableStatement msAccessSqlBuilder)
                            (default_buildDropViewStatement msAccessSqlBuilder)
                            (default_buildInsertValuesStatement msAccessSqlBuilder)
                            (default_buildInsertQueryValuesStatement msAccessSqlBuilder)
                            (default_buildUpdateValuesStatement msAccessSqlBuilder)
                            (default_buildDeleteRowsStatement msAccessSqlBuilder)
                            (default_buildCommitStatement msAccessSqlBuilder)
                            (default_buildFieldDescription msAccessSqlBuilder)
                            msAccess_buildFieldType

                            (default_parameterToSql msAccessSqlBuilder)
                            (default_listToSql msAccessSqlBuilder)
                            (msAccess_functionToSql msAccessSqlBuilder)

                            default_addParens
                            default_quoteIdentifier

                            (default_buildTableAndAliasText msAccessSqlBuilder)
                            default_makeSafeName

                            msAccess_primitiveValueBuilder;

private msAccess_buildCreateDatabaseStatement builder databaseRef skipIfDatabaseExists =
    error "Unsupported operation";

private msAccess_buildDropDatabaseStatement builder databaseRef skipIfDatabaseExists =
    error "Unsupported operation";

private msAccess_prepareQuery builderState query = 
    let
        msAccess_maxColumnAliasLen = 64 :: Int;
    in
        limitColumnAliasLength msAccess_maxColumnAliasLen query;

private msAccess_functionToSql builder builderState func arguments = 
    case func of
    Sql.QuarterFunction -> 
        default_functionToSql builder builderState (Sql.FunctionOther "DATEPART") (toUntypedExpr (Sql.stringConstant "q") : arguments);

    Sql.IfNullFunction -> 
        let
            arg1 = head arguments;
            arg2 = head (tail arguments);
            isNullArg = Sql.untypedFunctionExpr (Sql.FunctionOther "ISNULL") [arg1];
        in
            default_functionToSql builder builderState (Sql.FunctionOther "IIF") [isNullArg, arg2, arg1];

    Sql.NullIfFunction ->
        let
            arg1 = head arguments;
            arg2 = head (tail arguments);
            equalArgs = Sql.untypedFunctionExpr Sql.OpEq [arg1, arg2];
        in
            default_functionToSql builder builderState (Sql.FunctionOther "IIF") [equalArgs, toUntypedExpr Sql.nullValue, arg1];

    Sql.OpCase_Simple -> 
        let
            caseArg = head arguments;
            argPairs = chop 2 (tail arguments);

            // Handle the special case where the comparison value is NULL (generate x IS NULL instead of x = NULL).
            switchArgsForPair pr = 
                if (isSingletonList pr) then toUntypedExpr Sql.trueConstant : pr
                else if (Sql.isNullValue (head pr)) then Sql.untypedFunctionExpr Sql.OpIsNull [caseArg] : tail pr
                else Sql.untypedFunctionExpr Sql.OpEq [caseArg, head pr] : tail pr;

            switchArgs = concatMap switchArgsForPair argPairs;
        in
            default_functionToSql builder builderState (Sql.FunctionOther "SWITCH") switchArgs;

    Sql.OpCase_Searched -> 
        let
            argPairs = chop 2 arguments;

            switchArgsForPair pr = 
                if (isSingletonList pr) then toUntypedExpr Sql.trueConstant : pr
                else head pr : tail pr;

            switchArgs = concatMap switchArgsForPair argPairs;
        in
            default_functionToSql builder builderState (Sql.FunctionOther "SWITCH") switchArgs;

    _ -> default_functionToSql builder builderState func arguments;
    ;

private msAccess_buildFieldType !dataType = 
    case dataType of
    SqlType_TinyInt            -> text $ "TINYINT";
    SqlType_SmallInt           -> text $ "SMALLINT";
    SqlType_Integer            -> text $ "INTEGER";
    SqlType_BigInt             -> text $ "DECIMAL(19, 0)";  // MS Access doesn't seem to have a BigInt type, so use the Decimal type instead.
    SqlType_Decimal {precision, scale} -> text $ "DECIMAL(" ++ intToString precision ++ ", " ++ intToString scale ++ ")";
    SqlType_Numeric {precision, scale} -> text $ "DECIMAL(" ++ intToString precision ++ ", " ++ intToString scale ++ ")";
    SqlType_Real               -> text $ "REAL";
    SqlType_Float              -> text $ "FLOAT";
    SqlType_Double             -> text $ "FLOAT";
    SqlType_Bit                -> text $ "BIT";
    SqlType_Boolean            -> text $ "BIT";
    SqlType_Char {length}      -> text $ "CHARACTER(" ++ intToString length ++ ")";     // MS Access doesn't have fix length strings, so treat it as variable length.
    SqlType_VarChar {length}   -> text $ "CHARACTER(" ++ intToString length ++ ")";
    SqlType_LongVarChar        -> text $ "TEXT";
    SqlType_Clob               -> text $ "TEXT";
    SqlType_Binary {length}    -> text $ "BINARY(" ++ intToString length ++ ")";
    SqlType_VarBinary {length} -> text $ "BINARY(" ++ intToString length ++ ")";
    SqlType_LongVarBinary      -> text $ "IMAGE";       // TODO: is this the best type mapping?
    SqlType_Blob               -> text $ "IMAGE";       // TODO: is this the best type mapping?
    SqlType_Date               -> text $ "DATETIME";
    SqlType_Time               -> text $ "DATETIME";
    SqlType_TimeStamp          -> text $ "DATETIME";
    _ -> error ("Unsupported data type '" ++ show dataType ++ "'.");
    ;

private msAccess_primitiveValueBuilder = 
    Sql.makePrimitiveValueBuilder 
        default_intToSql
        default_doubleToSql
        default_stringToSql
        default_timeToSql
        default_booleanToSql
        default_nullToSql
        msAccess_timeIntervalToSql;

private msAccess_timeIntervalToSql !timeInterval = 
    case timeInterval of
    Sql.YearInterval    -> text "'yyyy'"; 
    Sql.QuarterInterval -> text "'q'";
    Sql.MonthInterval   -> text "'m'";
    Sql.DayInterval     -> text "'d'";
    Sql.HourInterval    -> text "'h'";
    Sql.MinuteInterval  -> text "'n'";
    Sql.SecondInterval  -> text "'s'";
    ;

//////////////////////////////////////////////////////////////////////////////////////////////
// MS SQL Server SQL Builder
//////////////////////////////////////////////////////////////////////////////////////////////

/**
 * The Microsoft SQL Server SQL builder generates queries which will work with SQL Server databases.
 * Special syntax is used for some SQL functions.
 */
public msSqlServerSqlBuilder = Sql.makeSqlBuilder msSqlServer_prepareQuery 
                            (default_constructQuery msSqlServerSqlBuilder)
                            (default_constructUnionQuery msSqlServerSqlBuilder)
                            (default_buildSelectClause msSqlServerSqlBuilder)
                            (default_buildFromClause msSqlServerSqlBuilder)
                            (default_buildWhereClause msSqlServerSqlBuilder)
                            (default_buildOrderByClause msSqlServerSqlBuilder)
                            (default_buildGroupByClause msSqlServerSqlBuilder)
                            (default_buildHavingClause msSqlServerSqlBuilder)

                            (msSqlServer_buildCreateDatabaseStatement msSqlServerSqlBuilder)
                            (msSqlServer_buildDropDatabaseStatement msSqlServerSqlBuilder)
                            (msSqlServer_buildCreateTableStatement msSqlServerSqlBuilder)
                            (msSqlServer_buildCreateViewStatement msSqlServerSqlBuilder)
                            (msSqlServer_buildDropTableStatement msSqlServerSqlBuilder)
                            (msSqlServer_buildDropViewStatement msSqlServerSqlBuilder)
                            (default_buildInsertValuesStatement msSqlServerSqlBuilder)
                            (default_buildInsertQueryValuesStatement msSqlServerSqlBuilder)
                            (default_buildUpdateValuesStatement msSqlServerSqlBuilder)
                            (default_buildDeleteRowsStatement msSqlServerSqlBuilder)
                            (default_buildCommitStatement msSqlServerSqlBuilder)
                            (default_buildFieldDescription msSqlServerSqlBuilder)
                            msSqlServer_buildFieldType

                            (default_parameterToSql msSqlServerSqlBuilder)
                            (default_listToSql msSqlServerSqlBuilder)
                            (msSqlServer_functionToSql msSqlServerSqlBuilder)

                            default_addParens
                            default_quoteIdentifier

                            (default_buildTableAndAliasText msSqlServerSqlBuilder)
                            default_makeSafeName

                            defaultPrimitiveValueBuilder;

private msSqlServer_prepareQuery builderState query = 
    let
        msSqlServer_maxColumnAliasLen = 128 :: Int;
    in
        limitColumnAliasLength msSqlServer_maxColumnAliasLen query;

private msSqlServer_functionToSql builder builderState func arguments = 
    case func of
    Sql.QuarterFunction -> 
        default_functionToSql builder builderState (Sql.FunctionOther "DATEPART") (Sql.untypedFunctionExpr (Sql.FunctionOther "q") [] : arguments);
    _ -> 
        default_functionToSql2 msSqlServer_functionNameText builder builderState func arguments;
    ;

/**
 * Override the default names of some of the functions for SQL Server.
 */
private msSqlServer_functionNameText func =
    case func of
    Sql.IfNullFunction     -> "ISNULL";
    Sql.LengthFunction     -> "LEN";
    _ -> default_functionNameText func;
    ;
    
private msSqlServer_buildCreateDatabaseStatement builder databaseRef !skipIfDatabaseExists =
    let
        createText = default_buildCreateDatabaseStatement builder databaseRef False;
        databaseNameText = getDatabaseNameFromReference databaseRef;
    in
        if (skipIfDatabaseExists) then
            text "IF NOT EXISTS("
                ++ nest 4 (line ++ text "SELECT NAME FROM SYS.DATABASES"
                                ++ nest 4 (line ++ text "WHERE NAME = '" ++ text databaseNameText ++ text "'")
                                ++ text ")" ++ line
                                ++ createText)
        else createText;

private msSqlServer_buildDropDatabaseStatement builder databaseRef !onlyIfDatabaseExists =
    let
        dropText = default_buildDropDatabaseStatement builder databaseRef False;
        databaseNameText = getDatabaseNameFromReference databaseRef;
    in
        if (onlyIfDatabaseExists) then
            text "IF EXISTS("
                ++ nest 4 (line ++ text "SELECT NAME FROM SYS.DATABASES"
                                ++ nest 4 (line ++ text "WHERE NAME = '" ++ text databaseNameText ++ text "'")
                                ++ text ")" ++ line
                                ++ dropText)
        else dropText;

private msSqlServer_buildCreateTableStatement builder tableDesc !skipIfTableExists = 
    let
        createText = default_buildCreateTableStatement builder tableDesc False;
        tableNameText = getTableNameFromReference (getTableReference tableDesc);
    in
        if (skipIfTableExists) then
            text "IF NOT EXISTS("
                ++ nest 4 (line ++ text "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES" 
                                ++ nest 4 (line ++ text "WHERE TABLE_NAME = '" ++ text tableNameText ++ text "'") 
                                ++ text ")" ++ line 
                                ++ createText)
        else createText;

private msSqlServer_buildDropTableStatement builder tableRef !onlyIfTableExists = 
    let
        dropText = default_buildDropTableStatement builder tableRef False;
    in
        if (onlyIfTableExists) then
            text "IF EXISTS("
                ++ nest 4 (line ++ text "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES" 
                                ++ nest 4 (line ++ text "WHERE TABLE_NAME = '" ++ text (getTableNameFromReference tableRef) ++ text "'") 
                                ++ text ")" ++ line 
                                ++ dropText)
        else dropText;

private msSqlServer_buildCreateViewStatement builder viewRef viewQuery !skipIfViewExists = 
    let
        createText = default_buildCreateViewStatement builder viewRef viewQuery False;
        viewNameText = getTableNameFromReference viewRef;
    in
        if (skipIfViewExists) then
            text "IF NOT EXISTS("
                ++ nest 4 (line ++ text "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.VIEWS" 
                                ++ nest 4 (line ++ text "WHERE TABLE_NAME = '" ++ text viewNameText ++ text "'") 
                                ++ text ")" ++ line 
                                ++ createText)
        else createText;

private msSqlServer_buildDropViewStatement builder viewRef !onlyIfViewExists = 
    let
        dropText = default_buildDropViewStatement builder viewRef False;
    in
        if (onlyIfViewExists) then
            text "IF EXISTS("
                ++ nest 4 (line ++ text "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.VIEWS" 
                                ++ nest 4 (line ++ text "WHERE TABLE_NAME = '" ++ text (getTableNameFromReference viewRef) ++ text "'") 
                                ++ text ")" ++ line 
                                ++ dropText)
        else dropText;

private msSqlServer_buildFieldType !dataType = 
    case dataType of
    SqlType_TinyInt            -> text $ "tinyint";
    SqlType_SmallInt           -> text $ "smallint";
    SqlType_Integer            -> text $ "int";
    SqlType_BigInt             -> text $ "bigint";
    SqlType_Decimal {precision, scale} -> text $ "decimal(" ++ intToString precision ++ ", " ++ intToString scale ++ ")";
    SqlType_Numeric {precision, scale} -> text $ "numeric(" ++ intToString precision ++ ", " ++ intToString scale ++ ")";
    SqlType_Real               -> text $ "real";
    SqlType_Float              -> text $ "float";
    SqlType_Double             -> text $ "float";
    SqlType_Bit                -> text $ "bit";
    SqlType_Boolean            -> text $ "bit";
    SqlType_Char {length}      -> text $ "nchar(" ++ intToString length ++ ")";
    SqlType_VarChar {length}   -> text $ "nvarchar(" ++ intToString length ++ ")";
    SqlType_LongVarChar        -> text $ "ntext"; 
    SqlType_Clob               -> text $ "ntext";
    SqlType_Binary {length}    -> text $ "binary(" ++ intToString length ++ ")";
    SqlType_VarBinary {length} -> text $ "varbinary(" ++ intToString length ++ ")";
    SqlType_LongVarBinary      -> text $ "image";
    SqlType_Blob               -> text $ "image";
    SqlType_Date               -> text $ "datetime";
    SqlType_Time               -> text $ "datetime";
    SqlType_TimeStamp          -> text $ "datetime";
    _ -> error ("Unsupported data type '" ++ show dataType ++ "'.");
    ;


//////////////////////////////////////////////////////////////////////////////////////////////
// Oracle SQL Builder
//////////////////////////////////////////////////////////////////////////////////////////////

/**
 * The Oracle SQL builder generates queries which will work with Oracle databases.
 * Quoting of identifiers is different than the default.
 * The double-quote character is used for quoting and this is also needed for table names with lower case letters.
 */
public oracleSqlBuilder = Sql.makeSqlBuilder oracle_prepareQuery 
                            (default_constructQuery oracleSqlBuilder)
                            (default_constructUnionQuery oracleSqlBuilder)
                            (default_buildSelectClause oracleSqlBuilder)
                            (default_buildFromClause oracleSqlBuilder)
                            (default_buildWhereClause oracleSqlBuilder)
                            (default_buildOrderByClause oracleSqlBuilder)
                            (default_buildGroupByClause oracleSqlBuilder)
                            (default_buildHavingClause oracleSqlBuilder)

                            (default_buildCreateDatabaseStatement oracleSqlBuilder) // TODO handle skipIfDatabaseExists
                            (default_buildDropDatabaseStatement oracleSqlBuilder)   // TODO handle onlyIfDatabaseExists
                            (oracle_buildCreateTableStatement oracleSqlBuilder)
                            (oracle_buildCreateViewStatement oracleSqlBuilder)
                            (oracle_buildDropTableStatement oracleSqlBuilder)
                            (oracle_buildDropViewStatement oracleSqlBuilder)
                            (default_buildInsertValuesStatement oracleSqlBuilder)
                            (default_buildInsertQueryValuesStatement oracleSqlBuilder)
                            (default_buildUpdateValuesStatement oracleSqlBuilder)
                            (default_buildDeleteRowsStatement oracleSqlBuilder)
                            (default_buildCommitStatement oracleSqlBuilder)
                            (default_buildFieldDescription oracleSqlBuilder)
                            oracle_buildFieldType

                            (default_parameterToSql oracleSqlBuilder)
                            (default_listToSql oracleSqlBuilder)
                            (oracle_functionToSql oracleSqlBuilder)

                            default_addParens
                            oracle_quoteIdentifier

                            (oracle_tableAndAliasText oracleSqlBuilder)
                            (default_makeSafeNameWithLengthCheck default_makeSafeName 30)

                            oracle_primitiveValueBuilder;

/**
 * Quoting of identifiers is different than the default.
 * The double-quote character is used for quoting and this is also needed for table names with lower case letters.
 */
private oracle_quoteIdentifier = quoteIdentifierHelper oracle_quotesNeeded "\"" "\"";

/**
 * Returns whether the specified identifier needs to be quoted.
 */
oracle_quotesNeeded :: String -> Boolean;
private oracle_quotesNeeded !txt = 
    let
        // Only allow upper case letters in unquoted names.
        // TODO: could this be restricted to table names (since it seems to be ok to have lower case letters in aliases and field names).
        isValidFirstSqlChar char = Char.isLetter char && Char.isUpperCase char;
        isValidSqlChar char = isValidFirstSqlChar char || Char.isDigit char || (char == '.') || (char == '_');
    in
    	if (default_quotesNeeded txt) then True
        else quotesNeededHelper isValidFirstSqlChar isValidSqlChar txt;

/**
 * For Oracle, don't include the 'AS' keyword between a table name and the table alias.
 */
oracle_tableAndAliasText :: SqlBuilder -> SqlBuilderState -> QueryTable -> Document;
private oracle_tableAndAliasText = buildTableAndAliasTextHelper False;

private oracle_primitiveValueBuilder = Sql.makePrimitiveValueBuilder 
                                            default_intToSql
                                            default_doubleToSql
                                            default_stringToSql
                                            oracle_timeToSql
                                            oracle_booleanToSql
                                            default_nullToSql
                                            default_timeIntervalToSql;

/**
 * Generates timestamps in the following form:  TIMESTAMP '2005-05-20 13:23:45.0'
 */
oracle_timestampPattern :: String;
private oracle_timestampPattern = "'TIMESTAMP '''yyyy-MM-dd HH:mm:ss.S''";

private oracle_timeToSql timeVal timeZone = 
    text (Time.formatTime timeVal timeZone Time.gregorianCalendar oracle_timestampPattern Locale.defaultLocale);

private oracle_booleanToSql !boolVal =
    text (if (boolVal) then "1" else "0");

private oracle_prepareQuery builderState query = 
    let
        oracle_maxColumnAliasLen = 30 :: Int;

        // Convert TopN queries to restrict the number of rows using the ranking functions.
        query1 = restructureTopN query;

        query2 = limitColumnAliasLength oracle_maxColumnAliasLen query1;
    in
        query2;
        
/**
 * Customizes the SQL generated for certain Oracle functions.
 */
private oracle_functionToSql builder builderState func arguments = 
    let
        isRankFunction = 
            case func of 
            Sql.FunctionOther {funcName} -> equalsIgnoreCase funcName "RANK";
            _ -> False;
            ;

        isPercentRankFunction = 
            case func of 
            Sql.FunctionOther {funcName} -> equalsIgnoreCase funcName "PERCENT_RANK";
            _ -> False;
            ;

        rankFunctionText isPercentRank = 
            let
                argListPairToOrderInfo pr = 
                    let
                        orderExpr = head pr;
                        isAscOrder = isSingletonList pr || subscript pr 1 != Sql.toUntypedExpr Sql.falseConstant;
                    in
                        (orderExpr, isAscOrder);

                orderExprs = map argListPairToOrderInfo (chop 2 arguments);

                orderByText = default_buildOrderByClause builder builderState orderExprs;

                rankFunctionName = if (isPercentRank) then "PERCENT_RANK" else "RANK";
            in
                text rankFunctionName ++ text "() OVER (ORDER BY " ++ nest 4 (orderByText ++ text ")");

        // Handle functions to extract a time part value from a time expression.
        oracleDatePartText :: Boolean -> String -> Document;
        oracleDatePartText !isNumericResult datePartString = 
            let
                toNumberFn = Sql.FunctionOther "to_number";
                toCharFn = Sql.FunctionOther "to_char";

                toCharArgs :: [Expr];
                toCharArgs = [head arguments, Sql.toUntypedExpr $ Sql.stringConstant datePartString];
            in
                if isNumericResult then default_functionToSql builder builderState toNumberFn [Sql.untypedFunctionExpr toCharFn toCharArgs]
                else default_functionToSql builder builderState toCharFn toCharArgs;
    in
        if (isRankFunction) then rankFunctionText False
        else if (isPercentRankFunction) then rankFunctionText True
        else 
            case func of
            Sql.YearFunction       -> oracleDatePartText True "YYYY";
            Sql.QuarterFunction    -> oracleDatePartText True "Q";
            Sql.MonthFunction      -> oracleDatePartText True "MM";
            Sql.DayOfMonthFunction -> oracleDatePartText True "DD";
            Sql.HourFunction       -> oracleDatePartText True "HH24";
            Sql.MinuteFunction     -> oracleDatePartText True "MI";
            Sql.SecondFunction     -> oracleDatePartText True "SS";
            Sql.DayOfWeekFunction  -> oracleDatePartText True "D";
            Sql.DayOfYearFunction  -> oracleDatePartText True "DDD";
            Sql.WeekFunction       -> oracleDatePartText True "WW";
            Sql.MonthNameFunction  -> oracleDatePartText False "MON";
            Sql.DayNameFunction    -> oracleDatePartText False "DY";
            _ ->
                default_functionToSql builder builderState func arguments;
            ;

private oracle_buildFieldType !dataType = 
    case dataType of
    SqlType_TinyInt            -> text $ "number(38)";  // TODO: are these integer type mappings sensible?
    SqlType_SmallInt           -> text $ "number(38)";
    SqlType_Integer            -> text $ "number(38)";
    SqlType_BigInt             -> text $ "number(38)";
    SqlType_Decimal {precision, scale} -> text $ "number(" ++ intToString precision ++ ", " ++ intToString scale ++ ")";
    SqlType_Numeric {precision, scale} -> text $ "number(" ++ intToString precision ++ ", " ++ intToString scale ++ ")";
    SqlType_Real               -> text $ "real";
    SqlType_Float              -> text $ "float";
    SqlType_Double             -> text $ "double precision";
    SqlType_Bit                -> text $ "number(1)";
    SqlType_Boolean            -> text $ "number(1)";
    SqlType_Char {length}      -> text $ "nchar(" ++ intToString length ++ ")";
    SqlType_VarChar {length}   -> text $ "nvarchar2(" ++ intToString length ++ ")";
    SqlType_LongVarChar        -> text $ "nclob";
    SqlType_Clob               -> text $ "nclob";
    SqlType_Binary {length}    -> text $ "raw(" ++ intToString length ++ ")";   // Oracle doesn't appear to have a fixed-length binary type.
    SqlType_VarBinary {length} -> text $ "raw(" ++ intToString length ++ ")";
    SqlType_LongVarBinary      -> text $ "long raw";
    SqlType_Blob               -> text $ "blob";
    SqlType_Date               -> text $ "date";
    SqlType_Time               -> text $ "timestamp";       // TODO: is this the best type mapping?
    SqlType_TimeStamp          -> text $ "timestamp";
    _ -> error ("Unsupported data type '" ++ show dataType ++ "'.");
    ;

private oracle_buildCreateTableStatement builder tableDesc !skipIfTableExists =
    let
        // TODO escape single quote
        createTableText :: Document;
        createTableText = default_buildCreateTableStatement builder tableDesc False;
    in
        if (skipIfTableExists) then
            text "DECLARE tab_exist PLS_INTEGER;" ++ line
                ++ text "BEGIN" ++ line
                ++ nest 4 (text ("SELECT COUNT(1) INTO tab_exist FROM user_tables WHERE table_name = '" ++ (getTableNameFromReference $ getTableReference tableDesc) ++ "';") ++ line
                         ++ text "IF tab_exist = 0 THEN" ++ line
                         ++ text "EXECUTE IMMEDIATE '" ++ createTableText ++ text "';" ++ line
                         ++ text "END IF;") ++ line
                ++ text "END;"
        else createTableText;

private oracle_buildCreateViewStatement builder viewRef viewDefinition !skipIfViewExists =
    let
        // TODO escape single quote
        createViewText :: Document;
        createViewText = default_buildCreateViewStatement builder viewRef viewDefinition False;
    in
        if (skipIfViewExists) then
            text "DECLARE view_exist PLS_INTEGER;" ++ line
                ++ text "BEGIN" ++ line
                ++ nest 4 (text ("SELECT COUNT(1) INTO view_exist FROM user_views WHERE view_name = '" ++ (getTableNameFromReference viewRef) ++ "';") ++ line
                         ++ text "IF view_exist = 0 THEN" ++ line
                         ++ text "EXECUTE IMMEDIATE '" ++ createViewText ++ text "';" ++ line
                         ++ text "END IF;") ++ line
                ++ text "END;"
        else createViewText;

private oracle_buildDropTableStatement builder tableRef !onlyIfTableExists =
    let
        dropTableText :: Document;
        dropTableText = default_buildDropTableStatement builder tableRef False;
    in
        if (onlyIfTableExists) then
            text "DECLARE tab_exist PLS_INTEGER;" ++ line
                ++ text "BEGIN" ++ line
                ++ nest 4 (text ("SELECT COUNT(1) INTO tab_exist FROM user_tables WHERE table_name = '" ++ (getTableNameFromReference tableRef) ++ "';") ++ line
                         ++ text "IF tab_exist = 1 THEN" ++ line
                         ++ text "EXECUTE IMMEDIATE '" ++ dropTableText ++ text "';" ++ line
                         ++ text "END IF;") ++ line
                ++ text "END;"
        else dropTableText;
        
private oracle_buildDropViewStatement builder viewRef !onlyIfViewExists =
    let
        dropViewText :: Document;
        dropViewText = default_buildDropViewStatement builder viewRef False;
    in
        if (onlyIfViewExists) then
            text "DECLARE view_exist PLS_INTEGER;" ++ line
                ++ text "BEGIN" ++ line
                ++ nest 4 (text ("SELECT COUNT(1) INTO view_exist FROM user_views WHERE view_name = '" ++ (getTableNameFromReference viewRef) ++ "';") ++ line
                         ++ text "IF view_exist = 1 THEN" ++ line
                         ++ text "EXECUTE IMMEDIATE '" ++ dropViewText ++ text "';" ++ line
                         ++ text "END IF;") ++ line
                ++ text "END;"
        else dropViewText;
        
/*
//////////////////////////////////////////////////////////////////////////////////////////////
// This class demonstrates how to alter some of the behaviour of the default SQL builder.
// TODO: remove this test code later...

public otherPrimitiveValueBuilder = Sql.makePrimitiveValueBuilder 
                                            default_intToSql
                                            default_doubleToSql
                                            default_stringToSql
                                            otherSqlBuilder_timeToSql
                                            default_booleanToSql
                                            default_nullToSql;

public otherSqlBuilder = Sql.makeSqlBuilder default_prepareQuery 
                            (default_constructQuery otherSqlBuilder)
                            (default_constructUnionQuery otherSqlBuilder)
                            (default_buildSelectClause otherSqlBuilder)
                            (default_buildFromClause otherSqlBuilder)
                            (default_buildWhereClause otherSqlBuilder)
                            (default_buildOrderByClause otherSqlBuilder)
                            (default_buildGroupByClause otherSqlBuilder)
                            (default_buildHavingClause otherSqlBuilder)

                            (default_buildCreateTableStatement otherSqlBuilder (default_buildFieldDescription default_buildFieldType))
                            (default_buildDropTableStatement otherSqlBuilder)
                            (default_buildInsertValuesStatement otherSqlBuilder)
                            (default_buildCommitStatement otherSqlBuilder)
                            (default_buildFieldDescription otherSqlBuilder)

                            (default_parameterToSql otherSqlBuilder)
                            (default_listToSql otherSqlBuilder)
                            (default_functionToSql otherSqlBuilder)

                            default_addParens
                            default_quoteIdentifier

                            (default_buildTableAndAliasText otherSqlBuilder)
                            default_makeSafeName

                            otherPrimitiveValueBuilder;

private otherTimestampPattern = "MM/dd/yyyy h:mm:ssa";
private otherSqlBuilder_timeToSql timeVal timeZone = Time.formatTime timeVal timeZone Time.gregorianCalendar otherTimestampPattern Locale.defaultLocale;
*/
    
    
//////////////////////////////////////////////////////////////////////////////////////////////
// NCR v2r5 SQL Builder
//////////////////////////////////////////////////////////////////////////////////////////////

public ncrTeradataPrimitiveValueBuilder = Sql.makePrimitiveValueBuilder 
                                            default_intToSql
                                            default_doubleToSql
                                            default_stringToSql
                                            ncrTeradataSqlBuilder_timeToSql
                                            default_booleanToSql
                                            default_nullToSql 
                                            default_timeIntervalToSql;  // TODO: is this correct?

/**
 * The SQL builder generates queries which will work with Teradata databases.
 * Quoting of identifiers is different than the default.
 * The double-quote character is used for quoting and this is also needed for table names with lower case letters.
 */
public ncrTeradataSqlBuilder = Sql.makeSqlBuilder ncrTeradata_prepareQuery 
                            (default_constructQuery ncrTeradataSqlBuilder)
                            (default_constructUnionQuery ncrTeradataSqlBuilder)
                            (default_buildSelectClause ncrTeradataSqlBuilder)
                            (default_buildFromClause ncrTeradataSqlBuilder)
                            (default_buildWhereClause ncrTeradataSqlBuilder)
//                            (ncrTeradatabuildWhereClause ncrTeradataSqlBuilder)
                            (default_buildOrderByClause ncrTeradataSqlBuilder)
                            (default_buildGroupByClause ncrTeradataSqlBuilder)
                            (default_buildHavingClause ncrTeradataSqlBuilder)

                            (default_buildCreateDatabaseStatement ncrTeradataSqlBuilder) // TODO untested! TODO handle skipIfDatabaseExists
                            (default_buildDropDatabaseStatement ncrTeradataSqlBuilder)   // TODO untested! TODO handle onlyIfDatabaseExists
                            (default_buildCreateTableStatement ncrTeradataSqlBuilder)
                            (default_buildCreateViewStatement ncrTeradataSqlBuilder)
                            (default_buildDropTableStatement ncrTeradataSqlBuilder)
                            (default_buildDropViewStatement ncrTeradataSqlBuilder)
                            (default_buildInsertValuesStatement ncrTeradataSqlBuilder)
                            (default_buildInsertQueryValuesStatement ncrTeradataSqlBuilder)
                            (default_buildUpdateValuesStatement ncrTeradataSqlBuilder)
                            (default_buildDeleteRowsStatement ncrTeradataSqlBuilder)
                            (default_buildCommitStatement ncrTeradataSqlBuilder)
                            (default_buildFieldDescription ncrTeradataSqlBuilder)
                            ncrTeradata_buildFieldType

                            (default_parameterToSql ncrTeradataSqlBuilder)
                            (default_listToSql ncrTeradataSqlBuilder)
                            (ncrTeradata_functionToSql ncrTeradataSqlBuilder)

                            default_addParens
                            ncrTeradata_quoteIdentifier

                            (default_buildTableAndAliasText ncrTeradataSqlBuilder)
                            default_makeSafeName

                            ncrTeradataPrimitiveValueBuilder;

//Generates timestamps in the following form: CAST ( '2006-01-13 12:01:00.0' AS TIMESTAMP  ( 3 )  )
ncrTeradataTimestampPattern :: String;
private ncrTeradataTimestampPattern = "'CAST ( '''yyyy-MM-dd HH:mm:ss.S''' AS TIMESTAMP  ( 3 )  )'";
private ncrTeradataSqlBuilder_timeToSql timeVal timeZone = 
    text (Time.formatTime timeVal timeZone Time.gregorianCalendar ncrTeradataTimestampPattern Locale.defaultLocale);
    
    
private ncrTeradata_buildFieldType !dataType = 
    case dataType of
    SqlType_TinyInt            -> text $ "BYTEINT";
    SqlType_SmallInt           -> text $ "SMALLINT";
    SqlType_Integer            -> text $ "INTEGER";
    SqlType_BigInt             -> text $ "DECIMAL(19, 0)";  // Teradata doesn't seem to have a BigInt type, so use the Decimal type instead.
    SqlType_Decimal {precision, scale} -> text $ "DECIMAL(" ++ intToString precision ++ ", " ++ intToString scale ++ ")";
    SqlType_Numeric {precision, scale} -> text $ "NUMERIC(" ++ intToString precision ++ ", " ++ intToString scale ++ ")";
    SqlType_Real               -> text $ "REAL";
    SqlType_Float              -> text $ "FLOAT";
    SqlType_Double             -> text $ "DOUBLE PRECISION";
    SqlType_Bit                -> text $ "BYTEINT";     // TODO: is this the best type mapping?
    SqlType_Boolean            -> text $ "BYTEINT";     // TODO: is this the best type mapping?
    SqlType_Char {length}      -> text $ "CHAR (" ++ intToString length ++ ")";
    SqlType_VarChar {length}   -> text $ "VARCHAR(" ++ intToString length ++ ")";
    SqlType_LongVarChar        -> text $ "LONG VARCHAR";
    SqlType_Clob               -> text $ "LONG VARCHAR";
    SqlType_Binary {length}    -> text $ "BYTE(" ++ intToString length ++ ")";
    SqlType_VarBinary {length} -> text $ "VARBYTE(" ++ intToString length ++ ")";
    SqlType_LongVarBinary      -> text $ "BLOB";    // TODO: is this the best option here?
    SqlType_Blob               -> text $ "BLOB";
    SqlType_Date               -> text $ "DATE";
    SqlType_Time               -> text $ "TIMESTAMP";     // TODO: is this the best type mapping?
    SqlType_TimeStamp          -> text $ "TIMESTAMP";
    _ -> error ("Unsupported data type '" ++ show dataType ++ "'.");
    ;


private ncrTeradata_quoteIdentifier = quoteIdentifierHelper oracle_quotesNeeded "\"" "\"";


private ncrTeradata_prepareQuery builderState query = 
    let
        ncrTearadata_maxColumnAliasLen = 30;

        //for convertQueryColumnsToCartesianJoins to be effective it requires aliases to be assigned
        query1 = Sql.modifyQueries Sql.assignMissingColumnAliases query;
        query2 = Sql.modifyQueries Sql.convertQueryColumnsToCartesianJoins query1;

        // Convert TopN queries to restrict the number of rows using the ranking functions.
        query3 = restructureTopN query2;  

        query4 = Sql.modifyQueries ncrTeradata_castDateFieldsToTimeStamps query3;
        
        query5 = limitColumnAliasLength ncrTearadata_maxColumnAliasLen query4;
    in
        query5;


//v2r5 does not like operations on different subtypes of a datetime field, so in order to use timestamps
//we need to make sure all fields are casted to timestamps as well
ncrTeradata_castDateFieldsToTimeStamps :: Query -> Query;
private ncrTeradata_castDateFieldsToTimeStamps query =
    Sql.transformQueryRestrictionExpr Sql.convertDateQueryFieldsToTimeExprs query;


// Convert TopN queries to restrict the number of rows using the ranking functions.
// On Teradata operand scalar expression containg subquery cannot contain other expressions 
restructureTopN :: Query -> Query;
private restructureTopN query = 
    case (find Sql.isTopNOption (Sql.queryOptions query)) of
    Nothing -> query;
    Just topNInfo -> 
        case topNInfo of
        Sql.TopN {n, percent, withTies} ->
            let
                // Remove the topN option from the query.
                nonTopNQuery :: Query;
                nonTopNQuery = Sql.removeOption query topNInfo;

                queryOrdering :: [(Expr, Boolean)];
                queryOrdering = Sql.orderingExpressions query;

                // If there is ordering in the original query, then use a ranking expression, otherwise use the ROWNUM expr.
                // kbac / agr: should this be an error condition??? -> fix this dummyOrderingFn 
                rankArgs = concatMap (\pr -> [fst pr, Sql.toUntypedExpr (Sql.booleanConstant (snd pr))]) queryOrdering;
                rankExpr = 
                    if (percent) then Sql.untypedFunctionExpr (Sql.FunctionOther "PERCENT_RANK") rankArgs
                    else Sql.untypedFunctionExpr (Sql.FunctionOther "RANK") rankArgs;

                // Wrap the query as a subquery.
                additionalExprs = if (isEmpty queryOrdering) then [rowNumberExpr] else [rankExpr];
                wrapResults = Sql.wrapQuery2 nonTopNQuery additionalExprs;

                wrappedQuery = fst wrapResults;

                // If there is no ordering in the orginal query, then do the topN based on the row number.
                // However, this cannot be done for the TopN% case.
                rowNumberExpr :: Expr;
                rowNumberExpr = 
                    if (percent) then error "Unable to build TopN% SQL for a query with no ordering."
                    else Sql.untypedFunctionExpr (Sql.FunctionOther "ROW_NUMBER() OVER (ORDER BY 1)") [];

                wrappedRankExpr = 
                        head (snd wrapResults);

                nExpr :: Sql.TypedExpr Double;
                nExpr = 
                    if (percent) then 
                        Sql.numericConstant (toDouble n / 100.0)
                    else 
                        Sql.numericConstant (toDouble n);

                topNRestriction = Sql.ltEqExpr (Sql.toTypedExpr wrappedRankExpr) nExpr;
            in
                Sql.restrict wrappedQuery topNRestriction;
        ;
    ;


// Customize the SQL generated for certain Teradata functions.
private ncrTeradata_functionToSql builder builderState func arguments = 
    let
        isRankFunction = 
            case func of 
            Sql.FunctionOther funcName -> String.equalsIgnoreCase funcName "RANK";
            _ -> False;
            ;

        isPercentRankFunction = 
            case func of 
            Sql.FunctionOther {funcName} -> equalsIgnoreCase funcName "PERCENT_RANK";
            _ -> False;
            ;

        convertToTimeFunctionText = text "CAST (" 
            ++ nest 4 (expressionText2 builder builderState (head arguments))
            ++ text " AS TIMESTAMP )"
            ;

        rankFunctionText isPercentRank = 
            let
                argListPairToOrderInfo pr = 
                    let
                        orderExpr = head pr;
                        isAscOrder = isSingletonList pr || subscript pr 1 != Sql.toUntypedExpr Sql.falseConstant;
                    in
                        (orderExpr, isAscOrder);

                orderExprs = map argListPairToOrderInfo (chop 2 arguments);

                orderByText = default_buildOrderByClause builder builderState orderExprs;

                rankFunctionName = if (isPercentRank) then "PERCENT_RANK" else "RANK";
            in
                text rankFunctionName ++ text "() OVER (ORDER BY " ++ nest 4 (orderByText ++ text ")");

        ifNullFunctionText = 
            let
                arg1 = head arguments;
                arg1Text = expressionText2 builder builderState arg1;
                arg2 = head (tail arguments);
                arg2Text = expressionText2 builder builderState arg2;
            in
                text "( CASE WHEN " ++ arg1Text ++ text " IS NULL THEN " ++ arg2Text ++ text " ELSE " ++ arg1Text ++ text " END )"
            ;

	//although the Tera supports the NULLIF but it does it like ti the way we use it so in order
	//to skip the regenaration of the outter expression convert it to CASE
        nullIfFunctionText =            
            let
                arg1 = head arguments;
                arg1Text = expressionText2 builder builderState arg1;
                arg2 = head (tail arguments);
                arg2Text = expressionText2 builder builderState arg2;
            in
                text "( CASE WHEN " ++ arg1Text ++ text " = " ++ arg2Text ++ text " THEN NULL ELSE " ++ arg1Text ++ text " END )"
            ;

        // Handle functions to extract a time part value from a time expression.
        teradataDatePartText :: String -> Document;
        teradataDatePartText datePartString = 
            let
                dateArg = head arguments;
                dateArgText = expressionText2 builder builderState dateArg;
            in
                text ("EXTRACT (" ++ datePartString ++ " FROM ") ++ dateArgText ++ text ")";

        quarterFunctionText =                 
            let
                dateArg = head arguments;
                dateArgText = expressionText2 builder builderState dateArg;
                monthFromDateText = text " WHEN " ++ teradataDatePartText "MONTH"; 
                lineText = text "";//line;
                lessThan4Text = text " < 4 THEN 1";
                lessThan7Text = text " < 7 THEN 2";
                lessThan10Text = text " < 10 THEN 3";
            in
                text "(" ++ text "CASE"
                         ++ lineText ++ nest 10 (monthFromDateText ++ lessThan4Text)
                         ++ lineText ++ nest 4 (monthFromDateText ++ lessThan7Text)
                         ++ lineText ++ nest 4 (monthFromDateText ++ lessThan10Text)
                         ++ lineText ++ nest 4 (text "ELSE 4")
                         ++ lineText ++ text " END )"            
                ;      
    in
        case func of
        Sql.QuarterFunction    -> quarterFunctionText;
        Sql.YearFunction       -> teradataDatePartText "YEAR";
        Sql.MonthFunction      -> teradataDatePartText "MONTH";
        Sql.DayOfMonthFunction -> teradataDatePartText "DAY";
        Sql.HourFunction       -> teradataDatePartText "HOUR";
        Sql.MinuteFunction     -> teradataDatePartText "MINUTE";
        Sql.SecondFunction     -> teradataDatePartText "SECOND";

        Sql.IfNullFunction -> ifNullFunctionText;
        Sql.NullIfFunction -> nullIfFunctionText;
//        Sql.ConvertToStringFunction 
//        Sql.ConvertToIntFunction 
//        Sql.ConvertToDoubleFunction
        Sql.ConvertToTimeFunction -> convertToTimeFunctionText;
        _ -> 
            if (isRankFunction) then rankFunctionText False
            else if (isPercentRankFunction) then rankFunctionText True
            else default_functionToSql builder builderState func arguments;
        ;


//////////////////////////////////////////////////////////////////////////////////////////////
// DB2 Builder
//////////////////////////////////////////////////////////////////////////////////////////////

/**
 * The DB2 SQL builder generates queries which will work with IBM DB2 databases.
 * Quoting of identifiers is different than the default.
 * The double-quote character is used for quoting.
 */
public db2SqlBuilder = Sql.makeSqlBuilder db2_prepareQuery 
                          (default_constructQuery db2SqlBuilder)
                          (default_constructUnionQuery db2SqlBuilder)
                          (default_buildSelectClause db2SqlBuilder)
                          (default_buildFromClause db2SqlBuilder)
                          (default_buildWhereClause db2SqlBuilder)
                          (default_buildOrderByClause db2SqlBuilder)
                          (default_buildGroupByClause db2SqlBuilder)
                          (default_buildHavingClause db2SqlBuilder)

                          (default_buildCreateDatabaseStatement db2SqlBuilder) // TODO handle skipIfDatabaseExists
                          (default_buildDropDatabaseStatement db2SqlBuilder)   // TODO handle onlyIfDatabaseExists
                          (default_buildCreateTableStatement db2SqlBuilder)
                          (default_buildCreateViewStatement db2SqlBuilder)
                          (default_buildDropTableStatement db2SqlBuilder)
                          (default_buildDropViewStatement db2SqlBuilder)
                          (default_buildInsertValuesStatement db2SqlBuilder)
                          (default_buildInsertQueryValuesStatement db2SqlBuilder)
                          (default_buildUpdateValuesStatement db2SqlBuilder)
                          (default_buildDeleteRowsStatement db2SqlBuilder)
                          (default_buildCommitStatement db2SqlBuilder)
                          (default_buildFieldDescription db2SqlBuilder)
                          db2_buildFieldType

                          (default_parameterToSql db2SqlBuilder)
                          (default_listToSql db2SqlBuilder)
                          (db2_functionToSql db2SqlBuilder)

                          default_addParens
                          db2_quoteIdentifier

                          (db2_tableAndAliasText db2SqlBuilder)
                          (default_makeSafeNameWithLengthCheck default_makeSafeName 30)

                          db2_primitiveValueBuilder;

/**
 * Quoting of identifiers is different than the default.
 * The double-quote character is used for quoting.
 */
private db2_quoteIdentifier = quoteIdentifierHelper default_quotesNeeded "\"" "\"";

/**
 * For DB2, don't include the 'AS' keyword between a table name and the table alias.
 */
db2_tableAndAliasText :: SqlBuilder -> SqlBuilderState -> QueryTable -> Document;
private db2_tableAndAliasText = buildTableAndAliasTextHelper False;


private db2_primitiveValueBuilder = Sql.makePrimitiveValueBuilder 
                                       default_intToSql
                                       default_doubleToSql
                                       default_stringToSql
                                       db2_timeToSql
                                       db2_booleanToSql
                                       default_nullToSql
                                       default_timeIntervalToSql;

/**
* Generates timestamps in the following form:  '2005-05-20 13:23:45.0'
*/
db2_timestampPattern :: String;
private db2_timestampPattern = "''yyyy-MM-dd HH:mm:ss.S''";

private db2_timeToSql timeVal timeZone = 
    text (Time.formatTime timeVal timeZone Time.gregorianCalendar db2_timestampPattern Locale.defaultLocale);

private db2_booleanToSql !boolVal =
    text (if (boolVal) then "'1'" else "'0'");

private db2_prepareQuery builderState query = 
    let
        db2_maxColumnAliasLen = 30;  //Tested on UDB

        // Convert TopN queries to restrict the number of rows using the ranking functions.
        query1 = restructureTopN query;
        query2 = limitColumnAliasLength db2_maxColumnAliasLen query1;
    in
        query2;

/**
 * Customizes the SQL generated for certain DB2 functions.
 */
private db2_functionToSql builder builderState func arguments = 
    let
        isRankFunction = 
            case func of 
            Sql.FunctionOther {funcName} -> equalsIgnoreCase funcName "RANK";
            _ -> False;
            ;

        isPercentRankFunction = 
            case func of 
            Sql.FunctionOther {funcName} -> equalsIgnoreCase funcName "PERCENT_RANK";
            _ -> False;
            ;

        rankFunctionText isPercentRank = 
            let
                argListPairToOrderInfo pr = 
                    let
                        orderExpr = head pr;
                        isAscOrder = isSingletonList pr || subscript pr 1 != Sql.toUntypedExpr Sql.falseConstant;
                    in
                        (orderExpr, isAscOrder);

                orderExprs = map argListPairToOrderInfo (chop 2 arguments);

                orderByText = default_buildOrderByClause builder builderState orderExprs;

                rankFunctionName = if (isPercentRank) then "PERCENT_RANK" else "RANK";
            in
                text rankFunctionName ++ text "() OVER (ORDER BY " ++ nest 4 (orderByText ++ text ")");
    in
        if (isRankFunction) then rankFunctionText False
        else if (isPercentRankFunction) then rankFunctionText True
        else default_functionToSql2 db2_functionNameText builder builderState func arguments;

private db2_functionNameText func =
    case func of
    Sql.DayOfWeekFunction  -> "DAYOFWEEK";
    _ -> default_functionNameText func;
    ;

private db2_buildFieldType !dataType = 
    case dataType of
    SqlType_TinyInt            -> text $ "SMALLINT";        // DB2 doesn't seem to have a TinyInt type, so use the SmallInt type instead.
    SqlType_SmallInt           -> text $ "SMALLINT";
    SqlType_Integer            -> text $ "INTEGER";
    SqlType_BigInt             -> text $ "BIGINT";
    SqlType_Decimal {precision, scale} -> text $ "DECIMAL(" ++ intToString precision ++ ", " ++ intToString scale ++ ")";
    SqlType_Numeric {precision, scale} -> text $ "NUMERIC(" ++ intToString precision ++ ", " ++ intToString scale ++ ")";
    SqlType_Real               -> text $ "REAL";
    SqlType_Float              -> text $ "FLOAT";
    SqlType_Double             -> text $ "DOUBLE PRECISION";
    SqlType_Bit                -> text $ "SMALLINT";        // DB2 doesn't seem to have a Bit type, so use the SmallInt type instead.
    SqlType_Boolean            -> text $ "SMALLINT";        // DB2 doesn't seem to have a Boolean type, so use the SmallInt type instead.
    SqlType_Char {length}      -> text $ "CHAR(" ++ intToString length ++ ")";
    SqlType_VarChar {length}   -> text $ "VARCHAR(" ++ intToString length ++ ")";
    SqlType_LongVarChar        -> text $ "LONG VARCHAR";
    SqlType_Clob               -> text $ "CLOB";
    SqlType_Binary {length}    -> text $ "CHAR(" ++ intToString length ++ ") FOR BIT DATA";
    SqlType_VarBinary {length} -> text $ "VARCHAR(" ++ intToString length ++ ") FOR BIT DATA";
    SqlType_LongVarBinary      -> text $ "BLOB";
    SqlType_Blob               -> text $ "BLOB";
    SqlType_Date               -> text $ "DATE";
    SqlType_Time               -> text $ "TIME";
    SqlType_TimeStamp          -> text $ "TIMESTAMP";
    SqlType_Datalink           -> text $ "DATALINK";
    _ -> error ("Unsupported data type '" ++ show dataType ++ "'.");
    ;

        
//////////////////////////////////////////////////////////////////////////////////////////////
// Apache Derby
//////////////////////////////////////////////////////////////////////////////////////////////

/**
 * The SQL builder for Derby differs from the default SQL builder
 * in the identifier quoting characters - double quotes instead of square brackets
 */
public derbySqlBuilder = Sql.makeSqlBuilder default_prepareQuery 

                            (default_constructQuery derbySqlBuilder)
                            (default_constructUnionQuery derbySqlBuilder)

                            (default_buildSelectClause derbySqlBuilder)
                            (default_buildFromClause derbySqlBuilder)
                            (default_buildWhereClause derbySqlBuilder)
                            (default_buildOrderByClause derbySqlBuilder)
                            (default_buildGroupByClause derbySqlBuilder)
                            (default_buildHavingClause derbySqlBuilder)

                            (default_buildCreateDatabaseStatement derbySqlBuilder)
                            (default_buildDropDatabaseStatement derbySqlBuilder)
                            (default_buildCreateTableStatement derbySqlBuilder)
                            (default_buildCreateViewStatement derbySqlBuilder)
                            (default_buildDropTableStatement derbySqlBuilder)
                            (default_buildDropViewStatement derbySqlBuilder)
                            (default_buildInsertValuesStatement derbySqlBuilder)
                            (default_buildInsertQueryValuesStatement derbySqlBuilder)
                            (default_buildUpdateValuesStatement derbySqlBuilder)
                            (default_buildDeleteRowsStatement derbySqlBuilder)
                            (default_buildCommitStatement derbySqlBuilder)
                            (derby_buildFieldDescription derbySqlBuilder)
                            default_buildFieldType

                            (default_parameterToSql derbySqlBuilder)
                            (default_listToSql derbySqlBuilder)
                            (derby_functionToSql derbySqlBuilder)

                            default_addParens
                            derby_quoteIdentifier

                            (default_buildTableAndAliasText derbySqlBuilder)
                            default_makeSafeName

                            defaultPrimitiveValueBuilder;

private derby_quoteIdentifier = quoteIdentifierHelper default_quotesNeeded "\"" "\""; 

private derby_functionToSql builder builderState func arguments = 
    let
        ifNullFunctionText = 
            let
                arg1 = head arguments;
                arg1Text = expressionText2 builder builderState arg1;
                arg2 = head (tail arguments);
                arg2Text = expressionText2 builder builderState arg2;
            in
                text "( CASE WHEN " ++ arg1Text ++ text " IS NULL THEN " ++ arg2Text ++ text " ELSE " ++ arg1Text ++ text " END )"
            ;
    in
        case func of
        Sql.IfNullFunction -> ifNullFunctionText;
        _ -> default_functionToSql builder builderState func arguments;
        ;

private derby_buildFieldDescription builder fieldDesc = 
    let
        fieldTypeText = Sql.fieldTypeText builder (getFieldDataType fieldDesc);
        nullableText = if (isFieldNullable fieldDesc) then "" else "NOT NULL";
    in
        spread [Sql.quoteIdentifier builder (getFieldName fieldDesc), fieldTypeText, text nullableText];
