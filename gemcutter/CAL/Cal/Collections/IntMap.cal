/*
 * Copyright (c) 2007 BUSINESS OBJECTS SOFTWARE LIMITED
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *  
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *  
 *     * Neither the name of Business Objects nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


/*
 * IntMap.cal
 * Creation date: Dec 18, 2003.
 * By: Bo Ilic
 */

/* 
Daan's license:

--------------------------------------------------------------------------------------------
Copyright (c) 2003, Daan Leijen, All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1) Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

2) Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer
   in the documentation and/or other materials provided with the distribution.

3) Neither the name of the Universiteit Utrecht nor the names of its contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
THE POSSIBILITY OF SUCH DAMAGE.
--------------------------------------------------------------------------------------------
*/ 

//
//{-# OPTIONS -cpp -fglasgow-exts #-} 
//-------------------------------------------------------------------------------- 
//{-| Module      :  IntMap
//    Copyright   :  (c) Daan Leijen 2002
//    License     :  BSD-style
//
//    Maintainer  :  daan@cs.uu.nl
//    Stability   :  provisional
//    Portability :  portable
//
//  An efficient implementation of maps from integer keys to values. 
//  
//  1) The module exports some names that clash with the "Prelude" -- 'lookup', 'map', and 'filter'. 
//      If you want to use "IntMap" unqualified, these functions should be hidden.
//
//      > import Prelude hiding (map,lookup,filter)
//      > import IntMap
//
//      Another solution is to use qualified names. 
//
//      > import qualified IntMap
//      >
//      > ... IntMap.single "Paris" "France"
//
//      Or, if you prefer a terse coding style:
//
//      > import qualified IntMap as M
//      >
//      > ... M.single "Paris" "France"
//
//  2) The implementation is based on /big-endian patricia trees/. This data structure 
//  performs especially well on binary operations like 'union' and 'intersection'. However,
//  my benchmarks show that it is also (much) faster on insertions and deletions when 
//  compared to a generic size-balanced map implementation (see "Map" and "Data.FiniteMap").
//   
//  *  Chris Okasaki and Andy Gill,  \"/Fast Mergeable Integer Maps/\",
//     Workshop on ML, September 1998, pages 77--86, <http://www.cse.ogi.edu/~andy/pub/finite.htm>
//
//  *  D.R. Morrison, \"/PATRICIA -- Practical Algorithm To Retrieve Information
//     Coded In Alphanumeric/\", Journal of the ACM, 15(4), October 1968, pages 514--534.
//
//  3) Many operations have a worst-case complexity of /O(min(n,W))/. This means that the
//    operation can become linear in the number of elements 
//    with a maximum of /W/ -- the number of bits in an 'Int' (32 or 64). 
//-}
//--------------------------------------------------------------------------------- 
//module IntMap  ( 
//            -- * Map type
//              IntMap, Key          -- instance Eq,Show
//
//            -- * Operators
//            , (!), (\\)
//
//            -- * Query
//            , isEmpty
//            , size
//            , member
//            , lookup
//            , find          
//            , findWithDefault
//            
//            -- * Construction
//            , empty
//            , single
//
//            -- ** Insertion
//            , insert
//            , insertWith, insertWithKey, insertLookupWithKey
//            
//            -- ** Delete\/Update
//            , delete
//            , adjust
//            , adjustWithKey
//            , update
//            , updateWithKey
//            , updateLookupWithKey
//  
//            -- * Combine
//
//            -- ** Union
//            , union         
//            , unionWith          
//            , unionWithKey
//            , unions
//
//            -- ** Difference
//            , difference
//            , differenceWith
//            , differenceWithKey
//            
//            -- ** Intersection
//            , intersection           
//            , intersectionWith
//            , intersectionWithKey
//
//            -- * Traversal
//            -- ** Map
//            , map
//            , mapWithKey
//            , mapAccum
//            , mapAccumWithKey
//            
//            -- ** Fold
//            , fold
//            , foldWithKey
//
//            -- * Conversion
//            , elems
//            , keys
//            , assocs
//            
//            -- ** Lists
//            , toList
//            , fromList
//            , fromListWith
//            , fromListWithKey
//
//            -- ** Ordered lists
//            , toAscList
//            , fromAscList
//            , fromAscListWith
//            , fromAscListWithKey
//            , fromDistinctAscList
//
//            -- * Filter 
//            , filter
//            , filterWithKey
//            , partition
//            , partitionWithKey
//
//            , split         
//            , splitLookup   
//
//            -- * Subset
//            , subset, subsetBy
//            , properSubset, properSubsetBy
//            
//            -- * Debugging
//            , showTree
//            , showTreeWith
//            ) where
//
//
//import Prelude hiding (lookup,map,filter)
//import Bits 
//import Int
//
//{-
//-- just for testing
//import qualified Prelude
//import Debug.QuickCheck 
//import List (nub,sort)
//import qualified List
//-}  
//

/**
 * An efficient implementation of maps from {@link Int@} to values.
 * 
 * The implementation is based on {@em big-endian patricia trees@}. This data structure 
 * performs especially well on binary operations like {@link union@} and {@link intersection@}.
 *
 * {@unorderedList
 *  {@item
 *   Chris Okasaki and Andy Gill,  "Fast Mergeable Integer Maps",
 *   Workshop on ML, September 1998, pages 77--86, {@url http://www.cse.ogi.edu/~andy/pub/finite.htm@}
 *  @}
 *  {@item
 *   D.R. Morrison, "PATRICIA -- Practical Algorithm To Retrieve Information
 *   Coded In Alphanumeric", Journal of the ACM, 15(4), October 1968, pages 514--534.
 *  @}
 * @}
 * 
 * Many operations have a worst-case complexity of O(min(n,W)). This means that the
 * operation can become linear in the number of elements 
 * with a maximum of W -- the number of bits in an {@link Int@}.
 * 
 * This module is an adaptation of functionality from Daan Leijen's DData collections library for Haskell.
 * The library was obtained from {@url http://www.cs.uu.nl/~daan/ddata.html@}.
 * See the file {@code ThirdPartyComponents/ThirdPartyComponents.txt@} for the DData license.
 * 
 * @author Bo Ilic
 * @see module = "Cal.Collections.Map", "Cal.Collections.LongMap"
 */
module Cal.Collections.IntMap;
import Cal.Core.Prelude using
    typeClass = Appendable, Eq, Inputable, Outputable;
    typeConstructor = Boolean, Int, JObject, Maybe, Ordering, String;
    dataConstructor = False, True, Nothing, Just, LT, EQ, GT;
    function = concat, const, equals, error, fst, input, lessThan, lessThanEquals, output, snd;
    ;
import Cal.Collections.List using
    function = foldLeftStrict, span;
    ;
import Cal.Collections.Set;
import Cal.Core.Bits using
    function = bitwiseAnd, bitwiseXor, complement, highestBitMask;
    ;
import Cal.Core.Debug using
    typeClass = Show;
    function = show;
    ;
import Cal.Utilities.QuickCheck using
    typeClass = Arbitrary;
    typeConstructor = Gen;
    function = arbitrary, coarbitrary, mapGen;
    ; 

//
//{--------------------------------------------------------------------
//  'Standard' Haskell
//  * A "Nat" is a natural machine word (an unsigned Int)
//--------------------------------------------------------------------}
//import Word
//infixl 9 \\
//
//type Nat = Word
//
//natFromInt :: Key -> Nat
//natFromInt i = fromIntegral i
//
//intFromNat :: Nat -> Key
//intFromNat w = fromIntegral w
//
//shiftRL :: Nat -> Key -> Nat
//shiftRL w i   = shiftR w i
//
//
//
//
//{--------------------------------------------------------------------
//  Operators
//--------------------------------------------------------------------}
//
//-- | /O(min(n,W))/. See 'find'.
//(!) :: IntMap a -> Key -> a
//m ! k    = find k m
//
//-- | /O(n+m)/. See 'difference'.
//(\\) :: IntMap a -> IntMap a -> IntMap a
//m1 \\ m2 = difference m1 m2
//
//{--------------------------------------------------------------------
//  Types  
//--------------------------------------------------------------------}
//-- | A map of integers to values @a@.
//data IntMap a = Nil
//              | Tip !Key a
//              | Bin !Prefix !Mask !(IntMap a) !(IntMap a) 
//
//type Prefix = Int
//type Mask   = Int
//type Key    = Int
//

/** A map from keys (of type {@link Int@}) to values (of type {@code a@}). */
data public IntMap a =
    private Nil |
    private Tip 
        key             :: !Int 
        value           :: a |
    private Bin 
        prefix          :: !Int 
        mask            :: !Int 
        leftMap         :: !(IntMap a) 
        rightMap        :: !(IntMap a)
    deriving Eq;
    
//{--------------------------------------------------------------------
//  Query
//--------------------------------------------------------------------}
//-- | /O(1)/. Is the map empty?
//isEmpty :: IntMap a -> Bool
//isEmpty Nil   = True
//isEmpty other = False

/**
 * Returns whether the map is empty.
 * 
 * Complexity: O(1).
 * 
 * @arg t the map.
 * @return {@link True@} if the map is empty; {@link False@} otherwise.
 */
isEmpty :: IntMap a -> Boolean;
public isEmpty !t =
    case t of
    Nil -> True;
    _   -> False;
    ;

//
//-- | /O(n)/. Number of elements in the map.
//size :: IntMap a -> Int
//size t
//  = case t of
//      Bin p m l r -> size l + size r
//      Tip k x -> 1
//      Nil     -> 0

/**
 * Returns the number of elements in the map.
 * 
 * Complexity: O(n).
 * 
 * @arg t the map.
 * @return the number of elements in the map.
 */
size :: IntMap a -> Int;
public size !t =
    case t of
    Bin {leftMap, rightMap} -> size leftMap + size rightMap;
    Tip {}  -> 1;
    Nil     -> 0;
    ;

//
//-- | /O(min(n,W))/. Is the key a member of the map?
//member :: Key -> IntMap a -> Bool
//member k m
//  = case lookup k m of
//      Nothing -> False
//      Just x  -> True
    
/**
 * Returns whether the key is a member of the map.
 * 
 * Complexity: O(min(n,W))
 * 
 * @arg k the key.
 * @arg m the map.
 * @return {@link True@} if the key is a member of the map; {@link False@} otherwise.
 */
member :: Int -> IntMap a -> Boolean;
public member !k !m =
    case lookup k m of
    Nothing -> False;
    Just {} -> True;
    ;

//    
//-- | /O(min(n,W))/. Lookup the value of a key in the map.
//lookup :: Key -> IntMap a -> Maybe a
//lookup k t
//  = case t of
//      Bin p m l r 
//        | nomatch k p m -> Nothing
//        | zero k m      -> lookup k l
//        | otherwise     -> lookup k r
//      Tip kx x 
//        | (k==kx)   -> Just x
//        | otherwise -> Nothing
//      Nil -> Nothing
    
/**
 * Looks up the value at a key in the map.
 * 
 * Complexity: O(min(n,W))
 * 
 * @arg k the key.
 * @arg t the map.
 * @return {@code {@link Just@} value@} if the key is found in the map and associated with the
 *         value, or {@link Nothing@} if the key is not found.
 */
lookup :: Int -> IntMap a -> Maybe a;
public lookup !k !t =
    case t of
    Bin {prefix, mask, leftMap, rightMap} ->
        if (nomatch k prefix mask) then
            Nothing
        else if (zero k mask) then
            lookup k leftMap
        else
            lookup k rightMap;        
    Tip {key, value} ->
        if (k==key) then
            Just value
        else
            Nothing;        
    Nil -> Nothing;
    ;
    
//
//-- | /O(min(n,W))/. Find the value of a key. Calls @error@ when the element can not be found.
//find :: Key -> IntMap a -> a
//find k m
//  = case lookup k m of
//      Nothing -> error ("IntMap.find: key " ++ show k ++ " is not an element of the map")
//      Just x  -> x

/**
 * Finds the value of a key. Calls {@link Prelude.error@} when the element cannot be found.
 * 
 * Complexity: O(min(n,W))
 * 
 * @arg k the key.
 * @arg m the map.
 * @return the value of the key in the map, or a call to {@link Prelude.error@} if it cannot be found.
 * @see lookup, lookupWithDefault
 */
find :: Int -> IntMap a -> a;
public find !k !m =
    case lookup k m of
    Nothing -> error ("Key is not an element of the map");
    Just x -> x;
    ;
    
//
//-- | /O(min(n,W))/. The expression @(findWithDefault def k map)@ returns the value of key @k@ or returns @def@ when
//-- the key is not an element of the map.
//findWithDefault :: a -> Key -> IntMap a -> a
//findWithDefault def k m
//  = case lookup k m of
//      Nothing -> def
//      Just x  -> x
    
/**
 * {@code lookupWithDefault key map defaultValue@} returns the value at the given key or {@code defaultValue@}
 * when the key is not in the map.
 * 
 * Complexity: O(min(n,W))
 *  
 * @arg key the key.
 * @arg map the map.
 * @arg defaultValue the default value to be returned if the key is not in the map.
 * @return the value at the given key or {@code defaultValue@} when the key is not in the map.
 */
lookupWithDefault :: Int -> IntMap a -> a -> a;
public lookupWithDefault !key !map defaultValue =
    case lookup key map of
    Nothing -> defaultValue;
    Just x -> x;
    ;
    
//
//{--------------------------------------------------------------------
//  Construction
//--------------------------------------------------------------------}
//-- | /O(1)/. The empty map.
//empty :: IntMap a
//empty
//  = Nil
    
/**
 * The empty map.
 * 
 * Complexity: O(1)
 * 
 * @return an empty map.
 */ 
empty :: IntMap a;
public empty = Nil;

//
//-- | /O(1)/. A map of one element.
//single :: Key -> a -> IntMap a
//single k x
//  = Tip k x

/**
 * Creates a map with a single element.
 * 
 * Complexity: O(1)
 * 
 * @arg k the key.
 * @arg x the value.
 * @return a map with the specified key-value pair as its single element.
 */
single :: Int -> a -> IntMap a;
public single !k x = Tip k x;

//
//{--------------------------------------------------------------------
//  Insert
//  'insert' is the inlined version of 'insertWith (\k x y -> x)'
//--------------------------------------------------------------------}
//-- | /O(min(n,W))/. Insert a new key\/value pair in the map. When the key 
//-- is already an element of the set, it's value is replaced by the new value, 
//-- ie. 'insert' is left-biased.
//insert :: Key -> a -> IntMap a -> IntMap a
//insert k x t
//  = case t of
//      Bin p m l r 
//        | nomatch k p m -> join k (Tip k x) p t
//        | zero k m      -> Bin p m (insert k x l) r
//        | otherwise     -> Bin p m l (insert k x r)
//      Tip ky y 
//        | k==ky         -> Tip k x
//        | otherwise     -> join k (Tip k x) ky t
//      Nil -> Tip k x

/**
 * Inserts a new key/value pair in the map. When the key is already an element of
 * the set, it's value is replaced by the new value, ie. {@code insert@} is
 * left-biased.
 * 
 * Complexity: O(min(n,W))
 * 
 * @arg k the key.
 * @arg x the value.
 * @arg t the map into which the key-value pair is to be inserted.
 * @return the map with the key-value pair inserted.
 */
insert :: Int -> a -> IntMap a -> IntMap a;
public insert !k x !t =
    case t of
    Bin p m l r ->
        if (nomatch k p m) then
            join k (Tip k x) p t
        else if (zero k m) then
            Bin p m (insert k x l) r
        else
            Bin p m l (insert k x r);
    Tip ky y ->
        if (k==ky) then
            Tip k x
        else
            join k (Tip k x) ky t;
    Nil -> Tip k x;
    ;
    
//
//-- right-biased insertion, used by 'union'
//-- | /O(min(n,W))/. Insert with a combining function.
//insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
//insertWith f k x t
//  = insertWithKey (\k x y -> f x y) k x t

/**
 * Inserts a new key and value in the map with a combining function.
 * 
 * Complexity: O(min(n,W))
 *
 * @arg f the combining function.
 * @arg k the key.
 * @arg x the value.
 * @arg t the map into which the key-value pair is to be inserted.
 * @return the map with the key-value pair inserted.
 */
insertWith :: (a -> a -> a) -> Int -> a -> IntMap a -> IntMap a;
public insertWith f !k x !t = insertWithKey (\k x y -> f x y) k x t;

//
//-- | /O(min(n,W))/. Insert with a combining function.
//insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
//insertWithKey f k x t
//  = case t of
//      Bin p m l r 
//        | nomatch k p m -> join k (Tip k x) p t
//        | zero k m      -> Bin p m (insertWithKey f k x l) r
//        | otherwise     -> Bin p m l (insertWithKey f k x r)
//      Tip ky y 
//        | k==ky         -> Tip k (f k x y)
//        | otherwise     -> join k (Tip k x) ky t
//      Nil -> Tip k x

/**
 * Inserts a new key and value in the map with a combining function.
 * 
 * Complexity: O(min(n,W))
 *
 * @arg f the combining function.
 * @arg k the key.
 * @arg x the value.
 * @arg t the map into which the key-value pair is to be inserted.
 * @return the map with the key-value pair inserted.
 */
insertWithKey :: (Int -> a -> a -> a) -> Int -> a -> IntMap a -> IntMap a;
public insertWithKey f !k x !t =
    case t of
    Bin p m l r ->
        if (nomatch k p m) then
            join k (Tip k x) p t
        else if (zero k m) then
            Bin p m (insertWithKey f k x l) r
        else 
            Bin p m l (insertWithKey f k x r);
    Tip ky y ->
        if (k == ky) then
            Tip k (f k x y)
        else
            join k (Tip k x) ky t;
    Nil -> Tip k x;
    ;
    
//
//
//-- | /O(min(n,W))/. The expression (@insertLookupWithKey f k x map@) is a pair where
//-- the first element is equal to (@lookup k map@) and the second element
//-- equal to (@insertWithKey f k x map@).
//insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> (Maybe a, IntMap a)
//insertLookupWithKey f k x t
//  = case t of
//      Bin p m l r 
//        | nomatch k p m -> (Nothing,join k (Tip k x) p t)
//        | zero k m      -> let (found,l') = insertLookupWithKey f k x l in (found,Bin p m l' r)
//        | otherwise     -> let (found,r') = insertLookupWithKey f k x r in (found,Bin p m l r')
//      Tip ky y 
//        | k==ky         -> (Just y,Tip k (f k x y))
//        | otherwise     -> (Nothing,join k (Tip k x) ky t)
//      Nil -> (Nothing,Tip k x)
    
/**
 * {@code insertLookupWithKey f k x map@} is a pair where the first element is equal to
 * {@code {@link lookup@} k map@} and the second element equal to {@code {@link insertWithKey@} f k x map@}.
 * 
 * Complexity: O(min(n,W))
 * 
 * @arg f the combining function.
 * @arg k the key.
 * @arg x the value.
 * @arg t the map into which the key-value pair is to be inserted.
 * @return the map with the key-value pair inserted.
 */
insertLookupWithKey :: (Int -> a -> a -> a) -> Int -> a -> IntMap a -> (Maybe a, IntMap a);
public insertLookupWithKey f !k x !t =
    case t of
        Bin p m l r ->
            if (nomatch k p m) then
                (Nothing, join k (Tip k x) p t)
            else if (zero k m) then
                let 
                    (found, lNew) = insertLookupWithKey f k x l; 
                in
                    (found, Bin p m lNew r)
            else 
                let 
                    (found, rNew) = insertLookupWithKey f k x r;
                in
                    (found, Bin p m l rNew);
        Tip ky y ->
            if (k==ky) then
                (Just y, Tip k (f k x y))
            else
                (Nothing, join k (Tip k x) ky t);
        Nil -> (Nothing, Tip k x);
        ;
//
//
//{--------------------------------------------------------------------
//  Deletion
//  [delete] is the inlined version of [deleteWith (\k x -> Nothing)]
//--------------------------------------------------------------------}
//-- | /O(min(n,W))/. Delete a key and its value from the map. When the key is not
//-- a member of the map, the original map is returned.
//delete :: Key -> IntMap a -> IntMap a
//delete k t
//  = case t of
//      Bin p m l r 
//        | nomatch k p m -> t
//        | zero k m      -> bin p m (delete k l) r
//        | otherwise     -> bin p m l (delete k r)
//      Tip ky y 
//        | k==ky         -> Nil
//        | otherwise     -> t
//      Nil -> Nil
        
/**
 * Deletes a key and its value from the map. When the key is not a member of the
 * map, the original map is returned.
 * 
 * Complexity: O(log n)
 * 
 * @arg k the key.
 * @arg t the map.
 * @return the map, with the specified key and its corresponding value deleted if present.
 */
delete :: Int -> IntMap a -> IntMap a;
public delete !k !t =
    case t of
        Bin p m l r ->
            if (nomatch k p m) then
                t
            else if (zero k m) then
                bin p m (delete k l) r
            else
                bin p m l (delete k r);
        Tip ky y ->
            if (k == ky) then
                Nil
            else
                t;
        Nil -> Nil;
        ;
    
//
//-- | /O(min(n,W))/. Adjust a value at a specific key. When the key is not
//-- a member of the map, the original map is returned.
//adjust ::  (a -> a) -> Key -> IntMap a -> IntMap a
//adjust f k m
//  = adjustWithKey (\k x -> f x) k m
        
/**
 * Adjusts a value at a specific key. When the key is not a member of the map,
 * the original map is returned.
 * 
 * Complexity: O(min(n,W))
 * 
 * @arg f the function used to map the old value associated with the key to the new value.
 * @arg k the key.
 * @arg m the map.
 * @return the map, with the value at the specified key adjusted if present.
 */
adjust :: (a -> a) -> Int -> IntMap a -> IntMap a;
public adjust f !k !m =
    adjustWithKey (\k x -> f x) k m;
        
//
//-- | /O(min(n,W))/. Adjust a value at a specific key. When the key is not
//-- a member of the map, the original map is returned.
//adjustWithKey ::  (Key -> a -> a) -> Key -> IntMap a -> IntMap a
//adjustWithKey f k m
//  = updateWithKey (\k x -> Just (f k x)) k m

/**
 * Adjusts a value at a specific key. When the key is not a member of the map,
 * the original map is returned.
 * 
 * Complexity: O(min(n,W))
 * 
 * @arg f the function which, when given the old key-value pair, returns the new value to be associated with the key.
 * @arg k the key.
 * @arg m the map.
 * @return the map, with the value at the specified key adjusted if present.
 */
adjustWithKey :: (Int -> a -> a) -> Int -> IntMap a -> IntMap a;
public adjustWithKey f !k !m =
    updateWithKey (\k x -> Just (f k x)) k m;
    
//
//-- | /O(min(n,W))/. The expression (@update f k map@) updates the value @x@
//-- at @k@ (if it is in the map). If (@f x@) is @Nothing@, the element is
//-- deleted. If it is (@Just y@), the key @k@ is bound to the new value @y@.
//update ::  (a -> Maybe a) -> Key -> IntMap a -> IntMap a
//update f k m
//  = updateWithKey (\k x -> f x) k m

/**
 * {@code update f k map@} updates the value {@code x@} at {@code k@} (if it is in the map). If {@code f x@} is
 * {@link Nothing@}, the element is deleted. If it is {@code {@link Just@} y@}, the key {@code k@} is bound to the
 * new value {@code y@}.
 * 
 * Complexity: O(min(n,W))
 * 
 * @arg f the function used to map the old value associated with the key to the new value.
 * @arg k the key.
 * @arg m the map.
 * @return the map, with the value at the specified key adjusted if present.
 */
update :: (a -> Maybe a) -> Int -> IntMap a -> IntMap a;
public update f !k !m =
    updateWithKey (\k x -> f x) k m;
    
//
//-- | /O(min(n,W))/. The expression (@update f k map@) updates the value @x@
//-- at @k@ (if it is in the map). If (@f k x@) is @Nothing@, the element is
//-- deleted. If it is (@Just y@), the key @k@ is bound to the new value @y@.
//updateWithKey ::  (Key -> a -> Maybe a) -> Key -> IntMap a -> IntMap a
//updateWithKey f k t
//  = case t of
//      Bin p m l r 
//        | nomatch k p m -> t
//        | zero k m      -> bin p m (updateWithKey f k l) r
//        | otherwise     -> bin p m l (updateWithKey f k r)
//      Tip ky y 
//        | k==ky         -> case (f k y) of
//                             Just y' -> Tip ky y'
//                             Nothing -> Nil
//        | otherwise     -> t
//      Nil -> Nil

/**
 * {@code updateWithKey f k map@} updates the value {@code x@} at {@code k@} (if it is in the map). If
 * {@code f k x@} is {@link Nothing@}, the element is deleted. If it is {@code {@link Just@} y@}, the key {@code k@} is
 * bound to the new value {@code y@}.
 * 
 * Complexity: O(min(n,W))
 * 
 * @arg f the function which, when given the old key-value pair, returns the new value to be associated with the key.
 * @arg k the key.
 * @arg t the map.
 * @return the map, with the value at the specified key adjusted if present.
 */
updateWithKey :: (Int -> a -> Maybe a) -> Int -> IntMap a -> IntMap a;
public updateWithKey f !k !t =
    case t of
    Bin p m l r ->
        if (nomatch k p m) then
            t
        else if (zero k m) then
            bin p m (updateWithKey f k l) r
        else
            bin p m l (updateWithKey f k r);
    Tip ky y ->
        if (k==ky) then
            case (f k y) of
            Just yNew -> Tip ky yNew;
            Nothing -> Nil;            
        else
            t;    
    Nil -> Nil;
    ;

//
//-- | /O(min(n,W))/. Lookup and update.
//updateLookupWithKey ::  (Key -> a -> Maybe a) -> Key -> IntMap a -> (Maybe a,IntMap a)
//updateLookupWithKey f k t
//  = case t of
//      Bin p m l r 
//        | nomatch k p m -> (Nothing,t)
//        | zero k m      -> let (found,l') = updateLookupWithKey f k l in (found,bin p m l' r)
//        | otherwise     -> let (found,r') = updateLookupWithKey f k r in (found,bin p m l r')
//      Tip ky y 
//        | k==ky         -> case (f k y) of
//                             Just y' -> (Just y,Tip ky y')
//                             Nothing -> (Just y,Nil)
//        | otherwise     -> (Nothing,t)
//      Nil -> (Nothing,Nil)
   
/**
 * Simultaneously looks up and updates the map at a specific key.
 * 
 * Complexity: O(min(n,W))
 * 
 * @arg f the function which, when given the old key-value pair, returns the new
 *        value to be associated with the key.
 * @arg k the key.
 * @arg t the map.
 * @return a pair. The first element contains either {@code {@link Just@} value@} if the key was
 *         originally associated with value, or {@link Nothing@} otherwise. The second
 *         element contains the map, with the value at the specified key
 *         adjusted if present.
 */
updateLookupWithKey :: (Int -> a -> Maybe a) -> Int -> IntMap a -> (Maybe a, IntMap a);
public updateLookupWithKey f !k !t =
    case t of
    Bin p m l r ->
        if (nomatch k p m) then
            (Nothing, t)
        else if (zero k m) then
            let 
                (found, lNew) = updateLookupWithKey f k l;
            in
                (found, bin p m lNew r)
        else
            let
                (found, rNew) = updateLookupWithKey f k r;
            in
                (found, bin p m l rNew);
    Tip ky y ->
        if (k==ky) then
            case (f k y) of
            Just yNew -> (Just y, Tip ky yNew);
            Nothing -> (Just y,Nil);            
        else
            (Nothing, t);
    Nil -> (Nothing,Nil);
    ;
        
    
//
//
//{--------------------------------------------------------------------
//  Union
//--------------------------------------------------------------------}
//-- | The union of a list of maps.
//unions :: [IntMap a] -> IntMap a
//unions xs
//  = foldlStrict union empty xs
    
/**
 * Returns the union of a list of maps.
 * 
 * @arg xs a list of maps.
 * @return the union of the maps in the list.
 */
unions :: [IntMap a] -> IntMap a;
public unions xs =
    foldLeftStrict union empty xs;

/**
 * Returns the union of a list of maps, with a combining operation.
 * 
 * @arg f the combining function.
 * @arg xs a list of maps.
 * @return the union of the maps in the list.
 */
unionsWith :: (a -> a -> a) -> [IntMap a] -> IntMap a;
public unionsWith f !xs = foldLeftStrict (unionWith f) empty xs;

/**
 * Returns the union of a list of maps, with a combining operation.
 * 
 * @arg f the combining function.
 * @arg xs a list of maps.
 * @return the union of the maps in the list.
 */
unionsWithKey :: (Int -> a -> a -> a) -> [IntMap a] -> IntMap a;
public unionsWithKey f !xs = foldLeftStrict (unionWithKey f) empty xs;

//
//
//-- | /O(n+m)/. The (left-biased) union of two sets. 
//union :: IntMap a -> IntMap a -> IntMap a
//union t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
//  | shorter m1 m2  = union1
//  | shorter m2 m1  = union2
//  | p1 == p2       = Bin p1 m1 (union l1 l2) (union r1 r2)
//  | otherwise      = join p1 t1 p2 t2
//  where
//    union1  | nomatch p2 p1 m1  = join p1 t1 p2 t2
//            | zero p2 m1        = Bin p1 m1 (union l1 t2) r1
//            | otherwise         = Bin p1 m1 l1 (union r1 t2)
//
//    union2  | nomatch p1 p2 m2  = join p1 t1 p2 t2
//            | zero p1 m2        = Bin p2 m2 (union t1 l2) r2
//            | otherwise         = Bin p2 m2 l2 (union t1 r2)
//
//union (Tip k x) t = insert k x t
//union t (Tip k x) = insertWith (\x y -> y) k x t  -- right bias
//union Nil t       = t
//union t Nil       = t

/**
 * {@code union t1 t2@} takes the left-biased union of {@code t1@} and {@code t2@}. It prefers {@code t1@} when
 * duplicate keys are encountered, i.e. {@code (union == {@link unionWith@} {@link const@})@}.
 * 
 * Complexity: O(n+m)
 * 
 * @arg t1 the first map.
 * @arg t2 the second map.
 * @return the left-biased union of {@code t1@} and {@code t2@}.
 */
union :: IntMap a -> IntMap a -> IntMap a;
public union !t1 !t2 =
    case t1 of
    Tip k x -> insert k x t2;
    Nil -> t2;
    Bin p1 m1 l1 r1 ->
        case t2 of
        Tip k x -> insertWith (\x y -> y) k x t1;
        Nil -> t1;
        Bin p2 m2 l2 r2 ->
            let
                union1 =
                        if (nomatch p2 p1 m1) then
                            join p1 t1 p2 t2
                        else if (zero p2 m1) then
                            Bin p1 m1 (union l1 t2) r1
                        else
                            Bin p1 m1 l1 (union r1 t2);
                union2 =
                        if (nomatch p1 p2 m2) then
                            join p1 t1 p2 t2
                        else if (zero p1 m2) then
                            Bin p2 m2 (union t1 l2) r2
                        else
                            Bin p2 m2 l2 (union t1 r2);
            in
                if (shorter m1 m2) then
                    union1
                else if (shorter m2 m1) then
                    union2
                else if (p1 == p2) then
                    Bin p1 m1 (union l1 l2) (union r1 r2)
                else
                    join p1 t1 p2 t2; 
        ;
    ;    
    
//
//-- | /O(n+m)/. The union with a combining function. 
//unionWith :: (a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
//unionWith f m1 m2
//  = unionWithKey (\k x y -> f x y) m1 m2
    
/**
 * Returns the left-biased union of two maps, with a combining function.
 * 
 * Complexity: O(n+m)
 * 
 * @arg f the combining function.
 * @arg m1 the first map.
 * @arg m2 the second map.
 * @return the left-biased union of two maps.
 */
unionWith :: (a -> a -> a) -> IntMap a -> IntMap a -> IntMap a;
public unionWith f !m1 !m2 = unionWithKey (\k x y -> f x y) m1 m2;

//
//-- | /O(n+m)/. The union with a combining function. 
//unionWithKey :: (Key -> a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
//unionWithKey f t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
//  | shorter m1 m2  = union1
//  | shorter m2 m1  = union2
//  | p1 == p2       = Bin p1 m1 (unionWithKey f l1 l2) (unionWithKey f r1 r2)
//  | otherwise      = join p1 t1 p2 t2
//  where
//    union1  | nomatch p2 p1 m1  = join p1 t1 p2 t2
//            | zero p2 m1        = Bin p1 m1 (unionWithKey f l1 t2) r1
//            | otherwise         = Bin p1 m1 l1 (unionWithKey f r1 t2)
//
//    union2  | nomatch p1 p2 m2  = join p1 t1 p2 t2
//            | zero p1 m2        = Bin p2 m2 (unionWithKey f t1 l2) r2
//            | otherwise         = Bin p2 m2 l2 (unionWithKey f t1 r2)
//
//unionWithKey f (Tip k x) t = insertWithKey f k x t
//unionWithKey f t (Tip k x) = insertWithKey (\k x y -> f k y x) k x t  -- right bias
//unionWithKey f Nil t  = t
//unionWithKey f t Nil  = t

/**
 * Returns the left-biased union of two maps, with a combining function.
 * 
 * Complexity: O(n+m)
 * 
 * @arg f the combining function.
 * @arg t1 the first map.
 * @arg t2 the second map.
 * @return the left-biased union of two maps.
 */
unionWithKey :: (Int -> a -> a -> a) -> IntMap a -> IntMap a -> IntMap a;
public unionWithKey f !t1 !t2 =
    case t1 of 
    Tip k x -> insertWithKey f k x t2;
    Nil -> t2;
    Bin p1 m1 l1 r1 ->
        case t2 of 
        Tip k x -> insertWithKey (\k x y -> f k y x) k x t1;
        Nil -> t1;
        Bin p2 m2 l2 r2 ->
            let 
                union1 = 
                    if (nomatch p2 p1 m1) then
                        join p1 t1 p2 t2
                    else if (zero p2 m1) then
                        Bin p1 m1 (unionWithKey f l1 t2) r1
                    else 
                        Bin p1 m1 l1 (unionWithKey f r1 t2);
                union2 =
                    if (nomatch p1 p2 m2) then
                        join p1 t1 p2 t2
                    else if (zero p1 m2) then
                        Bin p2 m2 (unionWithKey f t1 l2) r2
                    else
                        Bin p2 m2 l2 (unionWithKey f t1 r2);
            in
                if (shorter m1 m2) then
                    union1
                else if (shorter m2 m1) then
                    union2
                else if (p1 == p2) then
                    Bin p1 m1 (unionWithKey f l1 l2) (unionWithKey f r1 r2)
                else
                    join p1 t1 p2 t2;
        ;
    ;

//
//{--------------------------------------------------------------------
//  Difference
//--------------------------------------------------------------------}
//-- | /O(n+m)/. Difference between two maps (based on keys). 
//difference :: IntMap a -> IntMap a -> IntMap a
//difference t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
//  | shorter m1 m2  = difference1
//  | shorter m2 m1  = difference2
//  | p1 == p2       = bin p1 m1 (difference l1 l2) (difference r1 r2)
//  | otherwise      = t1
//  where
//    difference1 | nomatch p2 p1 m1  = t1
//                | zero p2 m1        = bin p1 m1 (difference l1 t2) r1
//                | otherwise         = bin p1 m1 l1 (difference r1 t2)
//
//    difference2 | nomatch p1 p2 m2  = t1
//                | zero p1 m2        = difference t1 l2
//                | otherwise         = difference t1 r2
//
//difference t1@(Tip k x) t2 
//  | member k t2  = Nil
//  | otherwise    = t1
//
//difference Nil t       = Nil
//difference t (Tip k x) = delete k t
//difference t Nil       = t
    
/**
 * Returns the difference of two maps (based on keys).
 * 
 * Complexity: O(n+m)
 * 
 * @arg t1 the first map.
 * @arg t2 the second map.
 * @return the difference of the two maps.
 */
difference :: IntMap a -> IntMap b -> IntMap a;
public difference !t1 !t2 =
    case t1 of
    Tip k x ->
        if (member k t2) then
            Nil
        else
            t1;
    Nil -> Nil;
    Bin p1 m1 l1 r1 ->
        case t2 of
        Tip k x -> delete k t1;
        Nil -> t1;
        Bin p2 m2 l2 r2 ->
            let 
                difference1 = 
                    if (nomatch p2 p1 m1) then
                        t1
                    else if (zero p2 m1) then
                        bin p1 m1 (difference l1 t2) r1
                    else
                        bin p2 m1 l1 (difference r1 t2);
                difference2 =
                    if (nomatch p1 p2 m2) then
                        t1
                    else if (zero p1 m2) then
                        difference t1 l2
                    else
                        difference t1 r2;
            in
                if (shorter m1 m2) then
                    difference1
                else if (shorter m2 m1) then
                    difference2
                else if (p1==p2) then
                    bin p1 m1 (difference l1 l2) (difference r1 r2)
                else
                    t1;
        ;
    ;
    
//
//-- | /O(n+m)/. Difference with a combining function. 
//differenceWith :: (a -> a -> Maybe a) -> IntMap a -> IntMap a -> IntMap a
//differenceWith f m1 m2
//  = differenceWithKey (\k x y -> f x y) m1 m2
    
/**
 * Returns the difference of two maps, with a combining function.
 * 
 * Complexity: O(n+m)
 * 
 * @arg f the combining function.
 * @arg m1 the first map.
 * @arg m2 the second map.
 * @return the difference of the two maps.
 */
differenceWith :: (a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a;
public differenceWith f !m1 !m2 = differenceWithKey (\k x y -> f x y) m1 m2;
    
//
//-- | /O(n+m)/. Difference with a combining function. When two equal keys are
//-- encountered, the combining function is applied to the key and both values.
//-- If it returns @Nothing@, the element is discarded (proper set difference). If
//-- it returns (@Just y@), the element is updated with a new value @y@. 
//differenceWithKey :: (Key -> a -> a -> Maybe a) -> IntMap a -> IntMap a -> IntMap a
//differenceWithKey f t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
//  | shorter m1 m2  = difference1
//  | shorter m2 m1  = difference2
//  | p1 == p2       = bin p1 m1 (differenceWithKey f l1 l2) (differenceWithKey f r1 r2)
//  | otherwise      = t1
//  where
//    difference1 | nomatch p2 p1 m1  = t1
//                | zero p2 m1        = bin p1 m1 (differenceWithKey f l1 t2) r1
//                | otherwise         = bin p1 m1 l1 (differenceWithKey f r1 t2)
//
//    difference2 | nomatch p1 p2 m2  = t1
//                | zero p1 m2        = differenceWithKey f t1 l2
//                | otherwise         = differenceWithKey f t1 r2
//
//differenceWithKey f t1@(Tip k x) t2 
//  = case lookup k t2 of
//      Just y  -> case f k x y of
//                   Just y' -> Tip k y'
//                   Nothing -> Nil
//      Nothing -> t1
//
//differenceWithKey f Nil t       = Nil
//differenceWithKey f t (Tip k y) = updateWithKey (\k x -> f k x y) k t
//differenceWithKey f t Nil       = t

/**
 * Returns the difference of two maps, with a combining function. When two equal keys are
 * encountered, the combining function is applied to the key and both values.
 * If it returns {@link Nothing@}, the element is discarded (proper set difference). If
 * it returns {@code {@link Just@} y@}, the element is updated with a new value {@code y@}. 
 * 
 * Complexity: O(n+m)
 * 
 * @arg f the combining function.
 * @arg t1 the first map.
 * @arg t2 the second map.
 * @return the difference of the two maps.
 */
differenceWithKey :: (Int -> a -> b -> Maybe a) -> IntMap a -> IntMap b -> IntMap a;
public differenceWithKey f !t1 !t2 =
    case t1 of
    Tip k x ->
        case lookup k t2 of
        Just y -> 
            case f k x y of
            Just yNew -> Tip k yNew;
            Nothing -> Nil;
            ;
        Nothing -> t1;
        ;
    Nil -> Nil;
    Bin p1 m1 l1 r1 ->
        case t2 of
        Tip k y -> updateWithKey (\k x -> f k x y) k t1;
        Nil -> t1;
        Bin p2 m2 l2 r2 ->
            let
                difference1 =
                    if (nomatch p2 p1 m1) then
                        t1
                    else if (zero p2 m1) then
                        bin p1 m1 (differenceWithKey f l1 t2) r1
                    else
                        bin p1 m1 l1 (differenceWithKey f r1 t2);
                difference2 =
                    if (nomatch p1 p2 m2) then
                        t1
                    else if (zero p1 m2) then
                        differenceWithKey f t1 l2
                    else
                        differenceWithKey f t1 r2;
            in
                if (shorter m1 m2) then
                    difference1
                else if (shorter m1 m2) then
                    difference2
                else if (p1==p2) then
                    bin p1 m1 (differenceWithKey f l1 l2) (differenceWithKey f r1 r2)
                else
                    t1;
        ;
    ;

//
//
//{--------------------------------------------------------------------
//  Intersection
//--------------------------------------------------------------------}
//-- | /O(n+m)/. The (left-biased) intersection of two maps (based on keys). 
//intersection :: IntMap a -> IntMap a -> IntMap a
//intersection t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
//  | shorter m1 m2  = intersection1
//  | shorter m2 m1  = intersection2
//  | p1 == p2       = bin p1 m1 (intersection l1 l2) (intersection r1 r2)
//  | otherwise      = Nil
//  where
//    intersection1 | nomatch p2 p1 m1  = Nil
//                  | zero p2 m1        = intersection l1 t2
//                  | otherwise         = intersection r1 t2
//
//    intersection2 | nomatch p1 p2 m2  = Nil
//                  | zero p1 m2        = intersection t1 l2
//                  | otherwise         = intersection t1 r2
//
//intersection t1@(Tip k x) t2 
//  | member k t2  = t1
//  | otherwise    = Nil
//intersection t (Tip k x) 
//  = case lookup k t of
//      Just y  -> Tip k y
//      Nothing -> Nil
//intersection Nil t = Nil
//intersection t Nil = Nil
    
/**
 * Returns the (left-biased) intersection of two maps (based on keys). The values in the first map are returned.
 * 
 * Complexity: O(n+m)
 * 
 * @arg t1 the first map.
 * @arg t2 the second map.
 * @return the intersection of the two maps.
 */
intersection :: IntMap a -> IntMap b -> IntMap a;
public intersection !t1 !t2 =
    case t1 of
    Tip k x ->
        if (member k t2) then
            t1
        else
            Nil;
    Nil -> Nil;
    Bin p1 m1 l1 r1 ->
        case t2 of
        Tip k x ->
            case lookup k t1 of
            Just y -> Tip k y;
            Nothing -> Nil;
            ;
        Nil -> Nil;
        Bin p2 m2 l2 r2 ->
            let 
                intersection1 =
                    if (nomatch p2 p1 m1) then
                        Nil
                    else if (zero p2 m1) then
                        intersection l1 t2
                    else
                        intersection r1 t2;
                intersection2 =
                    if (nomatch p1 p2 m2) then
                        Nil
                    else if (zero p1 m2) then
                        intersection t1 l2
                    else
                        intersection t1 r2;
            in
                if (shorter m1 m2) then
                    intersection1
                else if (shorter m2 m1) then
                    intersection2
                else if (p1==p2) then
                    bin p1 m1 (intersection l1 l2) (intersection r1 r2)
                else
                    Nil;
        ;
    ;              
            
    
//
//-- | /O(n+m)/. The intersection with a combining function. 
//intersectionWith :: (a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
//intersectionWith f m1 m2
//  = intersectionWithKey (\k x y -> f x y) m1 m2
    
/**
 * Returns the intersection of two maps, with a combining function.
 * 
 * Complexity: O(n+m)
 * 
 * @arg f the combining function.
 * @arg m1 the first map.
 * @arg m2 the second map.
 * @return the intersection of the two maps.
 */
intersectionWith :: (a -> b -> c) -> IntMap a -> IntMap b -> IntMap c;
public intersectionWith f !m1 !m2 = intersectionWithKey (\k x y -> f x y) m1 m2;
    
//
//-- | /O(n+m)/. The intersection with a combining function. 
//intersectionWithKey :: (Key -> a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
//intersectionWithKey f t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
//  | shorter m1 m2  = intersection1
//  | shorter m2 m1  = intersection2
//  | p1 == p2       = bin p1 m1 (intersectionWithKey f l1 l2) (intersectionWithKey f r1 r2)
//  | otherwise      = Nil
//  where
//    intersection1 | nomatch p2 p1 m1  = Nil
//                  | zero p2 m1        = intersectionWithKey f l1 t2
//                  | otherwise         = intersectionWithKey f r1 t2
//
//    intersection2 | nomatch p1 p2 m2  = Nil
//                  | zero p1 m2        = intersectionWithKey f t1 l2
//                  | otherwise         = intersectionWithKey f t1 r2
//
//intersectionWithKey f t1@(Tip k x) t2 
//  = case lookup k t2 of
//      Just y  -> Tip k (f k x y)
//      Nothing -> Nil
//intersectionWithKey f t1 (Tip k y) 
//  = case lookup k t1 of
//      Just x  -> Tip k (f k x y)
//      Nothing -> Nil
//intersectionWithKey f Nil t = Nil
//intersectionWithKey f t Nil = Nil

/**
 * Returns the intersection of two maps, with a combining function.
 * 
 * Complexity: O(n+m)
 * 
 * @arg f the combining function.
 * @arg t1 the first map.
 * @arg t2 the second map.
 * @return the intersection of the two maps.
 */
intersectionWithKey :: (Int -> a -> b -> c) -> IntMap a -> IntMap b -> IntMap c;
public intersectionWithKey f !t1 !t2 =
    case t1 of
    Tip k x ->
        case lookup k t2 of
        Just y -> Tip k (f k x y);
        Nothing -> Nil;
        ;
    Nil -> Nil;
    Bin p1 m1 l1 r1 ->
        case t2 of
        Tip k y ->
            case lookup k t1 of
            Just x -> Tip k (f k x y);
            Nothing -> Nil;
            ;
        Nil -> Nil;
        Bin p2 m2 l2 r2 ->
            let
                intersection1 =
                    if (nomatch p2 p1 m1) then
                        Nil
                    else if (zero p2 m1) then
                        intersectionWithKey f l1 t2
                    else
                        intersectionWithKey f r1 t2;
                intersection2 =
                    if (nomatch p1 p2 m2) then
                        Nil
                    else if (zero p1 m2) then
                        intersectionWithKey f t1 l2
                    else
                        intersectionWithKey f t1 r2;
            in
                if (shorter m1 m2) then
                    intersection1
                else if (shorter m2 m1) then
                    intersection2
                else if (p1==p2) then
                    bin p2 m1 (intersectionWithKey f l1 l2) (intersectionWithKey f r1 r2)
                else
                    Nil;
        ;
    ;

//
//
//{--------------------------------------------------------------------
//  Subset
//--------------------------------------------------------------------}
//-- | /O(n+m)/. Is this a proper subset? (ie. a subset but not equal). 
//-- Defined as (@properSubset = properSubsetBy (==)@).
//properSubset :: Eq a => IntMap a -> IntMap a -> Bool
//properSubset m1 m2
//  = properSubsetBy (==) m1 m2
    
/**
 * Returns whether the first map is a proper submap of the second map (ie. a submap but not equal).
 * 
 * Complexity: O(n+m)
 * 
 * @arg m1 the first map.
 * @arg m2 the second map.
 * @return {@link True@} if the first map is a proper submap of the second map; {@link False@} otherwise.
 * @see isProperSubmapBy
 */
isProperSubmap :: Eq a => IntMap a -> IntMap a -> Boolean;
public isProperSubmap !m1 !m2 = isProperSubmapBy equals m1 m2;

//
//{- | /O(n+m)/. Is this a proper subset? (ie. a subset but not equal).
// The expression (@properSubsetBy f m1 m2@) returns @True@ when
// @m1@ and @m2@ are not equal,
// all keys in @m1@ are in @m2@, and when @f@ returns @True@ when
// applied to their respective values. For example, the following 
// expressions are all @True@.
// 
//  > properSubsetBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
//  > properSubsetBy (<=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
//
// But the following are all @False@:
// 
//  > properSubsetBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
//  > properSubsetBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
//  > properSubsetBy (<)  (fromList [(1,1)])       (fromList [(1,1),(2,2)])
//-}
//properSubsetBy :: (a -> a -> Bool) -> IntMap a -> IntMap a -> Bool
//properSubsetBy pred t1 t2
//  = case subsetCmp pred t1 t2 of 
//      LT -> True
//      ge -> False

/**
 * Returns whether the first map is a proper submap of the second map (ie. a submap but not equal).
 * 
 * Complexity: O(n+m)
 * 
 * The expression {@code isProperSubmapBy f m1 m2@} returns {@link True@} when {@code m1@} and {@code m2@}
 * are not equal, all keys in {@code m1@} are in {@code m2@}, and when {@code f@} returns {@link True@} when applied
 * to their respective values.
 * 
 * For example, the following expressions are all {@link True@}:
 * {@code
 * isProperSubmapBy {@link equals@}         ({@link fromList@} [(1,1)]) ({@link fromList@} [(1,1),(2,2)])
 * isProperSubmapBy {@link lessThanEquals@} ({@link fromList@} [(1,1)]) ({@link fromList@} [(1,1),(2,2)])
 * @}
 * 
 * But the following are all {@link False@}:
 * {@code
 * isProperSubmapBy {@link equals@}   ({@link fromList@} [(1,1),(2,2)]) ({@link fromList@} [(1,1),(2,2)])
 * isProperSubmapBy {@link equals@}   ({@link fromList@} [(1,1),(2,2)]) ({@link fromList@} [(1,1)])
 * isProperSubmapBy {@link lessThan@} ({@link fromList@} [(1,1)])       ({@link fromList@} [(1,1),(2,2)])
 * @}
 * 
 * @arg pred a predicate for testing the equality of map values.
 * @arg t1 the first map.
 * @arg t2 the second map.
 * @return {@link True@} if the first map is a submap of the second map; {@link False@} otherwise.
 */
isProperSubmapBy :: (a -> b -> Boolean) -> IntMap a -> IntMap b -> Boolean;
public isProperSubmapBy pred !t1 !t2 = 
    case submapCmp pred t1 t2 of
        LT -> True;
        _ -> False;
    ;

//
//subsetCmp pred t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
//  | shorter m1 m2  = GT
//  | shorter m2 m1  = subsetCmpLt
//  | p1 == p2       = subsetCmpEq
//  | otherwise      = GT  -- disjoint
//  where
//    subsetCmpLt | nomatch p1 p2 m2  = GT
//                | zero p1 m2        = subsetCmp pred t1 l2
//                | otherwise         = subsetCmp pred t1 r2
//    subsetCmpEq = case (subsetCmp pred l1 l2, subsetCmp pred r1 r2) of
//                    (GT,_ ) -> GT
//                    (_ ,GT) -> GT
//                    (EQ,EQ) -> EQ
//                    other   -> LT
//
//subsetCmp pred (Bin p m l r) t  = GT
//subsetCmp pred (Tip kx x) (Tip ky y)  
//  | (kx == ky) && pred x y = EQ
//  | otherwise              = GT  -- disjoint
//subsetCmp pred (Tip k x) t      
//  = case lookup k t of
//     Just y  | pred x y -> LT
//     other   -> GT -- disjoint
//subsetCmp pred Nil Nil = EQ
//subsetCmp pred Nil t   = LT

submapCmp :: (a -> b -> Boolean) -> IntMap a -> IntMap b -> Ordering;
private submapCmp pred !t1 !t2 =
    case t1 of
    Bin p1 m1 l1 r1 -> 
        case t2 of
        Bin p2 m2 l2 r2 ->
            let 
                submapCmpLt :: Ordering;
                submapCmpLt = 
                    if (nomatch p1 p2 m2) then
                        GT
                    else if (zero p1 m2) then
                        submapCmp pred t1 l2
                    else
                        submapCmp pred t1 r2;
                
                submapCmpEq :: Ordering;
                submapCmpEq =
                    case submapCmp pred l1 l2 of
                    GT -> GT;
                    EQ -> submapCmp pred r1 r2;
                    _ -> 
                        case submapCmp pred l1 l2 of
                        GT -> GT;
                        _ -> LT;
                        ;
                    ;
            in
                if (shorter m1 m2) then 
                    GT
                else if (shorter m2 m1) then
                    submapCmpLt
                else if (p1 == p2) then
                    submapCmpLt
                else
                    GT;
        ;
    ;                    
                    

//
//-- | /O(n+m)/. Is this a subset? Defined as (@subset = subsetBy (==)@).
//subset :: Eq a => IntMap a -> IntMap a -> Bool
//subset m1 m2
//  = subsetBy (==) m1 m2
    
/**
 * Returns whether the first map is a submap of the second map.
 * 
 * Complexity: O(n+m)
 * 
 * @arg m1 the first map.
 * @arg m2 the second map.
 * @return {@link True@} if the first map is a submap of the second map; {@link False@} otherwise.
 * @see isSubmapBy
 */
isSubmap :: Eq a => IntMap a -> IntMap a -> Boolean;
public isSubmap !m1 !m2 = isSubmapBy equals m1 m2;

//
//{- | /O(n+m)/. 
// The expression (@subsetBy f m1 m2@) returns @True@ if
// all keys in @m1@ are in @m2@, and when @f@ returns @True@ when
// applied to their respective values. For example, the following 
// expressions are all @True@.
// 
//  > subsetBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
//  > subsetBy (<=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
//  > subsetBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])
//
// But the following are all @False@:
// 
//  > subsetBy (==) (fromList [(1,2)]) (fromList [(1,1),(2,2)])
//  > subsetBy (<) (fromList [(1,1)]) (fromList [(1,1),(2,2)])
//  > subsetBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])
//-}
//
//subsetBy :: (a -> a -> Bool) -> IntMap a -> IntMap a -> Bool
//subsetBy pred t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)
//  | shorter m1 m2  = False
//  | shorter m2 m1  = match p1 p2 m2 && (if zero p1 m2 then subsetBy pred t1 l2
//                                                      else subsetBy pred t1 r2)                     
//  | otherwise      = (p1==p2) && subsetBy pred l1 l2 && subsetBy pred r1 r2
//subsetBy pred (Bin p m l r) t  = False
//subsetBy pred (Tip k x) t      = case lookup k t of
//                                   Just y  -> pred x y
//                                   Nothing -> False 
//subsetBy pred Nil t            = True

/**
 * Returns whether the first map is a submap of the second map.
 * 
 * Complexity: O(n+m)
 * 
 * The expression {@code isSubmapBy f t1 t2@} returns {@link True@} if all keys in {@code t1@} are in
 * tree {@code t2@}, and when {@code f@} returns {@link True@} when applied to their respective values.
 * 
 * For example, the following expressions are all {@link True@}:
 * {@code
 * isSubmapBy {@link equals@}         ({@link fromList@} [(1,1)]) ({@link fromList@} [(1,1),(2,2)])
 * isSubmapBy {@link lessThanEquals@} ({@link fromList@} [(1,1)]) ({@link fromList@} [(1,1),(2,2)])
 * isSubmapBy {@link equals@}         ({@link fromList@} [(1,1),(2,2)]) ({@link fromList@} [(1,1),(2,2)])
 * @}
 * 
 * But the following are all {@link False@}:
 * {@code
 * isSubmapBy {@link equals@}   ({@link fromList@} [(1,2)]) ({@link fromList@} [(1,1),(2,2)])
 * isSubmapBy {@link lessThan@} ({@link fromList@} [(1,1)]) ({@link fromList@} [(1,1),(2,2)])
 * isSubmapBy {@link equals@}   ({@link fromList@} [(1,1),(2,2)]) ({@link fromList@} [(1,1)])
 * @}
 *
 * @arg pred a predicate for testing the equality of map values.
 * @arg t1 the first map.
 * @arg t2 the second map.
 * @return {@link True@} if the first map is a submap of the second map; {@link False@} otherwise.
 */
isSubmapBy :: (a -> b -> Boolean) -> IntMap a -> IntMap b -> Boolean;
public isSubmapBy pred !t1 !t2 =
    case t1 of
    Bin p1 m1 l1 r1 -> 
        case t2 of 
        Bin p2 m2 l2 r2 ->
            if (shorter m1 m2) then
                False
            else if (shorter m2 m1) then
                (match p1 p2 m2) &&
                (if zero p1 m2 then
                    isSubmapBy pred t1 l2
                 else
                    isSubmapBy pred t1 r2)
            else
                (p1==p2) && (isSubmapBy pred l1 l2) && (isSubmapBy pred r1 r2);
        _ -> False;
        ;
    Tip k x ->
        case lookup k t2 of
        Just y -> pred x y;
        Nothing -> False;
        ;
    Nil -> True;
    ;
    
//
//{--------------------------------------------------------------------
//  Mapping
//--------------------------------------------------------------------}
//-- | /O(n)/. Map a function over all values in the map.
//map :: (a -> b) -> IntMap a -> IntMap b
//map f m
//  = mapWithKey (\k x -> f x) m
    
/**
 * Maps a function over all values in the map.
 * 
 * Complexity: O(n)
 * 
 * @arg f the function to be mapped over the values in the map.
 * @arg m the map.
 * @return the map containing the mapped values.
 */
map :: (a -> b) -> IntMap a -> IntMap b;
public map f !m = mapWithKey (\k x -> f x) m;
    
//
//-- | /O(n)/. Map a function over all values in the map.
//mapWithKey :: (Key -> a -> b) -> IntMap a -> IntMap b
//mapWithKey f t  
//  = case t of
//      Bin p m l r -> Bin p m (mapWithKey f l) (mapWithKey f r)
//      Tip k x     -> Tip k (f k x)
//      Nil         -> Nil

/**
 * Maps a function over all values in the map.
 * 
 * Complexity: O(n)
 * 
 * @arg f the function to be mapped over the keys and values in the map.
 * @arg t the map.
 * @return the map containing the mapped values.
 */
mapWithKey :: (Int -> a -> b) -> IntMap a -> IntMap b;
public mapWithKey f !t =
    case t of
    Bin p m l r -> Bin p m (mapWithKey f l) (mapWithKey f r);
    Tip k x -> Tip k (f k x);
    Nil -> Nil;
    ;

//
//-- | /O(n)/. The function @mapAccum@ threads an accumulating
//-- argument through the map in an unspecified order.
//mapAccum :: (a -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c)
//mapAccum f a m
//  = mapAccumWithKey (\a k x -> f a x) a m
    
/**
 * Threads an accumulating argument through the map in an unspecified order.
 * 
 * Complexity: O(n)
 * 
 * @arg f the function to be mapped over the values in the map.
 * @arg a the accumulator to be thread through the map.
 * @arg m the map.
 * @return the map containing the mapped values.
 */
mapAccum :: (a -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c);
public mapAccum f a !m = mapAccumWithKey (\a k x -> f a x) a m;

//
//-- | /O(n)/. The function @mapAccumWithKey@ threads an accumulating
//-- argument through the map in an unspecified order.
//mapAccumWithKey :: (a -> Key -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c)
//mapAccumWithKey f a t
//  = mapAccumL f a t

/**
 * Threads an accumulating argument through the map in an unspecified order.
 * 
 * Complexity: O(n)
 * 
 * @arg f the function to be mapped over the keys and values in the map.
 * @arg a the accumulator to be thread through the map.
 * @arg t the map.
 * @return the map containing the mapped values.
 */
mapAccumWithKey :: (a -> Int -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c);
public mapAccumWithKey f a !t = mapAccumL f a t;

//
//-- | /O(n)/. The function @mapAccumL@ threads an accumulating
//-- argument through the map in pre-order.
//mapAccumL :: (a -> Key -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c)
//mapAccumL f a t
//  = case t of
//      Bin p m l r -> let (a1,l') = mapAccumL f a l
//                         (a2,r') = mapAccumL f a1 r
//                     in (a2,Bin p m l' r')
//      Tip k x     -> let (a',x') = f a k x in (a',Tip k x')
//      Nil         -> (a,Nil)

mapAccumL :: (a -> Int -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c);
private mapAccumL f a !t =
    case t of
    Bin {prefix, mask, leftMap, rightMap} ->
        let 
            (a1, lNew) = mapAccumL f a leftMap;
            (a2, rNew) = mapAccumL f a1 rightMap;
        in
            (a2, Bin prefix mask lNew rNew);
    Tip {key, value} ->
        let
            (aNew, xNew) = f a key value;
        in
            (aNew, Tip key xNew);
    Nil -> (a, Nil);
    ;

//
//
//-- | /O(n)/. The function @mapAccumR@ threads an accumulating
//-- argument throught the map in post-order.
//mapAccumR :: (a -> Key -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c)
//mapAccumR f a t
//  = case t of
//      Bin p m l r -> let (a1,r') = mapAccumR f a r
//                         (a2,l') = mapAccumR f a1 l
//                     in (a2,Bin p m l' r')
//      Tip k x     -> let (a',x') = f a k x in (a',Tip k x')
//      Nil         -> (a,Nil)
    
mapAccumR :: (a -> Int -> b -> (a,c)) -> a -> IntMap b -> (a,IntMap c);
private mapAccumR f a !t =
    case t of 
    Bin {prefix, mask, leftMap, rightMap} ->
        let 
            (a1, rNew) = mapAccumR f a rightMap;
            (a2, lNew) = mapAccumR f a1 leftMap;
        in
            (a2,Bin prefix mask lNew rNew);
    Tip {key, value} ->
        let
            (aNew, xNew) = f a key value;
        in
            (aNew, Tip key xNew);
    Nil -> (a, Nil);
    ;
    
/**
 * {@code mapKeys f s@} is the map obtained by applying {@code f@} to each key of {@code s@}.
 * 
 * Complexity: O(n*min(n,W))
 * 
 * The size of the result may be smaller if {@code f@} maps two or more distinct keys to
 * the same new key. In this case the value at the smallest of these keys is
 * retained.
 * 
 * @arg f the function to be mapped over the keys in the map.
 * @arg s the map.
 * @return the map containing the mapped keys.
 */
mapKeys :: (Int -> Int) -> IntMap a -> IntMap a;
public mapKeys = mapKeysWith const;

/**
 * {@code mapKeysWith c f s@} is the map obtained by applying {@code f@} to each key of {@code s@}.
 * 
 * Complexity: O(n*min(n,W))
 * 
 * The size of the result may be smaller if {@code f@} maps two or more distinct keys to
 * the same new key. In this case the associated values will be combined using
 * {@code c@}.
 * 
 * @arg c the combining function.
 * @arg f the function to be mapped over the keys in the map.
 * @arg m the map.
 * @return the map containing the mapped keys.
 */
mapKeysWith :: (a -> a -> a) -> (Int -> Int) -> IntMap a -> IntMap a;
public mapKeysWith c f m = fromListWith c (List.map (\x -> (f (fst x), snd x)) (toList m));
        
//
//{--------------------------------------------------------------------
//  Filter
//--------------------------------------------------------------------}
//-- | /O(n)/. Filter all values that satisfy some predicate.
//filter :: (a -> Bool) -> IntMap a -> IntMap a
//filter p m
//  = filterWithKey (\k x -> p x) m
    
/**
 * Filters all values that satisfy the predicate.
 * 
 * Complexity: O(n)
 * 
 * @arg p the predicate for testing the values.
 * @arg m the map.
 * @return the map containing only those key-value pairs whose values satisfy the predicate.
 */
filter :: (a -> Boolean) -> IntMap a -> IntMap a;
public filter p !m = filterWithKey (\k x -> p x) m;
    
//
//-- | /O(n)/. Filter all keys\/values that satisfy some predicate.
//filterWithKey :: (Key -> a -> Bool) -> IntMap a -> IntMap a
//filterWithKey pred t
//  = case t of
//      Bin p m l r 
//        -> bin p m (filterWithKey pred l) (filterWithKey pred r)
//      Tip k x 
//        | pred k x  -> t
//        | otherwise -> Nil
//      Nil -> Nil

/**
 * Filters all keys/values that satisfy the predicate.
 * 
 * Complexity: O(n)
 * 
 * @arg pred the predicate for testing the keys and values.
 * @arg t the map.
 * @return the map containing only those key-value pairs that satisfy the predicate.
 */
filterWithKey :: (Int -> a -> Boolean) -> IntMap a -> IntMap a;
public filterWithKey pred !t =
    case t of
    Bin {prefix, mask, leftMap, rightMap} -> bin prefix mask (filterWithKey pred leftMap) (filterWithKey pred rightMap);
    Tip {key, value} ->
        if (pred key value) then
            t
        else
            Nil;
    Nil -> Nil;
    ;

//
//-- | /O(n)/. partition the map according to some predicate. The first
//-- map contains all elements that satisfy the predicate, the second all
//-- elements that fail the predicate. See also 'split'.
//partition :: (a -> Bool) -> IntMap a -> (IntMap a,IntMap a)
//partition p m
//  = partitionWithKey (\k x -> p x) m
    
/**
 * Partitions the map according to a predicate. The first map contains all
 * elements that satisfy the predicate, the second all elements that fail the
 * predicate.
 * 
 * Complexity: O(n)
 * 
 * @arg p the predicate for testing the values.
 * @arg m the map.
 * @return a pair of maps. The first map contains all elements that satisfy the
 *         predicate, the second all elements that fail the predicate.
 * 
 * @see split
 */
partition :: (a -> Boolean) -> IntMap a -> (IntMap a,IntMap a);
public partition p !m = partitionWithKey (\k x -> p x) m;
    
//
//-- | /O(n)/. partition the map according to some predicate. The first
//-- map contains all elements that satisfy the predicate, the second all
//-- elements that fail the predicate. See also 'split'.
//partitionWithKey :: (Key -> a -> Bool) -> IntMap a -> (IntMap a,IntMap a)
//partitionWithKey pred t
//  = case t of
//      Bin p m l r 
//        -> let (l1,l2) = partitionWithKey pred l
//               (r1,r2) = partitionWithKey pred r
//           in (bin p m l1 r1, bin p m l2 r2)
//      Tip k x 
//        | pred k x  -> (t,Nil)
//        | otherwise -> (Nil,t)
//      Nil -> (Nil,Nil)

/**
 * Partitions the map according to a predicate. The first map contains all
 * elements that satisfy the predicate, the second all elements that fail the
 * predicate.
 * 
 * Complexity: O(n)
 * 
 * @arg pred the predicate for testing the keys and values.
 * @arg t the map.
 * @return a pair of maps. The first map contains all elements that satisfy the
 *         predicate, the second all elements that fail the predicate.
 * 
 * @see split
 */
partitionWithKey :: (Int -> a -> Boolean) -> IntMap a -> (IntMap a,IntMap a);
public partitionWithKey pred !t =
    case t of
    Bin {prefix, mask, leftMap, rightMap} ->
        let 
            (l1, l2) = partitionWithKey pred leftMap;
            (r1, r2) = partitionWithKey pred rightMap;
        in
            (bin prefix mask l1 r1, bin prefix mask l2 r2);
    Tip {key, value} ->
        if (pred key value) then
            (t, Nil)
        else
            (Nil, t);
    Nil -> (Nil,Nil);
    ;

//
//
//-- | /O(log n)/. The expression (@split k map@) is a pair @(map1,map2)@
//-- where all keys in @map1@ are lower than @k@ and all keys in
//-- @map2@ larger than @k@.
//-- Any key equal to @k@ is found in neither @map1@ nor @map2@.
//split :: Key -> IntMap a -> (IntMap a,IntMap a)
//split k t
//  = case t of
//      Bin p m l r
//        | zero k m  -> let (lt,gt) = split k l in (lt,union gt r)
//        | otherwise -> let (lt,gt) = split k r in (union l lt,gt)
//      Tip ky y 
//        | k>ky      -> (t,Nil)
//        | k<ky      -> (Nil,t)
//        | otherwise -> (Nil,Nil)
//      Nil -> (Nil,Nil)
    
/**
 * {@code split k map@} returns a pair {@code (map1,map2)@} where the keys in {@code map1@} are smaller
 * than {@code k@} and the keys in {@code map2@} larger than {@code k@}. Any key equal to {@code k@} is found in
 * neither {@code map1@} nor {@code map2@}.
 * 
 * Complexity: O(log n)
 * 
 * @arg k the key.
 * @arg t the map.
 * @return a pair {@code (map1,map2)@} where the keys in {@code map1@} are smaller than {@code k@} and the
 *         keys in {@code map2@} larger than {@code k@}.
 */
split :: Int -> IntMap a -> (IntMap a,IntMap a);
public split k !t =
    case t of
    Bin {mask, leftMap, rightMap} ->
        if (zero k mask) then
            let 
                (lt, gt) = split k leftMap;
            in 
                (lt,union gt rightMap)
        else
            let
                (lt, gt) = split k rightMap;
            in
                (union leftMap lt,gt);
    Tip {key} ->
        if (k>key) then
            (t,Nil)
        else if (k<key) then
            (Nil,t)
        else
            (Nil,Nil);
    Nil -> (Nil, Nil);
    ;
    
//
//-- | /O(log n)/. Performs a 'split' but also returns whether the pivot
//-- key was found in the original map.
//splitLookup :: Key -> IntMap a -> (Maybe a,IntMap a,IntMap a)
//splitLookup k t
//  = case t of
//      Bin p m l r
//        | zero k m  -> let (found,lt,gt) = splitLookup k l in (found,lt,union gt r)
//        | otherwise -> let (found,lt,gt) = splitLookup k r in (found,union l lt,gt)
//      Tip ky y 
//        | k>ky      -> (Nothing,t,Nil)
//        | k<ky      -> (Nothing,Nil,t)
//        | otherwise -> (Just y,Nil,Nil)
//      Nil -> (Nothing,Nil,Nil)
    
/**
 * {@code splitLookup key map@} splits a map just like {@link split@} but also returns {@code {@link lookup@} key map@}.
 * 
 * Complexity: O(log n)
 * 
 * @arg key
 * @arg map
 * @return a triple {@code (lookupResult, map1, map2)@} where the keys in {@code map1@} are smaller than {@code key@} and the
 *         keys in {@code map2@} larger than {@code key@}, and where {@code lookupResult@} is the result of looking
 *         up the key in the map.
 * @see split, lookup
 */
splitLookup :: Int -> IntMap a -> (Maybe a, IntMap a, IntMap a);
public splitLookup key !map =
    case map of
    Bin {mask, leftMap, rightMap} ->
        if zero key mask then
            let 
                (found, lt, gt) = splitLookup key leftMap;
            in
                (found, lt, union gt rightMap)
        else
            let
                (found, lt, gt) = splitLookup key rightMap;
            in
                (found, union leftMap lt, gt);
    Tip {key = k, value} ->
        if key > k then
            (Nothing, map, Nil)
        else if key < k then
            (Nothing, Nil, map)
        else
            (Just value, Nil, Nil);
    Nil -> (Nothing, Nil, Nil);
    ;
    
//
//{--------------------------------------------------------------------
//  Fold
//--------------------------------------------------------------------}
//-- | /O(n)/. Fold over the elements of a map in an unspecified order.
//--
//-- > sum map   = fold (+) 0 map
//-- > elems map = fold (:) [] map
//fold :: (a -> b -> b) -> b -> IntMap a -> b
//fold f z t
//  = foldWithKey (\k x y -> f x y) z t
    
/**
 * Folds over the values in the map in an unspecified order.
 * 
 * Complexity: O(n)
 * 
 * @arg f the function to be folded over the values in the map.
 * @arg z 
 * @arg t the map.
 * @return the summary value obtained from the fold.
 */
fold :: (a -> b -> b) -> b -> IntMap a -> b;
public fold f z !t = foldWithKey (\k x y -> f x y) z t;
    
//
//-- | /O(n)/. Fold over the elements of a map in an unspecified order.
//--
//-- > keys map = foldWithKey (\k x ks -> k:ks) [] map
//foldWithKey :: (Key -> a -> b -> b) -> b -> IntMap a -> b
//foldWithKey f z t
//  = foldR f z t

/**
 * Folds over the keys and values in the map in an unspecified order.
 * 
 * Complexity: O(n)
 * 
 * @arg f the function to be folded over the keys and values in the map.
 * @arg z 
 * @arg t the map.
 * @return the summary value obtained from the fold.
 */
foldWithKey :: (Int -> a -> b -> b) -> b -> IntMap a -> b;
public foldWithKey f z !t = foldR f z t;

//
//foldR :: (Key -> a -> b -> b) -> b -> IntMap a -> b
//foldR f z t
//  = case t of
//      Bin p m l r -> foldR f (foldR f z r) l
//      Tip k x     -> f k x z
//      Nil         -> z

foldR :: (Int -> a -> b -> b) -> b -> IntMap a -> b;
private foldR f z !t =
    case t of
    Bin {leftMap, rightMap} -> foldR f (foldR f z rightMap) leftMap;
    Tip {key, value} -> f key value z;
    Nil -> z;
    ;

//
//{--------------------------------------------------------------------
//  List variations 
//--------------------------------------------------------------------}
//-- | /O(n)/. Return all elements of the map.
//elems :: IntMap a -> [a]
//elems m
//  = foldWithKey (\k x xs -> x:xs) [] m
    
/**
 * Returns all elements of the map.
 * 
 * Complexity: O(n)
 * 
 * @arg m the map.
 * @return a list of all elements of the map.
 */
elems :: IntMap a -> [a];
public elems !m = foldWithKey (\k x xs -> x:xs) [] m;                      
    
//
//-- | /O(n)/. Return all keys of the map.
//keys  :: IntMap a -> [Key]
//keys m
//  = foldWithKey (\k x ks -> k:ks) [] m

/**
 * Returns all keys of the map.
 * 
 * Complexity: O(n)
 * 
 * @arg m the map.
 * @return a list of all keys of the map.
 */
keys :: IntMap a -> [Int];
public keys !m = foldWithKey (\k x ks -> k:ks) [] m;

/**
 * Returns a set of all keys of the map.
 * 
 * Complexity: O(n)
 * 
 * @arg m the map.
 * @return a {@code Set@} of all keys of the map.
 * @see typeConstructor = Set.Set
 */
keySet :: IntMap a -> Set.Set Int;
public keySet m = Set.fromList (keys m);

//
//-- | /O(n)/. Return all key\/value pairs in the map.
//assocs :: IntMap a -> [(Key,a)]
//assocs m
//  = toList m

/**
 * Returns an association list of all key-value pairs in the map.
 * 
 * Complexity: O(n)
 * 
 * @arg m the map.
 * @return an association list of all key-value pairs in the map.
 */
assocs :: IntMap a -> [(Int,a)];
public assocs !m = toList m;

//
//
//{--------------------------------------------------------------------
//  Lists 
//--------------------------------------------------------------------}
//-- | /O(n)/. Convert the map to a list of key\/value pairs.
//toList :: IntMap a -> [(Key,a)]
//toList t
//  = foldWithKey (\k x xs -> (k,x):xs) [] t

/**
 * Converts to a list of key-value pairs with the keys.
 * 
 * Complexity: O(n)
 *
 * @arg t the map.
 * @return a list of key-value pairs with the keys in ascending order.
 */
toList :: IntMap a -> [(Int,a)];
public toList !t = foldWithKey (\k x xs -> (k,x):xs) [] t; 

//
//-- | /O(n)/. Convert the map to a list of key\/value pairs where the
//-- keys are in ascending order.
//toAscList :: IntMap a -> [(Key,a)]
//toAscList t   
//  = -- NOTE: the following algorithm only works for big-endian trees
//    let (pos,neg) = span (\(k,x) -> k >=0) (foldR (\k x xs -> (k,x):xs) [] t) in neg ++ pos

/**
 * Converts to a list of key-value pairs with the keys in ascending order.
 * 
 * Complexity: O(n)
 *
 * @arg t the map.
 * @return a list of key-value pairs with the keys in ascending order.
 */
toAscList :: IntMap a -> [(Int,a)];
public toAscList !t =
    let 
        (pos, neg) = span (\k -> (fst k)>=0) (foldR (\k x xs -> (k,x):xs) [] t);
    in
        neg ++ pos;

//
//-- | /O(n*min(n,W))/. Create a map from a list of key\/value pairs.
//fromList :: [(Key,a)] -> IntMap a
//fromList xs
//  = foldlStrict ins empty xs
//  where
//    ins t (k,x)  = insert k x t
    
/**
 * Builds a map from a list of key-value pairs.
 * 
 * Complexity: O(n*min(n,W))
 * 
 * @arg xs the list of key-value pairs.
 * @return a map containing the key-value entries.
 * @see fromAscList
 */
fromList :: [(Int,a)] -> IntMap a;
public fromList !xs =
    let
        ins :: IntMap a -> (Int, a) -> IntMap a;
        ins t !p =
            case p of
            (k, x) -> insert k x t;
            ;
    in
        foldLeftStrict ins empty xs;   
    
//
//-- | /O(n*min(n,W))/.  Create a map from a list of key\/value pairs with a combining function. See also 'fromAscListWith'.
//fromListWith :: (a -> a -> a) -> [(Key,a)] -> IntMap a 
//fromListWith f xs
//  = fromListWithKey (\k x y -> f x y) xs
    
/**
 * Builds a map from a list of key-value pairs with a combining function.
 * 
 * Complexity: O(n*min(n,W))
 * 
 * @arg f the combining function.
 * @arg xs the list of key-value pairs.
 * @return a map containing the key-value entries.
 * @see fromAscListWith
 */
fromListWith :: (a -> a -> a) -> [(Int,a)] -> IntMap a;
public fromListWith f !xs =
    fromListWithKey (\k x y -> f x y) xs;
    
//
//-- | /O(n*min(n,W))/.  Build a map from a list of key\/value pairs with a combining function. See also fromAscListWithKey'.
//fromListWithKey :: (Key -> a -> a -> a) -> [(Key,a)] -> IntMap a 
//fromListWithKey f xs 
//  = foldlStrict ins empty xs
//  where
//    ins t (k,x) = insertWithKey f k x t

/**
 * Builds a map from a list of key-value pairs with a combining function.
 * 
 * Complexity: O(n*min(n,W))
 * 
 * @arg f the combining function.
 * @arg xs the list of key-value pairs.
 * @return a map containing the key-value entries.
 * @see fromAscListWithKey
 */
fromListWithKey :: (Int -> a -> a -> a) -> [(Int,a)] -> IntMap a;
public fromListWithKey f !xs =
    let
        //ins :: IntMap a -> (Int, a) -> IntMap a;
        ins t !p =
            case p of
            (k, x) -> insertWithKey f k x t;
            ;
    in
        foldLeftStrict ins empty xs;     

//
//-- | /O(n*min(n,W))/. Build a map from a list of key\/value pairs where
//-- the keys are in ascending order.
//  -- /The precondition (input list is ascending) is not checked./
//fromAscList :: [(Key,a)] -> IntMap a
//fromAscList xs
//  = fromList xs
    
/**
 * Builds a map from an ascending list in linear time. The precondition (input
 * list is ascending) is not checked.
 * 
 * Complexity: O(n*min(n,W))
 * 
 * @arg xs an ascending list of key-value pairs.
 * @return a map containing the key-value entries.
 */
fromAscList :: [(Int,a)] -> IntMap a;
public fromAscList !xs = fromList xs;
    
//
//-- | /O(n*min(n,W))/. Build a map from a list of key\/value pairs where
//-- the keys are in ascending order, with a combining function on equal keys.
//-- /The precondition (input list is ascending) is not checked./
//fromAscListWith :: (a -> a -> a) -> [(Key,a)] -> IntMap a
//fromAscListWith f xs
//  = fromListWith f xs

/**
 * Builds a map from an ascending list in linear time with a combining function
 * for equal keys. The precondition (input list is ascending) is not checked.
 * 
 * Complexity: O(n*min(n,W))
 * 
 * @arg f the combining function.
 * @arg xs an ascending list of key-value pairs.
 * @return a map containing the key-value entries.
 */
fromAscListWith :: (a -> a -> a) -> [(Int,a)] -> IntMap a;
public fromAscListWith f !xs = fromListWith f xs;

//
//-- | /O(n*min(n,W))/. Build a map from a list of key\/value pairs where
//-- the keys are in ascending order, with a combining function on equal keys.
//-- /The precondition (input list is ascending) is not checked./
//fromAscListWithKey :: (Key -> a -> a -> a) -> [(Key,a)] -> IntMap a
//fromAscListWithKey f xs
//  = fromListWithKey f xs

/**
 * Builds a map from an ascending list in linear time with a combining function
 * for equal keys. The precondition (input list is ascending) is not checked.
 * 
 * Complexity: O(n*min(n,W))
 * 
 * @arg f the combining function.
 * @arg xs an ascending list of key-value pairs.
 * @return a map containing the key-value entries.
 */
fromAscListWithKey :: (Int -> a -> a -> a) -> [(Int,a)] -> IntMap a;
public fromAscListWithKey f !xs = fromListWithKey f xs;

//
//-- | /O(n*min(n,W))/. Build a map from a list of key\/value pairs where
//-- the keys are in ascending order and all distinct.
//-- /The precondition is not checked./
//fromDistinctAscList :: [(Key,a)] -> IntMap a
//fromDistinctAscList xs
//  = fromList xs

/**
 * Builds a map from an ascending list of distinct elements in linear time.
 * The precondition is not checked.
 * 
 * Complexity: O(n*min(n,W))
 * 
 * @arg xs an ascending list of distinct key-value pairs.
 * @return a map containing the key-value entries.
 */
fromDistinctAscList :: [(Int,a)] -> IntMap a;
public fromDistinctAscList !xs = fromList xs;

//
//
//{--------------------------------------------------------------------
//  Eq 
//--------------------------------------------------------------------}
//instance Eq a => Eq (IntMap a) where
//  t1 == t2  = equal t1 t2
//  t1 /= t2  = nequal t1 t2
//
//equal :: Eq a => IntMap a -> IntMap a -> Bool
//equal (Bin p1 m1 l1 r1) (Bin p2 m2 l2 r2)
//  = (m1 == m2) && (p1 == p2) && (equal l1 l2) && (equal r1 r2) 
//equal (Tip kx x) (Tip ky y)
//  = (kx == ky) && (x==y)
//equal Nil Nil = True
//equal t1 t2   = False
//
//nequal :: Eq a => IntMap a -> IntMap a -> Bool
//nequal (Bin p1 m1 l1 r1) (Bin p2 m2 l2 r2)
//  = (m1 /= m2) || (p1 /= p2) || (nequal l1 l2) || (nequal r1 r2) 
//nequal (Tip kx x) (Tip ky y)
//  = (kx /= ky) || (x/=y)
//nequal Nil Nil = False
//nequal t1 t2   = True

// We have chosen to use a derived Eq instance instead, since the performance is comparable.

instance Appendable (IntMap a) where
    empty = empty;
    isEmpty = isEmpty;
    append = union;
    concat = unions;
    ;

instance (Outputable a) => Outputable (IntMap a) where
    //a map is output as a list of (key, value) pairs sorted in ascending order by key.
    output = outputIntMap;
    ;

outputIntMap :: (Outputable a) => IntMap a -> JObject;
private outputIntMap m = output (toList m);

instance (Inputable a) => Inputable (IntMap a) where
    input = inputIntMap;
    ;
    
inputIntMap :: (Inputable a) => JObject -> IntMap a;
private inputIntMap list = fromList (input list);
        
//
//instance Show a => Show (IntMap a) where
//  showsPrec d t   = showMap (toList t)
//
//
//showMap :: (Show a) => [(Key,a)] -> ShowS
//showMap []     
//  = showString "{}" 
//showMap (x:xs) 
//  = showChar '{' . showElem x . showTail xs
//  where
//    showTail []     = showChar '}'
//    showTail (x:xs) = showChar ',' . showElem x . showTail xs
//    
//    showElem (k,x)  = shows k . showString ":=" . shows x
//  
//{--------------------------------------------------------------------
//  Debugging
//--------------------------------------------------------------------}
//-- | /O(n)/. Show the tree that implements the map. The tree is shown
//-- in a compressed, hanging format.
//showTree :: Show a => IntMap a -> String
//showTree s
//  = showTreeWith True False s
//
//
//{- | /O(n)/. The expression (@showTreeWith hang wide map@) shows
// the tree that implements the map. If @hang@ is
// @True@, a /hanging/ tree is shown otherwise a rotated tree is shown. If
// @wide@ is true, an extra wide version is shown.
//-}
//showTreeWith :: Show a => Bool -> Bool -> IntMap a -> String
//showTreeWith hang wide t
//  | hang      = (showsTreeHang wide [] t) ""
//  | otherwise = (showsTree wide [] [] t) ""
//
//showsTree :: Show a => Bool -> [String] -> [String] -> IntMap a -> ShowS
//showsTree wide lbars rbars t
//  = case t of
//      Bin p m l r
//          -> showsTree wide (withBar rbars) (withEmpty rbars) r .
//             showWide wide rbars .
//             showsBars lbars . showString (showBin p m) . showString "\n" .
//             showWide wide lbars .
//             showsTree wide (withEmpty lbars) (withBar lbars) l
//      Tip k x
//          -> showsBars lbars . showString " " . shows k . showString ":=" . shows x . showString "\n" 
//      Nil -> showsBars lbars . showString "|\n"
//
//showsTreeHang :: Show a => Bool -> [String] -> IntMap a -> ShowS
//showsTreeHang wide bars t
//  = case t of
//      Bin p m l r
//          -> showsBars bars . showString (showBin p m) . showString "\n" . 
//             showWide wide bars .
//             showsTreeHang wide (withBar bars) l .
//             showWide wide bars .
//             showsTreeHang wide (withEmpty bars) r
//      Tip k x
//          -> showsBars bars . showString " " . shows k . showString ":=" . shows x . showString "\n" 
//      Nil -> showsBars bars . showString "|\n"
//      
//showBin p m
//  = "*" -- ++ show (p,m)
//
//showWide wide bars 
//  | wide      = showString (concat (reverse bars)) . showString "|\n" 
//  | otherwise = id
//
//showsBars :: [String] -> ShowS
//showsBars bars
//  = case bars of
//      [] -> id
//      _  -> showString (concat (reverse (tail bars))) . showString node
//
//node           = "+--"
//withBar bars   = "|  ":bars
//withEmpty bars = "   ":bars
//
//
//{--------------------------------------------------------------------
//  Helpers
//--------------------------------------------------------------------}
//{--------------------------------------------------------------------
//  Join
//--------------------------------------------------------------------}
//join :: Prefix -> IntMap a -> Prefix -> IntMap a -> IntMap a
//join p1 t1 p2 t2
//  | zero p1 m = Bin p m t1 t2
//  | otherwise = Bin p m t2 t1
//  where
//    m = branchMask p1 p2
//    p = mask p1 m
                
join :: Int -> IntMap a -> Int -> IntMap a -> IntMap a;
private join !p1 t1 !p2 t2 =
    let 
        m :: Int;
        m = branchMask p1 p2;
        
        p :: Int;
        p = mask p1 m;
    in
        if (zero p1 m) then
            Bin p m t1 t2
        else
            Bin p m t2 t1;
            
//
//{--------------------------------------------------------------------
//  @bin@ assures that we never have empty trees within a tree.
//--------------------------------------------------------------------}
//bin :: Prefix -> Mask -> IntMap a -> IntMap a -> IntMap a
//bin p m l Nil = l
//bin p m Nil r = r
//bin p m l r   = Bin p m l r
    
bin :: Int -> Int -> IntMap a -> IntMap a -> IntMap a;
private bin p m !l !r =
    case r of
    Nil -> l;
    _ ->
        case l of
        Nil -> r;
        _ -> Bin p m l r;
        ;
    ;
    
//
//  
//{--------------------------------------------------------------------
//  Endian independent bit twiddling
//--------------------------------------------------------------------}
//zero :: Key -> Mask -> Bool
//zero i m
//  = (natFromInt i) .&. (natFromInt m) == 0
        
zero :: Int -> Int -> Boolean;
private zero !i !m =
    (bitwiseAnd i m) == 0;

//
//nomatch,match :: Key -> Prefix -> Mask -> Bool
//nomatch i p m
//  = (mask i m) /= p
//
//match i p m
//  = (mask i m) == p
nomatch :: Int -> Int -> Int -> Boolean;
private nomatch !i !p !m = (mask i m) != p;

match :: Int -> Int -> Int -> Boolean;
private match !i !p !m = (mask i m) == p;

//
//mask :: Key -> Mask -> Prefix
//mask i m
//  = maskW (natFromInt i) (natFromInt m)
//
//
//{--------------------------------------------------------------------
//  Big endian operations  
//--------------------------------------------------------------------}
//maskW :: Nat -> Nat -> Prefix
//maskW i m
//  = intFromNat (i .&. (complement (m-1) `xor` m))

mask :: Int -> Int -> Int;
private mask !i !m = (bitwiseAnd i (bitwiseXor (complement (m-1)) m));

//
//shorter :: Mask -> Mask -> Bool
//shorter m1 m2
//  = (natFromInt m1) > (natFromInt m2)
shorter :: Int -> Int -> Boolean;
private shorter !m1 !m2 = 
    if (m1 < 0 && m2 < 0) || (m1 >= 0 && m2 >= 0) then
        m1 > m2
    else
        m1 < m2;

//
//branchMask :: Prefix -> Prefix -> Mask
//branchMask p1 p2
//  = intFromNat (highestBitMask (natFromInt p1 `xor` natFromInt p2))

branchMask :: Int -> Int -> Int;
private branchMask !p1 !p2 =
    highestBitMask (bitwiseXor p1 p2);



instance Show a => Show (IntMap a) where
    show = showIntMap;
    ;

showIntMap :: Show a => IntMap a -> String;
showIntMap !m = 
    let
        showEntry !entry = 
            case entry of
            (key, val) -> show key ++ " = " ++ show val;
            ;
    in
        concat ["IntMap.IntMap{",
                List.join ", " (List.map showEntry $ toList m),
                "}"];

//  
//{----------------------------------------------------------------------
//  Finding the highest bit (mask) in a word [x] can be done efficiently in
//  three ways:
//  * convert to a floating point value and the mantissa tells us the 
//    [log2(x)] that corresponds with the highest bit position. The mantissa 
//    is retrieved either via the standard C function [frexp] or by some bit 
//    twiddling on IEEE compatible numbers (float). Note that one needs to 
//    use at least [double] precision for an accurate mantissa of 32 bit 
//    numbers.
//  * use bit twiddling, a logarithmic sequence of bitwise or's and shifts (bit).
//  * use processor specific assembler instruction (asm).
//
//  The most portable way would be [bit], but is it efficient enough?
//  I have measured the cycle counts of the different methods on an AMD 
//  Athlon-XP 1800 (~ Pentium III 1.8Ghz) using the RDTSC instruction:
//
//  highestBitMask: method  cycles
//                  --------------
//                   frexp   200
//                   float    33
//                   bit      11
//                   asm      12
//
//  highestBit:     method  cycles
//                  --------------
//                   frexp   195
//                   float    33
//                   bit      11
//                   asm      11
//
//  Wow, the bit twiddling is on today's RISC like machines even faster
//  than a single CISC instruction (BSR)!
//----------------------------------------------------------------------}
//
//{----------------------------------------------------------------------
//  [highestBitMask] returns a word where only the highest bit is set.
//  It is found by first setting all bits in lower positions than the 
//  highest bit and than taking an exclusive or with the original value.
//  Allthough the function may look expensive, GHC compiles this into
//  excellent C code that subsequently compiled into highly efficient
//  machine code. The algorithm is derived from Jorg Arndt's FXT library.
//----------------------------------------------------------------------}
//highestBitMask :: Nat -> Nat
//highestBitMask x
//  = case (x .|. shiftRL x 1) of 
//     x -> case (x .|. shiftRL x 2) of 
//      x -> case (x .|. shiftRL x 4) of 
//       x -> case (x .|. shiftRL x 8) of 
//        x -> case (x .|. shiftRL x 16) of 
//         x -> case (x .|. shiftRL x 32) of   -- for 64 bit platforms
//          x -> (x `xor` (shiftRL x 1))
//
//
//{--------------------------------------------------------------------
//  Utilities 
//--------------------------------------------------------------------}
//foldlStrict f z xs
//  = case xs of
//      []     -> z
//      (x:xx) -> let z' = f z x in seq z' (foldlStrict f z' xx)
//


/**
 * The {@link Arbitrary@} instance for the {@link typeConstructor = IntMap@} type. This creates IntMaps
 * using the fromList method.
 */
instance Arbitrary a => Arbitrary (IntMap a) where
    arbitrary = arbitraryIntMap;
    coarbitrary = coarbitraryIntMap;
    ;

arbitraryIntMap :: Arbitrary a => Gen (IntMap a);
arbitraryIntMap = 
    mapGen fromList arbitrary;
 
coarbitraryIntMap :: Arbitrary a => (IntMap a)-> Gen b -> Gen b;
coarbitraryIntMap map = 
        coarbitrary $ toList map; 


