-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Parjson where
import Absjson
import Lexjson
import ErrM
}

%name pJSONObject JSONObject
%name pJSONPair JSONPair
%name pJSONArray JSONArray
%name pJSONValue JSONValue
%name pListJSONPair ListJSONPair
%name pListJSONValue ListJSONValue

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '{' { PT _ (TS "{") }
 '}' { PT _ (TS "}") }
 ':' { PT _ (TS ":") }
 '[' { PT _ (TS "[") }
 ']' { PT _ (TS "]") }
 ',' { PT _ (TS ",") }
 'false' { PT _ (TS "false") }
 'null' { PT _ (TS "null") }
 'true' { PT _ (TS "true") }

L_quoted { PT _ (TL $$) }
L_doubl  { PT _ (TD $$) }
L_err    { _ }


%%

String  :: { String }  : L_quoted { $1 }
Double  :: { Double }  : L_doubl  { (read $1) :: Double }

JSONObject :: { JSONObject }
JSONObject : '{' ListJSONPair '}' { JObject $2 } 


JSONPair :: { JSONPair }
JSONPair : String ':' JSONValue { JPair $1 $3 } 


JSONArray :: { JSONArray }
JSONArray : '[' ListJSONValue ']' { JArray $2 } 


JSONValue :: { JSONValue }
JSONValue : String { JStr $1 } 
  | Double { JNum $1 }
  | JSONObject { JObj $1 }
  | JSONArray { JArr $1 }
  | 'true' { JTru }
  | 'false' { JFal }
  | 'null' { JNul }


ListJSONPair :: { [JSONPair] }
ListJSONPair : {- empty -} { [] } 
  | JSONPair { (:[]) $1 }
  | JSONPair ',' ListJSONPair { (:) $1 $3 }


ListJSONValue :: { [JSONValue] }
ListJSONValue : {- empty -} { [] } 
  | JSONValue { (:[]) $1 }
  | JSONValue ',' ListJSONValue { (:) $1 $3 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map prToken (take 4 ts))

myLexer = tokens
}

