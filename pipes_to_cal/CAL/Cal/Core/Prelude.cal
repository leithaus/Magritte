/*
 * Copyright (c) 2007 BUSINESS OBJECTS SOFTWARE LIMITED
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *  
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *  
 *     * Neither the name of Business Objects nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


/*
 * Prelude.cal
 * Created: Sept 2000
 * By: Bo Ilic
 */

/**
This is the CAL Prelude module. {@summary The Prelude module is the core module of CAL and must be
imported by every other CAL module.@}

The Prelude defines the primitive types {@link Char@}, {@link Boolean@}, {@link Byte@}, {@link Short@},
{@link Int@}, {@link Long@}, {@link Float@} and {@link Double@} that correspond to the primitive
unboxed Java types. It also defines other important CAL types such as {@link String@}, {@link Function@},
{@link List@}, {@link Maybe@}, {@link Either@}, {@link typeConstructor = Unit@} and the built-in record and tuple types.

The Prelude defines many core type classes: {@link Eq@}, {@link Ord@}, {@link Num@},
{@link Inputable@}, {@link Outputable@}, {@link Appendable@}, {@link Bounded@},
{@link Enum@} and {@link Typeable@}, as well as appropriate instances of these classes for the
types described above.

Finally, the Prelude contains the definitions of many functions generally useful in writing CAL 
programs and working with values of the above types. 

Note that although the {@link String@} and {@link List@} types are defined in the Prelude module,
most of the useful basic functions for working specifically with them are to be found in the
{@link module = "Cal.Core.String"@} and {@link module = "Cal.Collections.List"@} modules respectively.

It is not safe for users to alter the contents of the Prelude module. The Prelude module
contains many basic constructs essential to CAL's internal operation and altering these can result
in unpredictable failures.

The CAL language is a lazy strongly-typed functional language supporting close integration with the
Java platform. Many of the core CAL modules contain features that are adaptations of work specified in
the Haskell 98 Language and Libraries report {@url http://www.haskell.org/onlinereport/@}. 

Some optimized implementations of CAL functions are adapted from versions of the Haskell standard libraries
as implemented by the Hugs 98 Haskell interpreter {@url http://www.haskell.org/hugs/@} and the Glasgow Haskell
Compiler {@url http://www.haskell.org/ghc/@}.

See the file {@code ThirdPartyComponents/ThirdPartyComponents.txt@} for the Hugs license and
the Glasgow Haskell Compiler license.

@author Bo Ilic 
*/
module Cal.Core.Prelude;

friend Cal.Collections.Array;
friend Cal.Collections.ArrayPrimitives;
friend Cal.Core.Debug;
friend Cal.Core.Dynamic;
friend Cal.Core.Exception;
friend Cal.Collections.List;
friend Cal.Test.Core.Prelude_Tests;
friend Cal.Core.Resource;
friend Cal.Core.String;
friend Cal.Core.System;
//please do not add additional friend modules to the Prelude

//////////////////////////////////////////////////////////////////////
// Data types

/*
The Function type in CAL is built-in. What this means is that the Prelude defines a type named Prelude.Function.
It can also be used in its operator form of "->". For example, instead of writing Function Int Char, one can 
write (and normally does write) Int -> Char.

The Function type is unique in CAL in that it is not an algebraic data type, and it is not a foreign data type.
*/

/**
 * The {@link Boolean@} type represents a boolean logical quantity. The two possible values are
 * {@link False@} and {@link True@}.
 * 
 * The {@link Boolean@} type can correspond to the Java primitive type "boolean" in foreign function declarations.
 * 
 * Basic operations on {@link Boolean@} values include:
 * {@unorderedList
 * {@item {@link and@} (operator form: {@code &&@}) - logical conjunction@}
 * {@item {@link or@} (operator form: {@code ||@}) - logical disjunction@}
 * {@item {@link not@} - logical complement@}
 * @}
 *
 * The derived {@link Ord@} instance provides an ordering of the two {@link Boolean@} values, namely
 * {@code {@link False@} < {@link True@}@}.
 */
data public Boolean =
    public False |
    public True
    deriving Eq, Ord, Bounded;

/**
 * The {@link List@} type constructor has special notation. For example, instead of writing
 * {@code List Int@} in a type expression one can write {@code [Int]@}.
 * 
 * The {@link Nil@} data constructor can be written as {@code []@} instead within an expression.
 * 
 * The {@link Cons@} data constructor has special notation. For example, instead of writing {@code Cons 'a' "def"@}
 * one can write {@code 'a' : "def"@}.
 * 
 * Many useful functions for working with lists are defined in the {@link module = "Cal.Collections.List"@} module.
 * 
 * @see module = "Cal.Collections.List"
 */
data public List a = 
    
    public Nil | 
    
    public Cons 
        head :: a
        tail :: (List a) 
        
    deriving Eq, Ord;


/** 
 * The {@link typeConstructor = Unit@} type {@code ()@}, which has only one data value, also denoted {@code ()@}.
 * In foreign function declarations, it is used for functions that return the "void" type in Java.
 * 
 * The {@link typeConstructor = Unit@} type constructor has special notation. It can be written as {@code ()@} within a type expression
 * instead of as {@link typeConstructor = Unit@}.
 * 
 * The {@link dataConstructor = Unit@} data constructor has special notation. It can be written as {@code ()@}
 * within an expression instead of as {@link dataConstructor = Unit@}.
 */
data public Unit =
    public Unit
    deriving Eq, Ord, Bounded, Enum;

//////////////////////////////////////////////////////////////////////

/**
 * The {@link Char@} type is a 16-bit unsigned integral value representing a Unicode character.
 * More precisely, a {@link Char@} represents a {@em code unit@} in the UTF-16 encoding.
 * (For more information on Unicode terminology, please consult the Unicode Glossary at
 * {@url http://www.unicode.org/glossary/@}.)
 * 
 * The {@link Char@} type is a foreign type that corresponds to the primitive Java type {@code char@}" 
 * (and not the reference type {@code java.lang.Character@}).
 *  
 * Constants of type {@link Char@} can be created using single quote notation such as {@code 'a'@}
 * or {@code 'b'@}. The escape characters {@code '\n'@} (newline), {@code '\r'@} (carriage return),
 * {@code '\t'@} (tab), {@code '\b'@} (backspace), {@code '\f'@} (form feed), {@code '\"'@} (double quote),
 * {@code '\''@} (single quote) and {@code '\\'@} (back slash) are supported.
 * 
 * In addition, explicit Unicode characters can be encoded using escape characters such as {@code '\u1234'@}
 * or {@code '\uABCD'@} i.e. a "u" followed by 4 hexidecimal digits ranging from 0 to F (or f).
 * Octal escape sequences are also accepted, as in Java e.g. {@code '\0177'@}.
 *  
 * The derived {@link Eq@} and {@link Ord@} instances for {@link Char@} values use the underlying primitive
 * Java comparison functions on char, which are based on comparing the integral representations. In particular,
 * they are very fast, but not locale sensitive.
 * 
 * The derived {@link Inputable@} instance inputs a {@code java.lang.Character@} object to a CAL {@link Char@} value.
 * 
 * The derived {@link Outputable@} instance outputs a CAL {@link Char@} value to a java.lang.Character object.
 * 
 * Many useful functions for working with characters are defined in the {@link module = "Cal.Core.Char"@} module.
 * 
 * @see module = "Cal.Core.Char"
 */
data foreign unsafe import jvm public "char"
    public Char deriving Eq, Ord, Inputable, Outputable;


/**
 * The {@link Byte@} type represents an 8-bit signed integral value with valid values from -128 to 127.
 * The {@link Byte@} type is a foreign type that corresponds to the primitive Java type {@code byte@}
 * (and not the reference type {@code java.lang.Byte@}).
 *  
 * Constants of type {@link Byte@} can be created using expression type signatures e.g. {@code 20 :: Byte@}.
 * 
 * The derived {@link Inputable@} instance inputs a {@code java.lang.Byte@} object to a CAL {@link Byte@} value.
 * 
 * The derived {@link Outputable@} instance outputs a CAL {@link Byte@} value to a {@code java.lang.Byte@} object.
 */
data foreign unsafe import jvm public "byte"
    public Byte deriving Eq, Ord, Inputable, Outputable;

/**
 * The {@link Short@} type represents a 16-bit signed integral value with valid values from -32768 to 32767.
 * The {@link Short@} type is a foreign type that corresponds to the primitive Java type {@code short@}
 * (and not the reference type {@code java.lang.Short@}).
 *  
 * Constants of type {@link Short@} can be created using expression type signatures e.g. {@code 30000 :: Short@}.
 * 
 * The derived {@link Inputable@} instance inputs a {@code java.lang.Short@} object to a CAL {@link Short@} value.
 * 
 * The derived {@link Outputable@} instance outputs a CAL {@link Short@} value to a {@code java.lang.Short@} object.
 */
data foreign unsafe import jvm public "short"
    public Short deriving Eq, Ord, Inputable, Outputable;

/**
 * The {@link Int@} type represents a 32-bit signed integral value with valid values from -2{@sup 31@} to 2{@sup 31@}-1.
 * The {@link Int@} type is a foreign type that corresponds to the primitive Java type {@code int@}
 * (and not the reference type {@code java.lang.Int@}).
 *  
 * Constants of type {@link Int@} can be created using expression type signatures e.g. {@code 100000 :: Int@}.
 * 
 * The derived {@link Inputable@} instance inputs a {@code java.lang.Integer@} object to a CAL {@link Int@} value.
 * 
 * The derived {@link Outputable@} instance outputs a CAL {@link Int@} value to a {@code java.lang.Integer@} object.
 */
data foreign unsafe import jvm public "int"
    public Int deriving Eq, Ord, Inputable, Outputable;

/**
 * The {@link Long@} type represents a 64-bit signed integral value with valid values from -2{@sup 63@} to 2{@sup 63@}-1.
 * The {@link Long@} type is a foreign type that corresponds to the primitive Java type {@code long@}
 * (and not the reference type {@code java.lang.Long@}).
 *  
 * Constants of type {@link Long@} can be created using expression type signatures e.g. {@code 10000000000 :: Long@}.
 * 
 * The derived {@link Inputable@} instance inputs a {@code java.lang.Long@} object to a CAL {@link Long@} value.
 * 
 * The derived {@link Outputable@} instance outputs a CAL {@link Long@} value to a {@code java.lang.Long@} object.
 */
data foreign unsafe import jvm public "long"
    public Long deriving Eq, Ord, Inputable, Outputable;

/**
 * The {@link Float@} type represents a single-precision 32-bit format IEEE 754 floating-point value.
 * The {@link Float@} type is a foreign type that corresponds to the primitive Java type {@code float@}
 * (and not the reference type {@code java.lang.Float@}).
 * 
 * The derived {@link Inputable@} instance inputs a {@code java.lang.Float@} object to a CAL {@link Float@} value.
 * 
 * The derived {@link Outputable@} instance outputs a CAL {@link Float@} value to a {@code java.lang.Float@} object.
 */
data foreign unsafe import jvm public "float"
    public Float deriving Eq, Ord, Inputable, Outputable;

/**
 * The {@link Double@} type represents a double-precision 64-bit format IEEE 754 floating-point value.
 * The {@link Double@} type is a foreign type that corresponds to the primitive Java type {@code double@}
 * (and not the reference type {@code java.lang.Double@}).
 * 
 * The derived {@link Inputable@} instance inputs a {@code java.lang.Double@} object to a CAL {@link Double@} value.
 * 
 * The derived {@link Outputable@} instance outputs a CAL {@link Double@} value to a {@code java.lang.Double@} object.
 */
data foreign unsafe import jvm public "double"
    public Double deriving Eq, Ord, Inputable, Outputable;

/**
 * The {@link String@} type represents a character string. The {@link String@} type is a foreign type
 * that corresponds to the Java type {@code java.lang.String@}.
 *  
 * Constants of type {@link String@} can be created using double quote notation such as {@code "Hello"@}
 * or {@code "x"@}. The escape characters {@code '\n'@} (newline), {@code '\r'@} (carriage return),
 * {@code '\t'@} (tab), {@code '\b'@} (backspace), {@code '\f'@} (form feed), {@code '\"'@} (double quote),
 * {@code '\''@} (single quote) and {@code '\\'@} (back slash) can appear within string literals.
 * 
 * In addition, explicit Unicode characters can be encoded using escape characters such as {@code '\u1234'@}
 * or {@code '\uABCD'@} i.e. a "u" followed by 4 hexidecimal digits ranging from 0 to F (or f).
 * Octal escape sequences are also accepted, as in Java e.g. {@code '\0177'@}.
 *  
 * The derived {@link Inputable@} instance inputs a {@code java.lang.String@} object to a CAL {@link String@} value.
 * 
 * The derived {@link Outputable@} instance outputs a CAL {@link String@} value to a {@code java.lang.String@} object.
 * 
 * Many useful functions for working with strings are defined in the {@link module = "Cal.Core.String"@} module.
 * 
 * @see module = "Cal.Core.String"
 */
data foreign unsafe import jvm public "java.lang.String"
    public String deriving Eq, Ord, Inputable, Outputable;


//functions corresponding to the allowed primitive conversions in Java, as well as conversions to an from the Integer
//and Decimal types.

foreign unsafe import jvm "cast" private byteToByte :: Byte -> Byte;
foreign unsafe import jvm "cast" private byteToChar :: Byte -> Char;
foreign unsafe import jvm "cast" private byteToShort :: Byte -> Short;
foreign unsafe import jvm "cast" private byteToInt :: Byte -> Int;
foreign unsafe import jvm "cast" private byteToLong :: Byte -> Long;
foreign unsafe import jvm "cast" private byteToFloat :: Byte -> Float;
foreign unsafe import jvm "cast" private byteToDouble :: Byte -> Double;
byteToInteger :: Byte -> Integer;
private byteToInteger !byteValue = longToInteger (byteToLong byteValue);
byteToDecimal :: Byte -> Decimal;
private byteToDecimal !byteValue = longToDecimal (byteToLong byteValue);


foreign unsafe import jvm "cast" private shortToByte :: Short -> Byte;
foreign unsafe import jvm "cast" private shortToShort :: Short -> Short;
foreign unsafe import jvm "cast" private shortToChar :: Short -> Char;
foreign unsafe import jvm "cast" private shortToInt :: Short -> Int;
foreign unsafe import jvm "cast" private shortToLong :: Short -> Long;
foreign unsafe import jvm "cast" private shortToFloat :: Short -> Float;
foreign unsafe import jvm "cast" private shortToDouble :: Short -> Double;
shortToInteger :: Short -> Integer;
shortToInteger !shortValue = longToInteger (shortToLong shortValue);
shortToDecimal :: Short -> Decimal;
shortToDecimal !shortValue = longToDecimal (shortToLong shortValue);

//todoBI the casting functions for char are probably better placed elsewhere
foreign unsafe import jvm "cast" private charToByte :: Char -> Byte;
foreign unsafe import jvm "cast" private charToShort :: Char -> Short;
foreign unsafe import jvm "cast" private charToChar :: Char -> Char;
foreign unsafe import jvm "cast" private charToInt :: Char -> Int;
foreign unsafe import jvm "cast" private charToLong :: Char -> Long;
foreign unsafe import jvm "cast" private charToFloat :: Char -> Float;
foreign unsafe import jvm "cast" private charToDouble :: Char -> Double;


foreign unsafe import jvm "cast" private intToByte :: Int -> Byte;
foreign unsafe import jvm "cast" private intToShort :: Int -> Short;
foreign unsafe import jvm "cast" private intToChar :: Int -> Char;
foreign unsafe import jvm "cast" private intToInt :: Int -> Int;
foreign unsafe import jvm "cast" private intToLong :: Int -> Long;
foreign unsafe import jvm "cast" private intToFloat :: Int -> Float;
foreign unsafe import jvm "cast" private intToDouble :: Int -> Double;
/**
 * Converts an {@link Int@} value to the corresponding {@link Integer@} value.
 * 
 * @arg intValue the {@link Int@} value to be converted.
 * @return the corresponding {@link Integer@} value.
 */
intToInteger :: Int -> Integer;
private intToInteger !intValue = longToInteger (intToLong intValue);
intToDecimal :: Int -> Decimal;
private intToDecimal !intValue = longToDecimal (intToLong intValue);


foreign unsafe import jvm "cast" private longToByte :: Long -> Byte;
foreign unsafe import jvm "cast" private longToShort :: Long -> Short;
foreign unsafe import jvm "cast" private longToChar :: Long -> Char;
foreign unsafe import jvm "cast" private longToInt :: Long -> Int;
foreign unsafe import jvm "cast" private longToLong :: Long -> Long;
foreign unsafe import jvm "cast" private longToFloat :: Long -> Float;
foreign unsafe import jvm "cast" private longToDouble :: Long -> Double;
/**
 * Converts a {@link Long@} value to the corresponding {@link Integer@} value.
 * 
 * @arg longValue the {@link Long@} value to be converted.
 * @return the corresponding {@link Integer@} value.
 */
foreign unsafe import jvm "static method java.math.BigInteger.valueOf" private longToInteger :: Long -> Integer;
foreign unsafe import jvm "static method java.math.BigDecimal.valueOf" private longToDecimal :: Long -> Decimal;


foreign unsafe import jvm "cast" private floatToByte :: Float -> Byte;
foreign unsafe import jvm "cast" private floatToShort :: Float -> Short;
foreign unsafe import jvm "cast" private floatToChar :: Float -> Char;
foreign unsafe import jvm "cast" private floatToInt :: Float -> Int;
foreign unsafe import jvm "cast" private floatToLong :: Float -> Long;
foreign unsafe import jvm "cast" private floatToFloat :: Float -> Float;
foreign unsafe import jvm "cast" private floatToDouble :: Float -> Double;
floatToInteger :: Float -> Integer;
floatToInteger !floatValue = decimalToInteger (floatToDecimal floatValue);
floatToDecimal :: Float -> Decimal;
floatToDecimal !floatValue = doubleToDecimal (floatToDouble floatValue);


foreign unsafe import jvm "cast" private doubleToByte :: Double -> Byte;
foreign unsafe import jvm "cast" private doubleToShort :: Double -> Short;
foreign unsafe import jvm "cast" private doubleToChar :: Double -> Char;
foreign unsafe import jvm "cast" private doubleToInt :: Double -> Int;
foreign unsafe import jvm "cast" private doubleToLong :: Double -> Long;
foreign unsafe import jvm "cast" private doubleToFloat :: Double -> Float;
foreign unsafe import jvm "cast" private doubleToDouble :: Double -> Double;
doubleToInteger :: Double -> Integer;
doubleToInteger !doubleValue = decimalToInteger (doubleToDecimal doubleValue);
/**
 * Converts a {@link Double@} value to the equivalent {@link Decimal@} value.
 * An error is signalled if {@code doubleValue@} is {@link notANumber@}, {@link positiveInfinity@},
 * or {@link negativeInfinity@}.
 * 
 * @arg doubleValue {@link Double@} value to convert to a {@link Decimal@}.  This should
 *      not be {@link notANumber@}, {@link positiveInfinity@}, or {@link negativeInfinity@}. 
 * @return the equivalent {@link Decimal@} value to {@code doubleToDouble@}
 */
foreign unsafe import jvm "constructor"
    private doubleToDecimal :: Double -> Decimal;


foreign unsafe import jvm "method byteValue"
    private integerToByte :: Integer -> Byte;   
foreign unsafe import jvm "method shortValue"
    private integerToShort :: Integer -> Short;
/**
 * Converts an {@link Integer@} value to the corresponding {@link Int@} value.
 * 
 * @arg integerValue the {@link Integer@} value to be converted.
 * @return the corresponding {@link Int@} value.
 */
foreign unsafe import jvm "method intValue" private integerToInt :: Integer -> Int;
/**
 * Converts an {@link Integer@} value to the corresponding {@link Long@} value.
 * 
 * @arg integerValue the {@link Integer@} value to be converted.
 * @return the corresponding {@link Long@} value.
 */
foreign unsafe import jvm "method longValue" private integerToLong :: Integer -> Long;
foreign unsafe import jvm "method floatValue" private integerToFloat :: Integer -> Float;
foreign unsafe import jvm "method doubleValue" private integerToDouble :: Integer -> Double;
foreign unsafe import jvm "cast" private integerToInteger :: Integer -> Integer;
/**
 * Converts an {@link Integer@} value to the equivalent {@link Decimal@} value.
 * The precision will be the number of digits in the {@link Integer@} (ie, the
 * scale will be 0).
 * @arg integerValue An {@link Integer@} value to convert to a {@link Decimal@}
 * @return A {@link Decimal@} value equivalent to {@code integerValue@}.
 */
foreign unsafe import jvm "constructor"
    private integerToDecimal :: Integer -> Decimal;


foreign unsafe import jvm "method byteValue" private decimalToByte :: Decimal -> Byte;
foreign unsafe import jvm "method shortValue" private decimalToShort :: Decimal -> Short;
foreign unsafe import jvm "method intValue" private decimalToInt :: Decimal -> Int;
foreign unsafe import jvm "method longValue" private decimalToLong :: Decimal -> Long;
foreign unsafe import jvm "method floatValue" private decimalToFloat :: Decimal -> Float;
/**
 * Attempts to convert a {@link Decimal@} value to the nearest {@link Double@} value.
 * If the magnitude of the {@link Decimal@} value is too large to represent
 * as a {@link Double@}, then the result will be either {@link positiveInfinity@}
 * (for positive values) or {@link negativeInfinity@} (for negative values).
 * Even when the return value is finite, there may be some loss of
 * precision.
 * @arg decimalValue {@link Decimal@} value to convert
 * @return the closest equivalent {@link Double@} value to {@code decimalValue@}, or 
 *          {@link positiveInfinity@} or {@link negativeInfinity@} (depending on 
 *          {@code decimalValue@}'s sign) if the magnitude of {@code decimalValue@} is
 *          too large to fit into a {@link Double@}.
 */
foreign unsafe import jvm "method doubleValue"
    private decimalToDouble :: Decimal -> Double;
foreign unsafe import jvm "method toBigInteger"
    private decimalToInteger :: Decimal -> Integer;
foreign unsafe import jvm "cast"
    private decimalToDecimal :: Decimal -> Decimal;


//////////////////////////////////////////////////////////////////////
//the Maybe type and its instances

/**
The {@link Maybe@} type can be thought of as representing an optional value.
For example, a value of type {@code Maybe {@link Double@}@} can be {@code {@link Just@} 2.0@},
indicating that the value 2.0 was supplied, or it can be
{@link Nothing@}, indicating that no {@link Double@} value was supplied.

It is also common to use the {@link Maybe@} type as the return type of a function
where the value {@link Nothing@} returned indicates an exception or error occurred within the
function. As an alternative, one can call the {@link Prelude.error@} function, which immediately
terminates execution, but that does not allow the caller to recover from the erroneous
situation, and so is rather severe.
*/
data public Maybe a = 
    
    /**
     * A data constructor which represents the fact that a value was not supplied.
     */
    public Nothing | 
    
    /**
     * A data constructor which represents the fact that a value was supplied.
     * @arg value
     *        the supplied value.
     */
    public Just 
        value :: a 
        
    deriving Eq, Ord;
    
testMaybeInstances :: Boolean;
private testMaybeInstances = 
    assert (Just 'a' == Just 'a') &&
    assert (not (Just 'a' == Just 'b')) &&
    assert (Just 'a' != Just 'b') &&
    assert (not (Just 1.0 != Just 1.0)) &&
    assert (Just 'a' > Nothing) && 
    assert (not (Nothing > Just 'a')) &&
    assert (Just 'b' > Just 'a') &&
    assert (not (Nothing > [Nothing, Just 1.0].Cons.head)) &&
    assert (Just 'a' >= Nothing ) &&
    assert (Nothing >= [Nothing, Just 1.0].Cons.head) &&
    assert (Just 'b' >= Just 'b') &&
    assert (Just 'b' >= Just 'a');

/**
 * Outputs to an object of Java type org.openquark.cal.foreignsupport.module.Prelude.MaybeValue, 
 * which is a convenient and efficient Java representation for values of the Maybe type.
 */
instance Outputable a => Outputable (Maybe a) where
    output = outputMaybe;
    ;

/**
 * Inputs from an object of Java type org.openquark.cal.foreignsupport.module.Prelude.MaybeValue, 
 * which is a convenient and efficient Java representation for values of the Maybe type.
 */    
instance Inputable a => Inputable (Maybe a) where
    input = inputMaybe;
    ;

outputMaybe :: Outputable a => Maybe a -> JObject;
private outputMaybe !maybeValue =
    case maybeValue of
    Nothing -> output maybeValue_makeNothing;
    Just {value} -> output (maybeValue_makeJust (output value));
    ;
    
inputMaybe :: Inputable a => JObject -> Maybe a;
private inputMaybe !javaMaybeValue =
    jMaybeToMaybe (input javaMaybeValue);   

jMaybeToMaybe :: Inputable a => JMaybeValue -> Maybe a;
private jMaybeToMaybe !javaMaybeValue =
    if maybeValue_isNothing javaMaybeValue then
        Nothing
    else
        Just (input (maybeValue_getValueField javaMaybeValue));
   
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Prelude.MaybeValue"
    private JMaybeValue deriving Inputable, Outputable;

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.Prelude.MaybeValue.makeNothing"
    private maybeValue_makeNothing :: JMaybeValue;

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.Prelude.MaybeValue.makeJust"
    private maybeValue_makeJust :: JObject -> JMaybeValue;
    
foreign unsafe import jvm "method isNothing"
    private maybeValue_isNothing :: JMaybeValue -> Boolean;
    
foreign unsafe import jvm "method getValueField"
    private maybeValue_getValueField :: JMaybeValue -> JObject;        
   

//////////////////////////////////////////////////////////////////////
// the Either type and its instances

/**
The {@link Either@} type represents values with two possibilities. A value of type {@code Either a b@} is either
{@code {@link Left@} a@} or {@code {@link Right@} b@}.
 
For example, the list {@code [{@link Left@} "abc", {@link Right@} 2.0]@} has type
{@code Either {@link String@} {@link Double@}@}.

The {@link Either@} type is sometimes used as an alternative to the {@link Maybe@} type when representing the return
type of a function that may fail. The {@link Left@} data constructor is then used to hold failure information (i.e. an
error message for example), and the {@link Right@} data constructor is then used to hold the successful return value.  
*/
data public Either a b = 
    
    /**
     * A data constructor that represents a value of the first of two possible types.
     * @arg value
     *        the value to be encapsulated.
     */
    public Left 
        value :: a | 
    
    /**
     * A data constructor that represents a value of the second of two possible types.
     * @arg value
     *        the value to be encapsulated.
     */
    public Right 
        value :: b 
        
    deriving Eq, Ord;

/**
 * Outputs to an object of Java type org.openquark.cal.foreignsupport.module.Prelude.EitherValue, 
 * which is a convenient and efficient Java representation for values of the Either type.
 */
instance (Outputable a, Outputable b) => Outputable (Either a b) where
    output = outputEither;
    ;
   
/**
 * Inputs from an object of Java type org.openquark.cal.foreignsupport.module.Prelude.EitherValue, 
 * which is a convenient and efficient Java representation for values of the Either type.
 */    
instance (Inputable a, Inputable b) => Inputable (Either a b) where
    input = inputEither;
    ;

outputEither :: (Outputable a, Outputable b) => Either a b -> JObject;
private outputEither !eitherValue =
    case eitherValue of
    Left {value} -> output (eitherValue_makeLeft (output value));
    Right {value} -> output (eitherValue_makeRight (output value));
    ;
    
inputEither :: (Inputable a, Inputable b) => JObject -> Either a b;
private inputEither !javaEitherValue =
    jEitherToEither (input javaEitherValue);
       
jEitherToEither :: (Inputable a, Inputable b) => JEitherValue -> Either a b;
private jEitherToEither !javaEitherValue =    
    if eitherValue_isLeft javaEitherValue then
        Left (input (eitherValue_getValueField javaEitherValue))
    else
        Right (input (eitherValue_getValueField javaEitherValue));

data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Prelude.EitherValue"
    private JEitherValue deriving Inputable, Outputable;

foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.Prelude.EitherValue.makeLeft"
    private eitherValue_makeLeft :: JObject -> JEitherValue;  
    
foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.Prelude.EitherValue.makeRight"
    private eitherValue_makeRight :: JObject -> JEitherValue;
    
foreign unsafe import jvm "method isLeft"
    private eitherValue_isLeft :: JEitherValue -> Boolean;
    
foreign unsafe import jvm "method getValueField"
    private eitherValue_getValueField :: JEitherValue -> JObject;    

/**
 * Extracts the {@code value@} field of a {@link Left@} value or terminates in an error if {@code eitherValue@} is
 * a {@link Right@} value. 
 * 
 * @arg eitherValue 
 * @return the {@code value@} field of a {@link Left@} value or terminates in an error if {@code eitherValue@} is
 *         a {@link Right@} value.
 * @see fromRight, isLeft
 */
fromLeft :: Either a b -> a; 
public fromLeft !eitherValue = eitherValue.Left.value;
    
/**
 * Extracts the {@code value@} field of a {@link Right@} value or terminates in an error if {@code eitherValue@} is
 * a {@link Left@} value. 
 * 
 * @arg eitherValue 
 * @return the {@code value@} field of a {@link Right@} value or terminates in an error if {@code eitherValue@} is
 *         a {@link Left@} value.
 * @see fromLeft, isRight
 */
fromRight :: Either a b -> b;
public fromRight !eitherValue = eitherValue.Right.value;

/**
 * Returns {@link True@} if {@code eitherValue@} is a {@link Left@} value and {@link False@} otherwise.
 * @arg eitherValue
 * @return {@link True@} if {@code eitherValue@} is a {@link Left@} value and {@link False@} otherwise.
 * @see isRight, fromLeft
 */
isLeft :: Either a b -> Boolean;
public isLeft !eitherValue = 
    case eitherValue of
    Left {} -> True;
    Right {} -> False;
    ;

/**
 * Returns {@link True@} if {@code eitherValue@} is a {@link Right@} value and {@link False@} otherwise.
 * @arg eitherValue
 * @return {@link True@} if {@code eitherValue@} is a {@link Right@} value and {@link False@} otherwise.
 * @see isLeft, fromRight
 */
isRight :: Either a b -> Boolean;
public isRight !eitherValue =
    case eitherValue of
    Left {} -> False;
    Right {} -> True;
    ;

/**
 * Applies one of the two specified functions to a value encapsulated by an {@link Either@} type.
 * If the value is {@code {@link Left@} x@}, then the first function is applied to {@code x@}; if the value is
 * {@code {@link Right@} y@}, then the second function is applied to {@code y@}.
 * 
 * @arg leftFunction
 *        the function to apply if the {@link Either@} value is {@code {@link Left@} x@}.
 * @arg rightFunction
 *        the function to apply if the {@link Either@} value is {@code {@link Right@} y@}.
 * @arg eitherValue
 *        the {@link Either@} value.
 * @return the result of the application of one of either {@code leftFunction@} or {@code rightFunction@} on
 *         the value encapsulated by the {@link Either@} value.
 */
either :: (a -> c) -> (b -> c) -> Either a b -> c;
public either leftFunction rightFunction !eitherValue =
    case eitherValue of
    Left x  -> leftFunction x;
    Right y -> rightFunction y;
    ;

            
//////////////////////////////////////////////////////////////////////
// the Ord type and its instances

/**
 * Represents an ordering relationship between two values: less than, equal to, or greater than.
 * 
 * @see typeClass = Ord
 * @see function = compare
 */
data public Ordering =
    
    /**
     * A data constructor that represents the ordering relationship of "less than".
     */
    public LT |
    
    /**
     * A data constructor that represents the ordering relationship of "equal to".
     */
    public EQ |
    
    /**
     * A data constructor that represents the ordering relationship of "greater than".
     */
    public GT
        
    deriving Eq, Ord, Enum, Bounded;


/**
 * Outputs to an object of Java type org.openquark.cal.foreignsupport.module.Prelude.OrderingValue, 
 * which is a convenient and efficient Java representation for values of the Ordering type.
 */
instance Outputable Ordering where
    output = outputOrdering;
    ;
 
/**
 * Inputs from an object of Java type org.openquark.cal.foreignsupport.module.Prelude.OrderingValue, 
 * which is a convenient and efficient Java representation for values of the Ordering type.
 */    
instance Inputable Ordering where
    input = inputOrdering;
    ;

outputOrdering :: Ordering -> JObject;
private outputOrdering !orderingValue =
    case orderingValue of
    LT -> output orderingValue_LT;
    EQ -> output orderingValue_EQ;
    GT -> output orderingValue_GT;
    ;
       
inputOrdering :: JObject -> Ordering;
private inputOrdering !javaOrderingValue =
    jOrderingToOrdering (input javaOrderingValue);
    
jOrderingToOrdering :: JOrderingValue -> Ordering;
private jOrderingToOrdering !javaOrderingValue =
    signumIntToOrdering (orderingValue_toInt javaOrderingValue);    
    
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Prelude.OrderingValue"
    private JOrderingValue deriving Inputable, Outputable;

foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Prelude.OrderingValue.LT"
    private orderingValue_LT :: JOrderingValue;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Prelude.OrderingValue.EQ"
    private orderingValue_EQ :: JOrderingValue;
foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Prelude.OrderingValue.GT"
    private orderingValue_GT :: JOrderingValue;

foreign unsafe import jvm "method toInt"
    private orderingValue_toInt :: JOrderingValue -> Int;
    



/**
 * Converts an {@link Int@} value to an {@link Ordering@} value. In particular, if the specified {@link Int@} value is
 * {@code < 0@}, {@link LT@} is returned. If the {@link Int@} value is {@code > 0@}, {@link GT@} is returned. {@link EQ@}
 * is returned if the {@link Int@} value is exactly {@code 0@}.
 * 
 * @arg intValue
 *        the {@link Int@} value to be converted.
 * @return {@link LT@}, {@link EQ@}, or {@link GT@} if the {@link Int@} value is respectively less than 0, equal to 0, or
 *         greater than 0.
 */
intToOrdering :: Int -> Ordering;
public intToOrdering !intValue =
    if intValue < 0 then
        LT
    else if intValue == 0 then
        EQ
    else
        GT;

/** 
 * similar to {@link intToOrdering@} but only handles the intValues -1, 0, 1. This is an optimization for some well-used
 * Prelude functions implemented in terms of Java primitives where the underlying Java primitive is known to return one of
 * -1, 0, or 1.
 */
signumIntToOrdering :: Int -> Ordering;
private signumIntToOrdering !intValue =
    case intValue of
    -1 -> LT;
    0 -> EQ;
    1 -> GT;
    _ -> error ("intValue must be -1, 0 or 1 and not " ++ intToString intValue);
    ;

/**
 * Converts an {@link Ordering@} value to an {@link Int@} value. In particular, {@link LT@} is mapped to -1, {@link EQ@} to 0,
 * and {@link GT@} to 1.
 * 
 * @arg orderingValue
 *        the {@link Ordering@} value to be converted.
 * @return -1, 0, or 1 if the {@link Ordering@} value is respectively {@link LT@}, {@link EQ@}, or {@link GT@}.
 */
orderingToInt :: Ordering -> Int;
public orderingToInt !orderingValue =
    case orderingValue of
    LT -> -1;
    EQ -> 0;
    GT -> 1;
    ;    

//////////////////////////////////////////////////////////////////////
    
    
/**
 * A CAL foreign type corresponding to the Java Object type.
 */
data foreign unsafe import jvm public "java.lang.Object"
    public JObject deriving Inputable, Outputable;


/**
 * Used to implement the {@link output@} instance function for derived instances of
 * {@link Outputable@} for foreign types having implementation type that is not one of the 
 * primitive Java types char, boolean, byte, short, int, long, float or double. 
 */
/*
 * @implementation this function is operationally equivalent to Prelude.id, and is similarly optimized
 * out if fully applied. We don't just use Prelude.id mainly because it improves the clarity of
 * tracing to know that an output operation was intended.
 */
outputJObject :: JObject -> JObject;
private outputJObject !x = x;

//////////////////////////////////////////////////////////////////////
// Type classes and instances

/**
 * The {@link Bounded@} type class is used to represent types that have a minimum bound and a maximum bound.
 * 
 * For example, the {@link Int@} type is an instance of {@link Bounded@}, since {@link Int@} is a finite precision signed 32
 * bit integer whereas the {@link Integer@} type, which is an arbitrary sized integer, is not an instance of {@link Bounded@}.
 * 
 * The {@link Bounded@} type class can be used in {@em deriving@} clauses for {@em enumeration@} types. An enumeration type
 * is an algebraic type having no type arguments, and such that each data constructor has no fields. The derived {@code minBound@}
 * class method returns the first data constructor declared in the type definition, while the {@code maxBound@} class method
 * returns the last one.
 */
public class Bounded a where
    /**
     * @return the minimum bound of the instance type.
     */
    public minBound :: a;
    /**
     * @return the maximum bound of the instance type.
     */
    public maxBound :: a;
    ;
    
/**
 * The {@link Bounded@} instance for the {@link Int@} type. {@summary The minimum and maximum bounds for {@link Int@} are,
 * respectively, -2{@sup 31@} and 2{@sup 31@} - 1@}.
 */
instance Bounded Int where
    /** The minimum bound for {@link Int@} is -2{@sup 31@}. */
    minBound = minBoundInt;
    /** The maximum bound for {@link Int@} is 2{@sup 31@} - 1. */
    maxBound = maxBoundInt;
    ;

//minBoundInt is -2^31.
minBoundInt :: Int;
private minBoundInt = -2147483648;

//maxBoundInt is 2^31 - 1.
maxBoundInt :: Int;
private maxBoundInt = 2147483647;

/**
 * The {@link Bounded@} instance for the {@link Long@} type. {@summary The minimum and maximum bounds for {@link Long@} are,
 * respectively, -2{@sup 63@} and 2{@sup 63@} - 1.@}
 */
instance Bounded Long where
    /** The minimum bound for {@link Long@} is -2{@sup 63@}. */
    minBound = minBoundLong;
    /** The maximum bound for {@link Long@} is 2{@sup 63@} - 1. */
    maxBound = maxBoundLong;
    ;

//minBoundLong is -2^63.
minBoundLong :: Long;   
private minBoundLong = -9223372036854775808;

//maxBoundLong is 2^63 - 1.
maxBoundLong :: Long;   
private maxBoundLong = 9223372036854775807;

/**
 * The {@link Bounded@} instance for the {@link Short@} type. {@summary The minimum and maximum bounds for {@link Short@} are,
 * respectively, -2{@sup 15@} and 2{@sup 15@} - 1.@}
 */
instance Bounded Short where
    /** The minimum bound for {@link Short@} is -2{@sup 15@}. */
    minBound = minBoundShort;
    /** The maximum bound for {@link Short@} is 2{@sup 15@} - 1. */
    maxBound = maxBoundShort;
    ;
    
//minBoundShort is -2^15
minBoundShort :: Short;
minBoundShort = -32768;

//minBoundShort is 2^15 - 1
maxBoundShort :: Short;
maxBoundShort = 32767;

// For the Enum and IntEnum instances it is also convenient to have the bounds expressed as Ints
minBoundShortAsInt :: Int;
minBoundShortAsInt = shortToInt minBoundShort;

maxBoundShortAsInt :: Int;
maxBoundShortAsInt = shortToInt maxBoundShort;

/**
 * The {@link Bounded@} instance for the {@link Byte@} type. {@summary The minimum and maximum bounds for {@link Byte@} are,
 * respectively, -2{@sup 7@} and 2{@sup 7@} - 1.@}
 */
instance Bounded Byte where
    /** The minimum bound for {@link Byte@} is -2{@sup 7@}. */
    minBound = minBoundByte;
    /** The maximum bound for {@link Byte@} is 2{@sup 7@} - 1. */
    maxBound = maxBoundByte;
    ;
    
//minBoundByte is -2^7
minBoundByte :: Byte;
minBoundByte = -128;

//maxBoundByte is 2^7 - 1.
maxBoundByte :: Byte;
maxBoundByte = 127;
    
// For the Enum and IntEnum instances it is also convenient to have the bounds expressed as Ints
minBoundByteAsInt :: Int;
minBoundByteAsInt = byteToInt minBoundByte;

maxBoundByteAsInt :: Int;
maxBoundByteAsInt = byteToInt maxBoundByte;

/**
 * The {@link Bounded@} instance for the {@link Char@} type. {@summary The minimum and maximum bounds for {@link Char@} are,
 * respectively, {@code '\u0000'@} and {@code '\uFFFF'@}.@}
 */
instance Bounded Char where
    /** The minimum bound for {@link Char@} is {@code '\u0000'@}. */
    minBound = minBoundChar;
    /** The maximum bound for {@link Char@} is {@code '\uFFFF'@}. */
    maxBound = maxBoundChar;
    ;

minBoundChar :: Char;    
private minBoundChar = '\u0000';

maxBoundChar :: Char;
private maxBoundChar = '\uFFFF';
        
// For the Enum and IntEnum instances it is also convenient to have the bounds expressed as Ints
minBoundCharAsInt :: Int;
minBoundCharAsInt = charToInt minBoundChar;

maxBoundCharAsInt :: Int;
maxBoundCharAsInt = charToInt maxBoundChar;

/*
--we can't do this sort of type class yet, since we don't support the type variables
--at the head of an application i.e. the f in "f a".
public class Functor f where
    public fmap :: (a -> b) -> (f a -> f b);
    ;
*/    

// What follows are the type classes and instances in CAL. These are similar to Haskell, except that CAL has a simplified
// Num class which derives from Ord. Haskell has a more complex hierarchy which allows the possibility of complex numbers. 

/**
The {@link Eq@} type class defines the notion of equality in CAL. Many types in CAL are instances of {@link Eq@}. 
Instances of {@link Eq@} should satisfy various algebraic laws in order for the functions that are defined 
using them to make intuitive sense. These laws basically say that the definitions of the various methods
for a particular instance are mutually consistent. For example, 

{@unorderedList
{@item {@code {@link notEquals@} x y = {@link not@} ({@link equals@} x y);@}@}
{@item {@code {@link equals@} x y = {@link not@} ({@link notEquals@} x y);@}@}
@}

The reason we don't simply define {@link notEquals@} in terms of {@link equals@} is efficiency: for various instance types,
such as {@link Int@}, there are primitive definitions of {@link notEquals@} that are more efficient than negating the result
of equality testing.

Typically instances of {@link Eq@} will also define an equivalence relation: i.e.

{@unorderedList
{@item reflexive: {@code {@link equals@} x x@} is {@link True@} for all {@code x@}.@}
{@item symmetric: if {@code {@link equals@} x y@} is {@link True@} then {@code {@link equals@} y x@} is also {@link True@}@}
{@item transitive: if {@code {@link equals@} x y@} is {@link True@} and {@code {@link equals@} y z@} is {@link True@} then
       {@code {@link equals@} x z@} is also {@link True@}.@}
@}
 
Some types cannot be instances of {@link Eq@} - for example the type {@code {@link Int@} -> {@link Int@}@}. This is because
it is not in general computationally practical to tell if two functions are equal; one would need to evaluate each function
on every {@link Int@} and verify that they produce the same result.
 
The {@link equals@} and {@link notEquals@} class methods have a built-in operator form ({@code ==@} and {@code !=@} respectively)
that can be used when using these methods in defining CAL functions. For example, instead of writing {@code {@link equals@} x y@}
you can simply write {@code x == y@}.

The {@link Eq@} type class can be used in {@em deriving@} clauses. For a type with n arguments, {@code T a1 ... an@}, this will
automatically create an instance definition {@code instance (Eq a1, Eq a2, ..., Eq an) => Eq (T a1 ... an) where ...@} using a
canonical boilerplate definition for the instance methods. When it provides the desired behavior, deriving an instance of {@link Eq@} 
is recommended. However, sometimes it does not and an explicit instance definition needs to be given.

When T is an algebraic type, the derived {@code equals@} class method is implemented as follows. Two values of the type T are equal
if they both correspond to the same underlying data constructor, and the field values of the two data constructors are equal, field by field.
The comparison of the field values is done in the order in which the fields are declared within the definition
of the data constructor. The algebraic type must be such that all the types of all the fields within its definition are instances of {@link Eq@}.
For example, the compiler will report an error when deriving an instance such as
{@code data F = F f::(Int -> Int) deriving Eq;@} because the type of the f field, {@code Int -> Int@} is not an instance of {@link Eq@}.

When T is a foreign type whose underlying implementation type is a Java object type, the derived {@link equals@} class method is
implemented by calling the Java method Object.equals(Object) on the underlying Java objects.

When T is a foreign type whose underlying type is a Java primitive type (char, boolean, byte, short, int, long, float, or double),
the derived {@link equals@} class method is implemented by calling the primitive Java equality operator.
*/
public class Eq a where    
    
    /**
     * Returns whether the two arguments are equal.
     * 
     * The operator form of {@code equals@} is {@code ==@}.
     * 
     * @arg x the first argument to compare.
     * @arg y the second argument to compare.
     * @return {@link True@} if {@code x@} and {@code y@} are equal; {@link False@} otherwise.
     */
    public equals :: a -> a -> Boolean;
    
    /**
     * Returns whether the two arguments not equal.
     * 
     * The operator form of {@link notEquals@} is {@code !=@}.
     * 
     * @arg x the first argument to compare.
     * @arg y the second argument to compare.
     * @return {@link True@} if {@code x@} and {@code y@} are not equal; {@link False@} otherwise.
     */
    public notEquals :: a -> a -> Boolean
        default notEqualsDefault;
    ;

notEqualsDefault :: Eq a => a -> a -> Boolean;
private notEqualsDefault !x !y =
    not (x == y);

// Definitions of standard comparison functions for foreign types
// These functions are used internally by derived Eq instances for foreign types.
foreign unsafe import jvm "method equals"  
    private equalsObject :: JObject -> JObject -> Boolean;
notEqualsObject :: JObject -> JObject -> Boolean;
private notEqualsObject !x !y = not (x `equalsObject` y);

/**
The {@link Ord@} type class defines the notion of an ordering of the values of a type in CAL. {@link Eq@} is a superclass of
{@link Ord@}, so any type that is an instance of {@link Ord@} must also be an instance of {@link Eq@}. 

Many types that are instances of {@link Eq@} are also instances of {@link Ord@}. But some are not since there is no reasonable
ordering on them. For example, the {@link typeConstructor = "Cal.Graphics.Color.Color"@} type is an instance of {@link Eq@} but is not an
instance of {@link Ord@}.
 
Instances of {@link Ord@} should satisfy various algebraic laws in order for the functions that are defined 
using them to make intuitive sense. These laws basically say that the definitions of the various methods for a particular instance
are mutually consistent. For example,

{@unorderedList
{@item {@code {@link greaterThanEquals@} x y = {@link not@} (y < x);@}@}
{@item {@code {@link greaterThanEquals@} x y = {@link compare@} x y != {@link LT@};@}@}
{@item {@code {@link greaterThanEquals@} x y = x == y || x > y;@}@}
{@item {@code {@link max@} x y = if x <= y then y else x;@}@}
{@item {@code {@link min@} x y = if x <= y then x else y;@}@}
@}

The {@link lessThan@}, {@link lessThanEquals@}, {@link greaterThanEquals@} and {@link greaterThan@} class methods have a
built-in operator form ({@code <@}, {@code <=@}, {@code >=@}, and {@code >@}) respectively that can be used when using these
methods in defining CAL functions.

Using the compare method can be more efficient for complex types since one can precisely characterize which comparison situation
you are in rather than needing potentially two calls to the relational class methods.

The {@link Ord@} type class can be used in {@em deriving@} clauses. For a type with n arguments, {@code T a1 ... an@}, this will
automatically create an instance definition {@code instance (Ord a1, Ord a2, ..., Ord an) => Ord (T a1 ... an) where ...@} using a
canonical boilerplate definition for the instance methods. When it provides the desired behavior, deriving an instance of {@link Ord@} 
is recommended. However, sometimes it does not and an explicit instance definition needs to be given. Usually, if you derive the
{@link Ord@} instance then you will also want to derive the {@link Eq@} instance.

When T is an algebraic type, the derived {@link compare@} class method is implemented as follows. When two values are compared, 
first the ordinals of the underlying data constructors are compared. (The ordinal of a data constructor is its 0-based index within
its type definition. For example, the ordinals of the data constructors of the {@link Ordering@} type, {@link LT@}, {@link EQ@}, and
{@link GT@}, are 0, 1 and 2 respectively). If the ordinals are equal, then both values have the same underlying data constructor,
and the field values of the data constructor are compared lexicographically in the order in which the fields are declared within
the data constructor. The algebraic type must be such that all the types of all the fields within its definition are instances of Ord.

When T is a foreign type whose underlying implementation type is a Java object type, the derived {@link compare@} class method is
implemented by calling the Java method {@code java.lang.Comparable.compareTo(Object)@} on the underlying objects. In particular, the implementation
type must implement the Java interface {@code java.lang.Comparable@} to avoid a CAL compilation error.

When T is a foreign type whose underlying type is a Java primitive type (char, byte, short, int, long, float, or double),
the derived {@link compare@} class method is implemented by calling the primitive Java comparison operators. For the Java primitive
type boolean, the ordering is determined by {@code false < true@}, even though an ordering for boolean values is not 
supported by Java itself.
*/
public class (Eq a) => Ord a where
    /**
     * Returns whether the first argument is less than the second argument.
     * 
     * The operator form of {@link lessThan@} is {@code <@}.
     * 
     * @arg x the first argument to compare.
     * @arg y the second argument to compare.
     * @return {@link True@} if {@code x@} is less than {@code y@}; {@link False@} otherwise.
     */
    public lessThan :: a -> a -> Boolean
        default lessThanDefault;
    
    /**
     * Returns whether the first argument is less than or equal to the second argument.
     * 
     * The operator form of {@link lessThanEquals@} is {@code <=@}.
     * 
     * @arg x the first argument to compare.
     * @arg y the second argument to compare.
     * @return {@link True@} if {@code x@} is less than or equal to {@code y@}; {@link False@} otherwise.
     */
    public lessThanEquals :: a -> a -> Boolean
        default lessThanEqualsDefault;
    
    /**
     * Returns whether the first argument is greater than or equal to the second argument.
     * 
     * The operator form of {@link greaterThanEquals@} is {@code >=@}.
     * 
     * @arg x the first argument to compare.
     * @arg y the second argument to compare.
     * @return {@link True@} if {@code x@} is greater than or equal to {@code y@}; {@link False@} otherwise.
     */
    public greaterThanEquals :: a -> a -> Boolean
        default greaterThanEqualsDefault;   
    
    /**
     * Returns whether the first argument is greater than the second argument.
     * 
     * The operator form of {@link greaterThan@} is {@code >@}.
     * 
     * @arg x the first argument to compare.
     * @arg y the second argument to compare.
     * @return {@link True@} if {@code x@} is greater than {@code y@}; {@link False@} otherwise.
     */
    public greaterThan :: a -> a -> Boolean
        default greaterThanDefault;
    
    /**
     * Returns an {@link Ordering@} based on how the first argument compares to the second argument.
     * 
     * @arg x the first argument to compare.
     * @arg y the second argument to compare.
     * @return {@link LT@}, {@link EQ@}, or {@link GT@} if {@code x@} is respectively less than, equal to, or greater than
     *         {@code y@}.
     */
    public compare :: a -> a -> Ordering;
    
    /**
     * Given the two arguments, returns the value that is the greater of the two.
     * In other words, the maximum of the two arguments is returned.
     * 
     * @arg x the first argument.
     * @arg y the second argument.
     * @return the maximum of {@code x@} and {@code y@}.
     */
    public max :: a -> a -> a
        default maxDefault;
    
    /**
     * Given the two arguments, returns the value that is the lesser of the two.
     * In other words, the minimum of the two arguments is returned.
     * 
     * @arg x the first argument.
     * @arg y the second argument.
     * @return the minimum of {@code x@} and {@code y@}.
     */
    public min :: a -> a -> a
        default minDefault;
    ;

lessThanDefault :: Ord a => a -> a -> Boolean;
private lessThanDefault !x !y =
    compare x y == LT;

lessThanEqualsDefault :: Ord a => a -> a -> Boolean;
private lessThanEqualsDefault !x !y =
    compare x y != GT;

greaterThanEqualsDefault :: Ord a => a -> a -> Boolean;
private greaterThanEqualsDefault !x !y =
    compare x y != LT;

greaterThanDefault :: Ord a => a -> a -> Boolean;
private greaterThanDefault !x !y =
    compare x y == GT;

maxDefault :: Ord a => a -> a -> a;
private maxDefault !x !y =
    if x <= y then y else x;

minDefault :: Ord a => a -> a -> a;
private minDefault !x !y = 
    if x <= y then x else y;   



// Definitions of standard comparison functions for foreign types     
// These functions are used internally by derived Ord instances for foreign types.
data foreign unsafe import jvm "java.lang.Comparable" 
    private JComparable; 

foreign unsafe import jvm "method compareTo"
    private jCompareComparableHelper :: JComparable -> JObject -> Int;
foreign unsafe import jvm "cast"
    private jComparableToJObject :: JComparable -> JObject;

//warning: this function returns values other than -1, 0, 1
jCompareComparable :: JComparable -> JComparable -> Int;
private jCompareComparable !x !y = jCompareComparableHelper x (jComparableToJObject y);

lessThanComparable :: JComparable -> JComparable -> Boolean;
private lessThanComparable !x !y = (x `jCompareComparable` y) < 0;
  
lessThanEqualsComparable :: JComparable -> JComparable -> Boolean;
private lessThanEqualsComparable !x !y = (x `jCompareComparable` y) <= 0;

greaterThanEqualsComparable :: JComparable -> JComparable -> Boolean;
private greaterThanEqualsComparable !x !y = (x `jCompareComparable` y) >= 0;

greaterThanComparable :: JComparable -> JComparable -> Boolean;
private greaterThanComparable !x !y = (x `jCompareComparable` y) > 0;

minComparable :: JComparable -> JComparable -> JComparable;
private minComparable !x !y =
    if x `lessThanEqualsComparable` y then x else y;

maxComparable :: JComparable -> JComparable -> JComparable;
private maxComparable !x !y =
    if x `lessThanEqualsComparable` y then y else x;

compareComparable :: JComparable -> JComparable -> Ordering;
private compareComparable !x !y = intToOrdering (x `jCompareComparable` y);

    
/**
The {@link Num@} type class defines what it means for a type to have numerical support in CAL using the usual arithmetic
operations of {@code +@}, {@code -@}, {@code *@}, and {@code /@}. 

Useful instances of {@link Num@} defined in the Prelude are for {@link Int@}, {@link Long@}, {@link Double@}, {@link Integer@} 
(arbitrary size integers), {@link Byte@}, {@link Short@}, {@link Float@} and {@link Decimal@}.

{@link Num@} derives from {@link Ord@}, so that CAL's {@link Num@} type class cannot be used for representing unordered numerical
types such as complex numbers or matrices.

One important point is that CAL does not do any coercion or promotion of numeric values like in many programming
languages. Rather, it relies on polymorphic integral constants to determine the precise type of a numeric expression.
In particular, integer literals such as {@code 2005@} are really short-hand for {@code {@link fromInt@} 2005@}. As a technical
point, if the literal cannot be represented by an {@link Int@} but can be represented by a {@link Long@}, then {@link fromLong@}
is used. Otherwise, {@link fromInteger@} is used.
  
Instances of {@link Num@} should satisfy various algebraic laws in order for the functions that are defined 
using them to make intuitive sense. These laws basically say that the definitions of the various methods for a particular instance
are mutually consistent. For example, {@code x + y@} should be the same as {@code x - (-y)@} for all {@code x@}, {@code y@}. 
*/
public class (Ord a) => Num a where    
    /**
     * Negates the given number.
     * 
     * The operator form of {@link negate@} is unary {@code -@}. This is the only unary operator in CAL.
     * 
     * @arg x the number to negate.
     * @return the negation of {@code x@}.
     */
    public negate :: a -> a;    
    
    /**
     * Returns the sum of two numbers.
     * 
     * The operator form of {@link add@} is {@code +@}.
     * 
     * @arg x the first addend.
     * @arg y the second addend.
     * @return the sum of {@code x@} and {@code y@}.
     */
    public add :: a -> a -> a;
    
    /**
     * Returns the result of subtracting the second number from the first number.
     * 
     * The operator form of {@link subtract@} is binary {@code -@}.
     * 
     * @arg x the minuend.
     * @arg y the subtrahend.
     * @return the difference.
     */
    public subtract :: a -> a -> a;
    
    /**
     * Returns the product of two numbers.
     * 
     * The operator form of {@link multiply@} is {@code *@}.
     * 
     * @arg x the multiplier.
     * @arg y the multiplicand.
     * @return the product of {@code x@} and {@code y@}.
     */
    public multiply :: a -> a -> a;
    
    /**
     * Returns the result of dividing the first number by the second number.
     * 
     * The operator form of {@link divide@} is {@code /@}.
     * 
     * @arg x the dividend.
     * @arg y the divisor.
     * @return the quotient.
     */
    public divide :: a -> a -> a;    
    
    /**
     * Returns the remainder from division. 
     * 
     * The operator form of {@link remainder@} is {@code %@}.
     * 
     * For integral types, the identity: {@code x == (x / y) * y + (x % y)@} must hold for all x and y.
     * For non-integral types, the identity: {@code x == (truncate (x / y)) * y + (x % y)@} must hold in general.
     * 
     * @arg x the dividend.
     * @arg y the divisor.
     * @return the remainder.
     */
    public remainder :: a -> a -> a;
    
    /**
     * Returns the absolute value of the given number.
     * 
     * The absolute value of a number is its numerical value without repect to sign.
     * The absolute value of -5 equals the absolute value of 5.
     * 
     * @arg x the number whose absolute value is requested.
     * @return the absolute value of {@code x@}. 
     */
    public abs :: a -> a;
    
    /**
     * Returns the sign of the given number.
     * 
     * The functions {@link abs@} and {@link signum@} should satisfy:
     *   {@code (abs x * signum x) == x@}
     * 
     * @arg x the number whose sign is requested.
     * @return one of: -1 (if the number is negative), 0 (if the number is zero), or 1 (if the number is positive). 
     */
    public signum :: a -> a;    
    
    /**
     * Converts a {@link Byte@} value to the corresponding value in a type that is an instance of {@link Num@}.
     * Conversions to {@link Byte@}, {@link Short@}, {@link Int@}, {@link Long@}, {@link Float@} and {@link Double@}
     * behave like the corresponding Java primitive cast operator.
     * 
     * @arg byteValue the {@link Byte@} value to be converted.
     * @return the corresponding value in the result type.
     */        
    public fromByte :: Byte -> a;
     
    /**
     * Converts a {@link Short@} value to the corresponding value in a type that is an instance of {@link Num@}.
     * Conversions to {@link Byte@}, {@link Short@}, {@link Int@}, {@link Long@}, {@link Float@} and {@link Double@}
     * behave like the corresponding Java primitive cast operator.
     * 
     * @arg shortValue the {@link Short@} value to be converted.
     * @return the corresponding value in the result type.
     */       
    public fromShort :: Short -> a;    
    
    /**
     * Converts an {@link Int@} value to the corresponding value in a type that is an instance of {@link Num@}.
     * Conversions to {@link Byte@}, {@link Short@}, {@link Int@}, {@link Long@}, {@link Float@} and {@link Double@}
     * behave like the corresponding Java primitive cast operator.
     * 
     * @arg intValue the {@link Int@} value to be converted.
     * @return the corresponding value in the result type.
     */    
    public fromInt :: Int -> a;
       
    /**
     * Converts a {@link Long@} value to the corresponding value in a type that is an instance of {@link Num@}.
     * Conversions to {@link Byte@}, {@link Short@}, {@link Int@}, {@link Long@}, {@link Float@} and {@link Double@}
     * behave like the corresponding Java primitive cast operator.
     * 
     * @arg longValue the {@link Long@} value to be converted.
     * @return the corresponding value in the result type.
     */           
    public fromLong :: Long -> a;
    
    /**
     * Converts a {@link Float@} value to the corresponding value in a type that is an instance of {@link Num@}.
     * Conversions to {@link Byte@}, {@link Short@}, {@link Int@}, {@link Long@}, {@link Float@} and {@link Double@}
     * behave like the corresponding Java primitive cast operator.
     * 
     * @arg floatValue the {@link Float@} value to be converted.
     * @return the corresponding value in the result type.
     */    
    public fromFloat :: Float -> a;       
     
    /**
     * Converts a {@link Double@} value to the corresponding value in a type that is an instance of {@link Num@}.
     * Conversions to {@link Byte@}, {@link Short@}, {@link Int@}, {@link Long@}, {@link Float@} and {@link Double@}
     * behave like the corresponding Java primitive cast operator.
     * 
     * @arg doubleValue the {@link Double@} value to be converted.
     * @return the corresponding value in the result type.
     */    
    public fromDouble :: Double -> a;
    
    /**
     * Converts an {@link Integer@} value to a value of the instance type.
     * @arg integerValue the {@link Integer@} value to convert.
     * @return the value of the instance type which correspond to the given {@link Integer@} value.
     */
    public fromInteger :: Integer -> a;
    
    /**
     * Converts a {@link Decimal@} value to a value of the instance type.
     * @arg decimalValue the {@link Decimal@} value to convert.
     * @return the value of the instance type which correspond to the given {@link Integer@} value.
     */    
    public fromDecimal :: Decimal -> a;        
    
    /**
     * Converts a value of the instance type to a {@link Byte@} value.
     * Conversions from {@link Byte@}, {@link Short@}, {@link Int@}, {@link Long@}, {@link Float@} and {@link Double@}
     * behave like the corresponding Java primitive cast operator.
     * 
     * @arg number the number to convert.
     * @return a {@link Byte@} value which correspond to the given number.
     */    
    public toByte :: a -> Byte;      
    
    /**
     * Converts a value of the instance type to a {@link Short@} value.
     * Conversions from {@link Byte@}, {@link Short@}, {@link Int@}, {@link Long@}, {@link Float@} and {@link Double@}
     * behave like the corresponding Java primitive cast operator.
     * 
     * @arg number the number to convert.
     * @return a {@link Short@} value which correspond to the given number.
     */     
    public toShort :: a -> Short;       
    
    /**
     * Converts a value of the instance type to an {@link Int@} value.
     * Conversions from {@link Byte@}, {@link Short@}, {@link Int@}, {@link Long@}, {@link Float@} and {@link Double@}
     * behave like the corresponding Java primitive cast operator.
     * 
     * @arg number the number to convert.
     * @return an {@link Int@} value which correspond to the given number.
     */     
    public toInt :: a -> Int;       
    
    /**
     * Converts a value of the instance type to a {@link Long@} value.
     * Conversions from {@link Byte@}, {@link Short@}, {@link Int@}, {@link Long@}, {@link Float@} and {@link Double@}
     * behave like the corresponding Java primitive cast operator.
     * 
     * @arg number the number to convert.
     * @return a {@link Long@} value which correspond to the given number.
     */     
    public toLong :: a -> Long;       
    
    /**
     * Converts a value of the instance type to a {@link Float@} value.
     * Conversions from {@link Byte@}, {@link Short@}, {@link Int@}, {@link Long@}, {@link Float@} and {@link Double@}
     * behave like the corresponding Java primitive cast operator.
     * 
     * @arg number the number to convert.
     * @return a {@link Float@} value which correspond to the given number.
     */     
    public toFloat :: a -> Float;    
      
    /**
     * Converts a value of the instance type to a {@link Double@} value.
     * Conversions from {@link Byte@}, {@link Short@}, {@link Int@}, {@link Long@}, {@link Float@} and {@link Double@}
     * behave like the corresponding Java primitive cast operator.
     * 
     * @arg number the number to convert.
     * @return a {@link Double@} value which correspond to the given number.
     */
    public toDouble :: a -> Double;  
    
    /**
     * Converts a value of the instance type to an {@link Integer@} value.
     * 
     * @arg number the number to convert.
     * @return an {@link Integer@} value which correspond to the given number.
     */    
    public toInteger :: a -> Integer;
    
    /**
     * Converts a value of the instance type to a {@link Decimal@} value.    
     * 
     * @arg number the number to convert.
     * @return a {@link Decimal@} value which correspond to the given number.
     */    
    public toDecimal :: a -> Decimal;    
    ;

compareInt :: Int -> Int -> Ordering;  
private compareInt !x !y = 
    if x < y then
        LT
    else if x == y then
        EQ
    else
        GT;
    
foreign unsafe import jvm "static method java.lang.Math.max" private maxInt :: Int -> Int -> Int;
foreign unsafe import jvm "static method java.lang.Math.min" private minInt :: Int -> Int -> Int;

instance Num Int where    
    negate = negateInt;    
    add = addInt;
    subtract = subtractInt;
    multiply = multiplyInt;
    divide = divideInt;
    remainder = remainderInt;
    abs = absInt;
    signum = signumInt;    
    fromByte = byteToInt;
    fromShort = shortToInt;
    fromInt = intToInt;
    fromLong = longToInt;
    fromFloat = floatToInt;
    fromDouble = doubleToInt;
    fromInteger = integerToInt; 
    fromDecimal = decimalToInt;
    toByte = intToByte;
    toShort = intToShort;
    toInt = intToInt;
    toLong = intToLong;
    toFloat = intToFloat;
    toDouble = intToDouble;
    toInteger = intToInteger;
    toDecimal = intToDecimal;
    ;
    
foreign unsafe import jvm "static method java.lang.Math.abs" private absInt :: Int -> Int; 

signumInt :: Int -> Int;   
private signumInt !x =
    if x > 0 then
        1
    else if x < 0 then
        -1
    else
        0;

compareFloat :: Float -> Float -> Ordering;  
private compareFloat !x !y = signumIntToOrdering (x `jCompareFloat` y);

//returns one of -1, 0 or 1.
foreign unsafe import jvm "static method java.lang.Float.compare"
    private jCompareFloat :: Float -> Float -> Int;  
    
foreign unsafe import jvm "static method java.lang.Math.max" private maxFloat :: Float -> Float -> Float;
foreign unsafe import jvm "static method java.lang.Math.min" private minFloat :: Float -> Float -> Float;    
    
instance Num Float where      
    negate = negateFloat;   
    add = addFloat;
    subtract = subtractFloat;
    multiply = multiplyFloat;
    divide = divideFloat;
    remainder = remainderFloat;
    abs = absFloat;
    signum = signumFloat;    
    fromByte = byteToFloat;
    fromShort = shortToFloat;
    fromInt = intToFloat;
    fromLong = longToFloat;
    fromFloat = floatToFloat;
    fromDouble = doubleToFloat;
    fromInteger = integerToFloat; 
    fromDecimal = decimalToFloat;
    toByte = floatToByte;
    toShort = floatToShort;
    toInt = floatToInt;
    toLong = floatToLong;
    toFloat = floatToFloat;
    toDouble = floatToDouble;
    toInteger = floatToInteger;
    toDecimal = floatToDecimal;    
    ;
    
foreign unsafe import jvm "static method java.lang.Math.abs" 
    private absFloat :: Float -> Float; 

//note: there are some tricky aspects here in how NaN and -0 are handled. 
foreign unsafe import jvm "static method java.lang.Math.signum" 
    private signumFloat :: Float -> Float; 
 
compareDouble :: Double -> Double -> Ordering;  
private compareDouble !x !y = signumIntToOrdering (x `jCompareDouble` y);

//returns one of -1, 0 or 1.
foreign unsafe import jvm "static method java.lang.Double.compare"
    private jCompareDouble :: Double -> Double -> Int;  

foreign unsafe import jvm "static method java.lang.Math.max" private maxDouble :: Double -> Double -> Double;
foreign unsafe import jvm "static method java.lang.Math.min" private minDouble :: Double -> Double -> Double;    
    
instance Num Double where   
    negate = negateDouble;    
    add = addDouble;
    subtract = subtractDouble;
    multiply = multiplyDouble;
    divide = divideDouble;
    remainder = remainderDouble;
    abs = absDouble;
    signum = signumDouble;    
    fromByte = byteToDouble;
    fromShort = shortToDouble;
    fromInt = intToDouble;
    fromLong = longToDouble;
    fromFloat = floatToDouble;
    fromDouble = doubleToDouble;
    fromInteger = integerToDouble; 
    fromDecimal = decimalToDouble;
    toByte = doubleToByte;
    toShort = doubleToShort;
    toInt = doubleToInt;
    toLong = doubleToLong;
    toFloat = doubleToFloat;
    toDouble = doubleToDouble;
    toInteger = doubleToInteger;
    toDecimal = doubleToDecimal;    
    ;
    
foreign unsafe import jvm "static method java.lang.Math.abs" 
    private absDouble :: Double -> Double; 

/**
 * There are some tricky aspects here in how NaN and -0 are handled. 
 * 
 * signum (positive double) --> 1.0
 * signum (negative double) --> -1.0
 * signum (0) --> 0
 * 
 * special cases:
 * signum (NaN) --> NaN
 * signum (-0.0) --> -0.0
 *      
 * @arg x double value
 * @return signum of the double value x
 */
foreign unsafe import jvm "static method java.lang.Math.signum" 
    private signumDouble :: Double -> Double; 

//implementation note: see the comment for compareInt
compareLong :: Long -> Long -> Ordering;  
private compareLong !x !y = 
    if x < y then
        LT
    else if x == y then
        EQ
    else
        GT;

foreign unsafe import jvm "static method java.lang.Math.max" private maxLong :: Long -> Long -> Long;
foreign unsafe import jvm "static method java.lang.Math.min" private minLong :: Long -> Long -> Long;      
    
instance Num Long where    
    negate = negateLong;    
    add = addLong;
    subtract = subtractLong;
    multiply = multiplyLong;
    divide = divideLong;
    remainder = remainderLong;
    abs = absLong;
    signum = signumLong;        
    fromByte = byteToLong;
    fromShort = shortToLong;
    fromInt = intToLong;
    fromLong = longToLong;
    fromFloat = floatToLong;
    fromDouble = doubleToLong;
    fromInteger = integerToLong; 
    fromDecimal = decimalToLong;
    toByte = longToByte;
    toShort = longToShort;
    toInt = longToInt;
    toLong = longToLong;
    toFloat = longToFloat;
    toDouble = longToDouble;
    toInteger = longToInteger;
    toDecimal = longToDecimal;        
    ;
    
foreign unsafe import jvm "static method java.lang.Math.abs" 
    private absLong :: Long -> Long; 

signumLong :: Long -> Long; 
private signumLong !x =
    if x > 0 then
        1
    else if x < 0 then
        -1
    else
        0;

compareShort :: Short -> Short -> Ordering;
private compareShort !x !y =
    if x < y then
        LT
    else if x == y then
        EQ
    else
        GT;
    
maxShort :: Short -> Short -> Short;
private maxShort !x !y = fromInt (max (toInt x) (toInt y));

minShort :: Short -> Short -> Short;
private minShort !x !y = fromInt (min (toInt x) (toInt y));

instance Num Short where   
    negate = negateShort;    
    add = addShort;
    subtract = subtractShort;
    multiply = multiplyShort;
    divide = divideShort;
    remainder = remainderShort;
    abs = absShort;
    signum = signumShort;       
    fromByte = byteToShort;
    fromShort = shortToShort;
    fromInt = intToShort;
    fromLong = longToShort;
    fromFloat = floatToShort;
    fromDouble = doubleToShort;
    fromInteger = integerToShort; 
    fromDecimal = decimalToShort;
    toByte = shortToByte;
    toShort = shortToShort;
    toInt = shortToInt;
    toLong = shortToLong;
    toFloat = shortToFloat;
    toDouble = shortToDouble;
    toInteger = shortToInteger;
    toDecimal = shortToDecimal;    
    ;
    
addShort :: Short -> Short -> Short; 
private addShort !x !y = fromInt (toInt x + toInt y);

subtractShort :: Short -> Short -> Short;
private subtractShort !x !y = fromInt (toInt x - toInt y);

multiplyShort :: Short -> Short -> Short; 
private multiplyShort !x !y = fromInt (toInt x * toInt y);

divideShort :: Short -> Short -> Short;
private divideShort !x !y = fromInt (toInt x / toInt y); 

absShort :: Short -> Short; 
private absShort !x = fromInt (abs (toInt x));

negateShort :: Short -> Short;
private negateShort !x = fromInt (negate (toInt x));

remainderShort :: Short -> Short -> Short;  
private remainderShort !x !y = fromInt (toInt x % toInt y);

signumShort :: Short -> Short;  
private signumShort !x = fromInt ((signum (toInt x)));


compareByte :: Byte -> Byte -> Ordering;
private compareByte !x !y =
    if x < y then
        LT
    else if x == y then
        EQ
    else
        GT;
    
maxByte :: Byte -> Byte -> Byte;
private maxByte !x !y = fromInt (max (toInt x) (toInt y));

minByte :: Byte -> Byte -> Byte;
private minByte !x !y = fromInt (min (toInt x) (toInt y));    

instance Num Byte where    
    negate = negateByte;   
    add = addByte;
    subtract = subtractByte;
    multiply = multiplyByte;
    divide = divideByte;
    remainder = remainderByte;
    abs = absByte;
    signum = signumByte;    
    fromByte = byteToByte;
    fromShort = shortToByte;
    fromInt = intToByte;
    fromLong = longToByte;
    fromFloat = floatToByte;
    fromDouble = doubleToByte;
    fromInteger = integerToByte; 
    fromDecimal = decimalToByte;
    toByte = byteToByte;
    toShort = byteToShort;
    toInt = byteToInt;
    toLong = byteToLong;
    toFloat = byteToFloat;
    toDouble = byteToDouble;
    toInteger = byteToInteger;
    toDecimal = byteToDecimal;    
    ;
    
addByte :: Byte -> Byte -> Byte; 
private addByte !x !y = fromInt (toInt x + toInt y);

subtractByte :: Byte -> Byte -> Byte;
private subtractByte !x !y = fromInt (toInt x - toInt y);

multiplyByte :: Byte -> Byte -> Byte; 
private multiplyByte !x !y = fromInt (toInt x * toInt y);

divideByte :: Byte -> Byte -> Byte;
private divideByte !x !y = fromInt (toInt x / toInt y); 

absByte :: Byte -> Byte; 
private absByte !x = fromInt (abs (toInt x));

negateByte :: Byte -> Byte;
private negateByte !x = fromInt (negate (toInt x));

remainderByte :: Byte -> Byte -> Byte;  
private remainderByte !x !y = fromInt (toInt x % toInt y);

signumByte :: Byte -> Byte;  
private signumByte !x = fromInt (signum (toInt x));      


//implementation note: see the comment for compareInt    
compareChar :: Char -> Char -> Ordering;
private compareChar !x !y =
    if x < y then
        LT
    else if x == y then
        EQ
    else
        GT;    

maxChar :: Char -> Char -> Char;
private maxChar !x !y =
    if x <= y then y else x;

minChar :: Char -> Char -> Char;
private minChar !x !y =
    if x <= y then x else y;

//////////////////////////////////////////////////////////////////////
// the Integer type and its instances

/**
 * The {@link Integer@} type represents arbitrary-precision integers.
 */
data foreign unsafe import jvm public "java.math.BigInteger"
    public Integer deriving Inputable, Outputable, Eq;

// We use a manual instance for Ord Integer instead of deriving it so that we can 
// defer to the Integer.max and Integer.min methods, which may be more efficient
// (and certainly will be no less efficient) than the generated minInteger/maxInteger
// would be.
instance Ord Integer where
    lessThan = lessThanInteger;
    lessThanEquals = lessThanEqualsInteger;
    greaterThanEquals = greaterThanEqualsInteger;
    greaterThan = greaterThanInteger;
    compare = compareInteger;
    max = maxInteger;
    min = minInteger;
    ;

//implementation note: see the comment for compareInt    
compareInteger :: Integer -> Integer -> Ordering;  
private compareInteger !x !y = signumIntToOrdering (x `jCompareInteger` y);

//jCompareInteger returns -1, 0, or 1. 
foreign unsafe import jvm "method compareTo"
    private jCompareInteger :: Integer -> Integer -> Int;    
    
foreign unsafe import jvm "method max"
    private maxInteger :: Integer -> Integer -> Integer;
foreign unsafe import jvm "method min"
    private minInteger :: Integer -> Integer -> Integer;     

instance Num Integer where    
    negate = negateInteger;    
    add = addInteger;
    subtract = subtractInteger;
    multiply = multiplyInteger;
    divide = divideInteger;
    remainder = remainderInteger;
    abs = absInteger;
    signum = signumInteger;    
    fromByte = byteToInteger;
    fromShort = shortToInteger;
    fromInt = intToInteger;
    fromLong = longToInteger;
    fromFloat = floatToInteger;
    fromDouble = doubleToInteger;
    fromInteger = integerToInteger; 
    fromDecimal = decimalToInteger;
    toByte = integerToByte;
    toShort = integerToShort;
    toInt = integerToInt;
    toLong = integerToLong;
    toFloat = integerToFloat;
    toDouble = integerToDouble;
    toInteger = integerToInteger;
    toDecimal = integerToDecimal;    
    ;
    
foreign unsafe import jvm "method abs" private absInteger :: Integer -> Integer; 

foreign unsafe import jvm "method signum" private signumIntegerAsInt :: Integer -> Int;

signumInteger :: Integer -> Integer;
private signumInteger !x =
    case signumIntegerAsInt x of
    -1 -> -1;
    0 -> 0;
    1 -> 1;
    ;


/**
 * Parses a string representation of an integer into an {@link Integer@} value.
 * 
 * @arg stringRep the string representation of an integer.
 * @return the corresponding {@link Integer@} value.
 */
foreign unsafe import jvm "constructor" public stringToInteger :: String -> Integer;


foreign unsafe import jvm "method negate" private negateInteger :: Integer -> Integer;
foreign unsafe import jvm "method add" private addInteger :: Integer -> Integer -> Integer;
foreign unsafe import jvm "method subtract" private subtractInteger :: Integer -> Integer -> Integer;
foreign unsafe import jvm "method multiply" private multiplyInteger :: Integer -> Integer -> Integer;
foreign unsafe import jvm "method divide" private divideInteger :: Integer -> Integer -> Integer;
foreign unsafe import jvm "method remainder" private remainderInteger :: Integer -> Integer -> Integer;

/**
 * Returns the result of raising the first argument to the power specified by the second argument.
 * 
 * @arg base the {@link Integer@} value whose power is to be taken.
 * @arg exponent an {@link Int@} value specifying the exponent in the exponentiation.
 * @return {@code base@}{@sup {@code exponent@}@}.
 */
foreign unsafe import jvm "method pow" public powerInteger :: Integer -> Int -> Integer;

/**
 * Converts an {@link Integer@} value to its string representation.
 * 
 * @arg integerValue the {@link Integer@} value to be converted.
 * @return the string representation of the given number.
 */
foreign unsafe import jvm "method toString"
    public integerToString :: Integer -> String;


//integer_ONE does not need to be public. Just use "1 :: Integer" instead. It is here for testing purposes only.
foreign unsafe import jvm "static field java.math.BigInteger.ONE" private integer_ONE :: Integer;
foreign unsafe import jvm "static field java.math.BigInteger.ZERO" private integer_ZERO :: Integer;


lessThanInteger :: Integer -> Integer -> Boolean;
private lessThanInteger !x !y  = jCompareInteger x y < 0;

lessThanEqualsInteger :: Integer -> Integer -> Boolean;
private lessThanEqualsInteger !x !y  = jCompareInteger x y <= 0;

greaterThanEqualsInteger :: Integer -> Integer -> Boolean;
private greaterThanEqualsInteger !x !y = jCompareInteger x y >= 0;

greaterThanInteger :: Integer -> Integer -> Boolean;
private greaterThanInteger !x !y = jCompareInteger x y > 0;


//////////////////////////////////////////////////////////////////////
// the Decimal type and its instances
/**
 * The {@link Decimal@} type represents arbitrary-precision signed decimal numbers.
 * It is an import of the Java BigDecimal type that provides the usual type
 * classes for numeric types (viz: {@link Eq@}, {@link Ord@},
 * {@link Num@}).  This means that you can use the arithmetic operators
 * with Decimal values.
 *  
 * A {@link Decimal@} value consists of an arbitrary-precision Integer value plus a
 * 32-bit unsigned "scale", which represents the number of digits to the
 * right of the decimal place.  So, for example:
 * {@unorderedList
 * {@item -3.00 has a scale of 2@}
 * {@item 123.11 has a scale of 2@}
 * {@item -1.0609 has a scale of 4@}
 * {@item 876134 has a scale of 0@}
 * @}
 * 
 * The result of an addition or subtraction of two {@link Decimal@} values will have 
 * the same scale as the input with the largest scale:
 * {@code
 *    1.0 + 2 = 3.0
 *    1.5 - 2.00 = -0.50
 * @}   
 * The result of a multiplication will have a scale of the sum of the scales
 * of the two inputs:
 * {@code
 *    -6.0 * 7.00 = -42.000
 *    1.0 * 1.0 * 1.0 * 1.0 = 1.0000
 * @}
 * The result of a division will have the same scale as the numerator:
 * {@code
 *    15.0 / 5.000 = 3.0
 *    18.00 / 9 = 2.00
 *    21.0 / 3 = 7.0 
 * @}
 * The output and input methods for this class convert {@link Decimal@} CAL values
 * to and from Java {@code java.math.BigDecimal@} objects.
 */
data foreign unsafe import jvm public "java.math.BigDecimal" 
    public Decimal 
    deriving Inputable, Outputable;

/**
 * Parses a string (eg. {@code "34.33"@}, {@code "1.0e50000"@}) into a {@link Decimal@}.
 * An error will be signalled for invalid strings.
 * 
 * @arg stringValue string to parse into a {@link Decimal@}
 * @return {@link Decimal@} value represented by {@code stringValue@} 
 */
foreign unsafe import jvm "constructor"
    public stringToDecimal :: String -> Decimal;


/**
 * The {@link Eq@} instance for the {@link Decimal@} type compares the represented values of the 
 * {@link Decimal@} values only.  (This is in contrast to the Java BigDecimal.equals method,
 * which also takes account of the scale of the values).
 * 
 * So, for example, 
 * {@code  
 *     equals (stringToDecimal "2.0") (stringToDecimal "2.000")
 * @}
 * returns {@link True@} (because both {@link Decimal@} values represent a value of 2),
 * whereas the Java method would return {@link False@} (because the left argument has
 * a different scale than the right argument).
 */
/*
 * @implementation We use a manual instance instead of deriving one, because a derived
 *                 instance would delegate to BigDecimal.equals, whose notion of
 *                 equality takes account of the scale of the arguments instead of
 *                 just the underlying value.
 *                 
 */
instance Eq Decimal where
    equals = equalsDecimal;
    notEquals = notEqualsDecimal;
    ;
 
compareDecimal :: Decimal -> Decimal -> Ordering;
private compareDecimal !decimalValue1 !decimalValue2 = 
    signumIntToOrdering (decimalValue1 `jCompareToDecimal` decimalValue2);

/** Returns -1, 0, or 1. */
foreign unsafe import jvm "method compareTo"
    private jCompareToDecimal :: Decimal -> Decimal -> Int;

equalsDecimal :: Decimal -> Decimal -> Boolean;
private equalsDecimal !decimalValue1 !decimalValue2 =
    jCompareToDecimal decimalValue1 decimalValue2 == 0;

notEqualsDecimal :: Decimal -> Decimal -> Boolean;
private notEqualsDecimal !decimalValue1 !decimalValue2 =
    jCompareToDecimal decimalValue1 decimalValue2 != 0;

/**
 * Like the {@code {@link Eq@} {@link Decimal@}@} instance,
 * the {@code Ord Decimal@} instance bases its comparisons
 * exclusively on the underlying values represented by {@link Decimal@} values, with no
 * reference to scale.
 */
/*
 * @implementation We use a manual Ord instance instead of deriving it so that we can 
 * use the BigDecimal.max and BigDecimal.min methods (which may be more
 * efficient than using compareTo, and at any rate won't be any slower).
 */
instance Ord Decimal where
    lessThan = lessThanDecimal;
    lessThanEquals = lessThanEqualsDecimal;
    greaterThanEquals = greaterThanEqualsDecimal;
    greaterThan = greaterThanDecimal;
    compare = compareDecimal;
    max = maxDecimal;
    min = minDecimal;
    ;

lessThanDecimal :: Decimal -> Decimal -> Boolean;
private lessThanDecimal !decimalValue1 !decimalValue2 =
    jCompareToDecimal decimalValue1 decimalValue2 < 0;

lessThanEqualsDecimal :: Decimal -> Decimal -> Boolean;
private lessThanEqualsDecimal !decimalValue1 !decimalValue2 =
    jCompareToDecimal decimalValue1 decimalValue2 <= 0;

greaterThanEqualsDecimal :: Decimal -> Decimal -> Boolean;
private greaterThanEqualsDecimal !decimalValue1 !decimalValue2 =
    jCompareToDecimal decimalValue1 decimalValue2 >= 0;

greaterThanDecimal :: Decimal -> Decimal -> Boolean;
private greaterThanDecimal !decimalValue1 !decimalValue2 =
    jCompareToDecimal decimalValue1 decimalValue2 > 0;

foreign unsafe import jvm "method min"
    private minDecimal :: Decimal -> Decimal -> Decimal;

foreign unsafe import jvm "method max"
    private maxDecimal :: Decimal -> Decimal -> Decimal;

/**
 * A {@link Decimal@} value consists of an arbitrary-precision Integer value plus a
 * 32-bit unsigned "scale", which represents the number of digits to the
 * right of the decimal place.  So, for example:
 * {@unorderedList    
 * {@item -3.00 has a scale of 2@}
 * {@item 123.11 has a scale of 2@}
 * {@item -1.0609 has a scale of 4@}
 * {@item 876134 has a scale of 0@}
 * @}
 * 
 * The result of an addition or subtraction of two {@link Decimal@} values will have 
 * the same scale as the input with the largest scale:
 * {@code
 *    1.0 + 2 = 3.0
 *    1.5 - 2.00 = -0.50
 * @}   
 * The result of a multiplication will have a scale of the sum of the scales
 * of the two inputs:
 * {@code
 *    -6.0 * 7.00 = -42.000
 *    1.0 * 1.0 * 1.0 * 1.0 = 1.0000
 * @}
 * The result of a division will have the same scale as the numerator:
 * {@code
 *    15.0 / 5.000 = 3.0
 *    18.00 / 9 = 2.00
 *    21.0 / 3 = 7.0
 * @}
 * The results of division are rounded to the nearest neighbour; if both neighbours
 * are equidistant, the results are rounded up:
 * {@code
 *    5.000 / 9 = 0.556
 *    (-1) / 2 = -1
 * @}
 */
instance Num Decimal where       
    negate = negateDecimal;    
    add = addDecimal;
    subtract = subtractDecimal;
    multiply = multiplyDecimal;
    divide = divideDecimal;
    remainder = remainderDecimal;
    abs = absDecimal;
    signum = signumDecimal;    
    fromByte = byteToDecimal;
    fromShort = shortToDecimal;
    fromInt = intToDecimal;
    fromLong = longToDecimal;
    fromFloat = floatToDecimal;
    fromDouble = doubleToDecimal;
    fromInteger = integerToDecimal; 
    fromDecimal = decimalToDecimal;
    toByte = decimalToByte;
    toShort = decimalToShort;
    toInt = decimalToInt;
    toLong = decimalToLong;
    toFloat = decimalToFloat;
    toDouble = decimalToDouble;
    toInteger = decimalToInteger;
    toDecimal = decimalToDecimal;        
    ;


foreign unsafe import jvm "method negate"
    private negateDecimal :: Decimal -> Decimal;

foreign unsafe import jvm "method abs"
    private absDecimal :: Decimal -> Decimal;

foreign unsafe import jvm "method signum" private signumDecimalAsInt :: Decimal -> Int;

signumDecimal :: Decimal -> Decimal;
private signumDecimal !x =
    case signumDecimalAsInt x of
    -1 -> -1;
    0 -> 0;
    1 -> 1;
    ;

foreign unsafe import jvm "method add"
    private addDecimal :: Decimal -> Decimal -> Decimal;

foreign unsafe import jvm "method subtract"
    private subtractDecimal :: Decimal -> Decimal -> Decimal;

foreign unsafe import jvm "method multiply"
    private multiplyDecimal :: Decimal -> Decimal -> Decimal;

foreign unsafe import jvm "method divide"
    private jDivideDecimal :: Decimal -> Decimal -> Int -> Decimal;

foreign unsafe import jvm "static field java.math.BigDecimal.ROUND_HALF_UP"
    private jROUND_HALF_UP :: Int;

divideDecimal :: Decimal -> Decimal -> Decimal;
private divideDecimal !numerator !denominator =
    jDivideDecimal numerator denominator jROUND_HALF_UP;

foreign unsafe import jvm "method remainder" 
    private remainderDecimal :: Decimal -> Decimal -> Decimal;

    
//////////////////////////////////////////////////////////////////////
// Boolean functions

/**
 * Returns the result of a logical OR operation on the two arguments.
 * 
 * {@link Prelude.or@} can also be used in its operator form (which is {@code ||@}).
 * 
 * @arg a the first {@link Boolean@} argument.
 * @arg b the second {@link Boolean@} argument.
 * @return {@link True@} when one or both arguments are {@link True@}; {@link False@} when both arguments are {@link False@}
 */
or :: Boolean -> Boolean -> Boolean;
public or !a b =
    case a of
    False -> b;
    True -> True;
    ;

/**
 * Returns the result of a logical AND operation on the two arguments.
 * 
 * {@link Prelude.and@} can also be used in its operator form (which is {@code &&@}).
 * 
 * @arg a the first {@link Boolean@} argument.
 * @arg b the second {@link Boolean@} argument.
 * @return {@link True@} when both arguments are {@link True@}; {@link False@} when one or both arguments are {@link False@}
 */
and :: Boolean -> Boolean -> Boolean;
public and !a b =
    case a of
    False -> False;
    True -> b;
    ;

/**
 * Returns the logical negation of the argument.
 * 
 * @arg x the {@link Boolean@} value to negate.
 * @return {@link True@} when the {@code x@} is {@link False@}; {@link False@} when the {@code x@} is {@link True@}.
 */
not :: Boolean -> Boolean;
public not !x =
    case x of
    True  -> False;
    False -> True;
    ;

//////////////////////////////////////////////////////////////////////
// Numeric functions

//built-in primitive functions for integer comparison and basic arithmetic

/**
 * equalsInt is used to define the instance method equals for derived Eq instances
 * for foreign types where the underlying Java type is the primitive type "int".
 * In particular, it is used by the derived Eq instance of Prelude.Int. 
 */
primitive private equalsInt :: Int -> Int -> Boolean;
primitive private notEqualsInt :: Int -> Int -> Boolean;
primitive private lessThanInt :: Int -> Int -> Boolean;
primitive private lessThanEqualsInt :: Int -> Int -> Boolean;
primitive private greaterThanEqualsInt :: Int -> Int -> Boolean;
primitive private greaterThanInt :: Int -> Int -> Boolean;

primitive private addInt :: Int -> Int -> Int;
primitive private subtractInt :: Int -> Int -> Int;
primitive private multiplyInt :: Int -> Int -> Int;
primitive private divideInt :: Int -> Int -> Int;
primitive private negateInt :: Int -> Int;
primitive private remainderInt :: Int -> Int -> Int;

//built-in primitive functions for double-precision floating point comparison and arithmetic

primitive private equalsDouble :: Double -> Double -> Boolean;
primitive private notEqualsDouble :: Double -> Double -> Boolean;
primitive private lessThanDouble :: Double -> Double -> Boolean;
primitive private lessThanEqualsDouble :: Double -> Double -> Boolean;
primitive private greaterThanEqualsDouble :: Double -> Double -> Boolean;
primitive private greaterThanDouble :: Double -> Double -> Boolean;

primitive private addDouble :: Double -> Double -> Double;
primitive private subtractDouble :: Double -> Double -> Double;
primitive private multiplyDouble :: Double -> Double -> Double;
primitive private divideDouble :: Double -> Double -> Double;
primitive private negateDouble :: Double -> Double;
primitive private remainderDouble :: Double -> Double -> Double;

//built-in primitive functions for single-precision floating point comparison and arithmetic

primitive private equalsFloat :: Float -> Float -> Boolean;
primitive private notEqualsFloat :: Float -> Float -> Boolean;
primitive private lessThanFloat :: Float -> Float -> Boolean;
primitive private lessThanEqualsFloat :: Float -> Float -> Boolean;
primitive private greaterThanEqualsFloat :: Float -> Float -> Boolean;
primitive private greaterThanFloat :: Float -> Float -> Boolean;

primitive private addFloat :: Float -> Float -> Float;
primitive private subtractFloat :: Float -> Float -> Float;
primitive private multiplyFloat :: Float -> Float -> Float;
primitive private divideFloat :: Float -> Float -> Float;
primitive private negateFloat :: Float -> Float;
primitive private remainderFloat :: Float -> Float -> Float;

//built-in primitive functions for long integer comparison and arithmetic

primitive private equalsLong :: Long -> Long -> Boolean;
primitive private notEqualsLong :: Long -> Long -> Boolean;
primitive private lessThanLong :: Long -> Long -> Boolean;
primitive private lessThanEqualsLong :: Long -> Long -> Boolean;
primitive private greaterThanEqualsLong :: Long -> Long -> Boolean;
primitive private greaterThanLong :: Long -> Long -> Boolean;

primitive private addLong :: Long -> Long -> Long;
primitive private subtractLong :: Long -> Long -> Long;
primitive private multiplyLong :: Long -> Long -> Long;
primitive private divideLong :: Long -> Long -> Long;
primitive private negateLong :: Long -> Long;
primitive private remainderLong :: Long -> Long -> Long;

//built-in primitive functions for short integer comparison

primitive private equalsShort :: Short -> Short -> Boolean;
primitive private notEqualsShort:: Short -> Short -> Boolean;
primitive private lessThanShort :: Short -> Short -> Boolean;
primitive private lessThanEqualsShort :: Short -> Short -> Boolean;
primitive private greaterThanEqualsShort :: Short -> Short -> Boolean;
primitive private greaterThanShort :: Short -> Short -> Boolean;

//built-in primitive functions for byte comparison

primitive private equalsByte :: Byte -> Byte -> Boolean;
primitive private notEqualsByte:: Byte -> Byte -> Boolean;
primitive private lessThanByte :: Byte -> Byte -> Boolean;
primitive private lessThanEqualsByte :: Byte -> Byte -> Boolean;
primitive private greaterThanEqualsByte :: Byte -> Byte -> Boolean;
primitive private greaterThanByte :: Byte -> Byte -> Boolean;


//mod is the same as Java's % operator on Int arguments.
/**
 * The remainder that corresponds to {@link divide@}.
 * 
 * e.g.
 * {@unorderedList
 * {@item {@code mod (-24) 5 = -4@}@}
 * {@item {@code mod 24 (-5) = 4@}@}
 * @}
 * 
 * This is a property of {@link mod@}: {@code ({@link divide@} x y) * y + (mod x y) = x@}
 * 
 * @arg x the dividend.
 * @arg y the divisor.
 * @return the remainder that would have resulted from dividing {@code x@} by {@code y@}.
 * @deprecated use {@link remainder@} instead.
 */
mod :: Int -> Int -> Int;
public mod !x !y = x % y;

/**
 * Simultaneous {@link divide@} and {@link remainder@} (or modulus) on {@link Int@} values.
 * 
 * @arg x the dividend.
 * @arg y the divisor.
 * @return the pair {@code (x / y, x % y)@}.
 */
divMod :: Int -> Int -> (Int, Int);
public divMod x y = (x / y, x % y);

/**
 * Returns whether the argument is even.
 * 
 * @arg x the {@link Int@} value whose evenness is to be determined.
 * @return {@link True@} if the argument is even; {@link False@} otherwise.
 */
isEven :: Int -> Boolean;
//todoBI generalize this type when we have an Integral type class
public isEven !x = (x % 2) == 0;

/**
 * Returns whether the argument is odd.
 * 
 * @arg x the {@link Int@} value whose oddness is to be determined.
 * @return {@link True@} if the argument is odd; {@link False@} otherwise.
 */
isOdd :: Int -> Boolean;
public isOdd !x = (x % 2) != 0;

/**
 * Truncates a number towards 0.
 * 
 * e.g.
 * {@unorderedList
 * {@item {@code truncate 2.6 = 2@}@}
 * {@item {@code truncate (-2.6) = -2@}@}
 * @}
 * 
 * @arg x the {@link Double@} value to be truncated.
 * @return the {@link Int@} value nearest {@code x@} between 0 and {@code x@}.
 */
truncate :: Double -> Int;
public truncate = doubleToInt;

/**
 * Rounds a number to the nearest integer. In border cases, round towards 0 for even integral parts and away from 0 for odd.
 * This is the same behavior as in Visual Basic, but differs from Crystal Reports' round function in border cases.
 * 
 * e.g.
 * {@unorderedList
 * {@item {@code round 2.3 = 2@}@}
 * {@item {@code round 2.6 = 3@}@}
 * {@item {@code round 2.5 = 2@}@}
 * {@item {@code round 1.5 = 2@}@}
 * {@item {@code round (-2.6) = -3@}@}
 * {@item {@code round (-2.5) = -2@}@}
 * @}
 * 
 * @arg x the {@link Double@} value to be rounded.
 * @return the {@link Int@} value nearest {@code x@}.
 */
foreign unsafe import jvm "static method org.openquark.cal.internal.foreignsupport.module.Prelude.Math.round"
    public round :: Double -> Int;

/**
 * Returns the smallest integer greater than or equal to {@code x@}.
 * 
 * e.g.
 * {@unorderedList
 * {@item {@code ceiling (-1.9) = -1@}@}
 * {@item {@code ceiling (1.3) = 2@}@}
 * @}
 * 
 * @arg x the {@link Double@} value whose ceiling is to be returned.
 * @return the smallest integer greater than or equal to {@code x@}.
 */
foreign unsafe import jvm "static method org.openquark.cal.internal.foreignsupport.module.Prelude.Math.ceiling" 
    public ceiling :: Double -> Int;

/**
 * Returns the greatest integer less than or equal to {@code x@}.
 * 
 * @arg x the {@link Double@} value whose floor is to be returned.
 * @return the greatest integer less than or equal to {@code x@}.
 */
foreign unsafe import jvm "static method org.openquark.cal.internal.foreignsupport.module.Prelude.Math.floor"
    public floor :: Double -> Int;


//////////////////////////////////////////////////////////////////////
// String functions


foreign unsafe import jvm "method toString"
    private jStringBuilderToString :: JStringBuilder -> String;

/**
 * Converts the list of characters to a string.
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Core.String.fromList"@}.
 * 
 * @arg listOfChars the list of characters.
 * @return a string constructed from the list of characters.
 */
charactersToString :: [Char] -> String;
protected charactersToString !listOfChars =
    jStringBuilderToString (foldLeftStrict jStringBuilder_append jStringBuilder_new listOfChars);

// Test for the empty String.
isEmptyString :: String -> Boolean;
private isEmptyString !stringValue = 
    lengthString stringValue == 0;


// Concatenates two strings
//appendString is private. Use Prelude.append instead.
foreign unsafe import jvm "method concat"
    private appendString :: String -> String -> String;

/* @example */
appendStringExamples :: Boolean;
private appendStringExamples =
    (appendString "abc" "def" == "abcdef") && ("abc" ++ "def" == "abcdef") &&
    (appendString "" "abc" == "abc") && (appendString "abc" "" == "abc") &&
    (appendString "" "" == "") 
    ;

/**
 * Returns the length of the string. The length is equal to the number of characters contained in the string.
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Core.String.length"@}.
 * 
 * @arg string the string whose length is to be returned.
 * @return the length of the string
 */
foreign unsafe import jvm "method length" 
    private lengthString :: String -> Int;


//////////////////////////////////////////////////////////////////////
// Char functions

//built-in primitive functions for char comparison

primitive private equalsChar :: Char -> Char -> Boolean;
primitive private notEqualsChar :: Char -> Char -> Boolean;
primitive private lessThanChar :: Char -> Char -> Boolean;
primitive private lessThanEqualsChar :: Char -> Char -> Boolean;
primitive private greaterThanEqualsChar :: Char -> Char -> Boolean;
primitive private greaterThanChar :: Char -> Char -> Boolean;


/* @example */
equalsRecordExamples :: Boolean;
private equalsRecordExamples =
    assert (equals ('a', 'b') ('a', 'b')) &&
    assert (not (equals ('a', 'b') ('b', 'a'))) &&
    assert (equals ("hello", 10.0) ("hello", 10.0));
                           
/* @example */
greaterThanRecordExamples :: Boolean;
private greaterThanRecordExamples = 
    assert (greaterThan (1.0, 'b') (1.0, 'a')) &&
    assert (greaterThan (2.0, 'a') (1.0, 'b')) &&    
    assert (not (greaterThan ("abc", 'a') ("abc", 'a'))) &&
    assert (greaterThan ("zap", "arg") ("arg", "zap"));
    
//////////////////////////////////////////////////////////////////////
// Some standard functions 

/**
 * Creates a pair (2-tuple).
 * 
 * @arg x the 1st component of the pair.
 * @arg y the 2nd component of the pair.
 * @return the pair {@code (x, y)@}.
 * @see tuple2, strictTuple2
 */
pair :: a -> b -> (a, b);
public pair x y = (x, y);

/**
 * Creates a triple (3-tuple).
 * 
 * @arg x the 1st component of the triple.
 * @arg y the 2nd component of the triple.
 * @arg z the 3rd component of the triple.
 * @return the triple {@code (x, y, z)@}.
 * @see tuple3, strictTuple3
 */
triple :: a -> b -> c -> (a, b, c);
public triple x y z = (x, y, z);

/**
 * Creates a 2-tuple.
 * 
 * @arg x1 the 1st component of the tuple.
 * @arg x2 the 2nd component of the tuple.
 * @return the tuple {@code (x1, x2)@}.
 * @see strictTuple2
 */
tuple2 :: a -> b -> (a, b);
public tuple2 x1 x2 = (x1, x2);

/**
 * Creates a 3-tuple.
 * 
 * @arg x1 the 1st component of the tuple.
 * @arg x2 the 2nd component of the tuple.
 * @arg x3 the 3rd component of the tuple.
 * @return the tuple {@code (x1, x2, x3)@}.
 * @see strictTuple3
 */
tuple3 :: a -> b -> c -> (a, b, c);
public tuple3 x1 x2 x3 = (x1, x2, x3);

/**
 * Creates a 4-tuple.
 * 
 * @arg x1 the 1st component of the tuple.
 * @arg x2 the 2nd component of the tuple.
 * @arg x3 the 3rd component of the tuple.
 * @arg x4 the 4th component of the tuple.
 * @return the tuple {@code (x1, x2, x3, x4)@}.
 * @see strictTuple4
 */
tuple4 :: a -> b -> c -> d -> (a, b, c, d);
public tuple4 x1 x2 x3 x4 = (x1, x2, x3, x4);

/**
 * Creates a 5-tuple.
 * 
 * @arg x1 the 1st component of the tuple.
 * @arg x2 the 2nd component of the tuple.
 * @arg x3 the 3rd component of the tuple.
 * @arg x4 the 4th component of the tuple.
 * @arg x5 the 5th component of the tuple.
 * @return the tuple {@code (x1, x2, x3, x4, x5)@}.
 * @see strictTuple5
 */
tuple5 :: a -> b -> c -> d -> e -> (a, b, c, d, e);
public tuple5 x1 x2 x3 x4 x5 = (x1, x2, x3, x4, x5);

/**
 * Creates a 6-tuple.
 * 
 * @arg x1 the 1st component of the tuple.
 * @arg x2 the 2nd component of the tuple.
 * @arg x3 the 3rd component of the tuple.
 * @arg x4 the 4th component of the tuple.
 * @arg x5 the 5th component of the tuple.
 * @arg x6 the 6th component of the tuple.
 * @return the tuple {@code (x1, x2, x3, x4, x5, x6)@}.
 * @see strictTuple6
 */
tuple6 :: a -> b -> c -> d -> e -> f -> (a, b, c, d, e, f);
public tuple6 x1 x2 x3 x4 x5 x6 = (x1, x2, x3, x4, x5, x6);

/**
 * Creates a 7-tuple.
 * 
 * @arg x1 the 1st component of the tuple.
 * @arg x2 the 2nd component of the tuple.
 * @arg x3 the 3rd component of the tuple.
 * @arg x4 the 4th component of the tuple.
 * @arg x5 the 5th component of the tuple.
 * @arg x6 the 6th component of the tuple.
 * @arg x7 the 7th component of the tuple.
 * @return the tuple {@code (x1, x2, x3, x4, x5, x6, x7)@}.
 * @see strictTuple7
 */
tuple7 :: a -> b -> c -> d -> e -> f -> g -> (a, b, c, d, e, f, g);
public tuple7 x1 x2 x3 x4 x5 x6 x7 = (x1, x2, x3, x4, x5, x6, x7);

/**
 * Creates a 2-tuple value, but ensures that the fields++ are evaluated (to weak-head normal form) prior to returning.
 */    
strictTuple2 :: a -> b -> (a, b);
public strictTuple2 !x1 !x2 = (x1, x2);

/**
 * Creates a 3-tuple value, but ensures that the fields are evaluated (to weak-head normal form) prior to returning.
 */
strictTuple3 :: a -> b -> c -> (a, b, c);
public strictTuple3 !x1 !x2 !x3 = (x1, x2, x3);

/**
 * Creates a 4-tuple value, but ensures that the fields are evaluated (to weak-head normal form) prior to returning.
 */
strictTuple4 :: a -> b -> c -> d -> (a, b, c, d);
public strictTuple4 !x1 !x2 !x3 !x4 = (x1, x2, x3, x4);

/**
 * Creates a 5-tuple value, but ensures that the fields are evaluated (to weak-head normal form) prior to returning.
 */
strictTuple5 :: a -> b -> c -> d -> e -> (a, b, c, d, e);
public strictTuple5 !x1 !x2 !x3 !x4 !x5 = (x1, x2, x3, x4, x5);

/**
 * Creates a 6-tuple value, but ensures that the fields are evaluated (to weak-head normal form) prior to returning.
 */
strictTuple6 :: a -> b -> c -> d -> e -> f -> (a, b, c, d, e, f);
public strictTuple6 !x1 !x2 !x3 !x4 !x5 !x6 = (x1, x2, x3, x4, x5, x6);

/**
 * Creates a 7-tuple value, but ensures that the fields are evaluated (to weak-head normal form) prior to returning.
 */
strictTuple7 :: a -> b -> c -> d -> e -> f -> g -> (a, b, c, d, e, f, g);
public strictTuple7 !x1 !x2 !x3 !x4 !x5 !x6 !x7 = (x1, x2, x3, x4, x5, x6, x7);

/**
 * Extracts the first component of a pair.
 * 
 * @arg pair the pair.
 * @return the first component of the pair.
 */
fst :: (a,b) -> a;
public fst !pair = pair.#1;

/**
 * Extracts the second component of a pair.
 * 
 * @arg pair the pair.
 * @return the second component of the pair.
 */
snd :: (a,b) -> b;
public snd !pair = pair.#2;

/**
 * Converts a function of a single pair argument to a function accepting 2 input arguments.
 * This function is named after the logician Haskell Curry.
 * 
 * @arg f the function to be curried.
 * @arg x the first argument to the curried function.
 * @arg y the second argument to the curried function.
 * @return the result of evaluating {@code (f (x, y))@}.
 */ 
curry :: ((a,b) -> c) -> (a -> b -> c);
public curry !f x y = f (x, y);

/**
 * Converts a function of 2 arguments to a function of a single pair argument.
 * 
 * @arg f the function to be uncurried.
 * @arg pair the pair of arguments to the uncurried function.
 * @return the result of evaluating {@code (f pair.#1 pair.#2)@}.
 */
uncurry :: (a -> b -> c) -> (a,b) -> c;
public uncurry !f !pair = f pair.#1 pair.#2;

/**
 * An identity function.
 * 
 * @arg x the argument.
 * @return {@code x@}, the supplied argument.
 */
id :: a -> a;
public id !x = x;

/**
 * A constant function.
 * 
 * @arg valueToReturn the value to be returned.
 * @arg valueToIgnore an ignored value.
 * @return {@code valueToReturn@}.
 */
const :: a -> b -> a;
public const !valueToReturn valueToIgnore = valueToReturn;

/**
 * {@link asTypeOf@} is a type-restricted version of {@link const@}. It can be used as a sort of a
 * casting function. Whatever the type of the argument {@code valueToIgnore@},
 * {@code valueToReturn@} is forced to have that type as well.
 * 
 * @arg valueToReturn the value to be returned.
 * @arg valueToIgnore an ignored value.
 * @return valueToReturn.
 * @see const
 */
asTypeOf :: a -> a -> a;
public asTypeOf !valueToReturn valueToIgnore = valueToReturn;

/**
 * {@code (compose f g)@} is the function composition of {@code f@} with {@code g@}. In other words, {@code (compose f g) x@}
 * is equivalent to the nested evaluation {@code (f (g x))@}.
 * 
 * This function can also be used in its operator form (which is {@code #@}).
 * 
 * @arg f the outer function of the composition.
 * @arg g the inner function of the composition.
 * @arg x the argument to the composite function.
 * @return the result of evaluating {@code (f (g x))@}.
 */
compose :: (b -> c) -> (a -> b) -> (a -> c);
public compose !f g x = f (g x);

/**
 * Example usage of the compose function, in its different forms (regular
 * function application, backquoted operator, and the {@code #@} operator).
 */
/* @example */
composeExamples :: Boolean;
composeExamples =
    assert ((compose longToString intToLong) 3 == "3")
    && assert ((longToString `compose` intToLong) 2 == "2")
    && assert ((longToString # intToLong) 10 == "10")
    && assert ((compose not isEmpty) [1.0, 2.0, 3.0])
    && assert ((not `compose` isEmpty) [1.0, 2.0, 3.0])
    && assert ((not # isEmpty) [1.0, 2.0, 3.0]);

/**
 * {@link flip@} converts a function of 2 arguments to another function of 2 arguments that accepts its
 * arguments in the opposite order. It is useful when making a partial application to the second
 * argument of a 2 argument function.
 * 
 * @arg f the function whose argument order is to be flipped.
 * @arg x the second argument to f.
 * @arg y the first argument to f.
 * @return the result of evaluating {@code (f y x)@}.
 */
flip :: (a -> b -> c) -> b -> a -> c;
public flip !f x y = f y x;

/**
 * A function application function. This function can also be used in its operator form (which is {@code $@}).
 * 
 * This function (and its operator form) can be viewed as redundant, since ordinary application
 * {@code (f x)@} means the same as {@code (apply f x)@} or {@code (f $ x)@}. However, {@code $@} has low, right-associative
 * binding precedence, so it sometimes allows parentheses to be omitted; for example:
 *
 * Writing {@code
 * f $ g $ h x
 * @} is the same as writing {@code
 * f (g (h x))
 * @}
 * 
 * It is also useful in higher-order situations, such as {@code ({@link "Cal.Collections.List.zipWith"@} apply functions listOfValues)@}.
 * 
 * @arg functionToApply the function to be applied.
 * @arg argument the argument to the function evaluation.
 * @return the result of evaluating {@code (functionToApply argument)@}.
 */
//public apply f x = f x; //rewrite with an eta-reduction for efficiency
apply :: (a -> b) -> a -> b;
public apply !functionToApply = functionToApply;

/**
 * Keeps applying {@code iterationFunction@} until {@code stopConditionFunction@} holds.
 * 
 * @arg stopConditionFunction the predicate that dictates when the iteration should stop
 * @arg iterationFunction the function to be iteratively applied.
 * @arg initialValue the initial value to the iterated application.
 * @return the result of the iterated application.
 */
until :: (a -> Boolean) -> (a -> a) -> a -> a;
public until !stopConditionFunction iterationFunction initialValue = 
    if stopConditionFunction initialValue then
        initialValue
    else
        until stopConditionFunction iterationFunction (iterationFunction initialValue);

//////////////////////////////////////////////////////////////////////
// Functions for controlling strictness

/**
 * {@link seq@} is a primitive function used to explicitly control the order of evaluation of CAL.
 * Its primary application is to limit lazy evaluation in cases where it would result in excess space usage.
 * {@link seq@} evaluates its first argument until WHNF (weak head normal form) is reached,
 * and then returns its second argument.
 * 
 * "evaluate to weak head normal form" means to evaluate an expression until you get a primitive value (such as an
 * {@link Int@} or {@link String@}), a function, or a data constructor. In particular, it does not evaluate the arguments of
 * the resulting data constructor. {@link seq@} is a very fine-grained way of controlling strictness.
 * 
 * For example,
 * {@unorderedList
 * {@item {@code seq ({@link error@} "error should be called") 2.0            //will call the error function@}@}
 * {@item {@code seq ({@link id@} ({@link error@} "error should be called")) 2.0      //will call the error function@}@}
 * {@item {@code seq ({@link Just@} ({@link error@} "error should not be called")) 2.0 //will return 2.0, and not call error. We already have the data constructor Just.@}@}
 * {@item {@code seq [{@link error@} "error should not be called"] 2.0        //will return 2.0, and not call error. We have the data constructor Cons.@}@}
 * @}
 * 
 * Note that plinging of arguments is defined in terms of {@link seq@}. For example, {@code
 * f !x y !z = someExpression;
 * @} means the same thing as: {@code
 * f x y z = x `seq` z `seq` someExpression;
 * @} i.e. {@code
 * f x y z = seq x (seq z someExpression);
 * @}
 * @arg x argument to be evaluated to WHNF prior to evaluating argument {@code y@}.
 * @arg y value to be returned after argument {@code x@} is evaluated to WHNF.
 * @return the argument {@code y@}.
 */
primitive public seq :: a -> b -> b;

/**
 * Strict function application. The argument {@code x@} of {@code f@} is reduced to WHNF (weak head normal form) before
 * {@code f@} is reduced.
 * 
 * @arg f the function to be applied.
 * @arg x the argument to {@code f@}, to be reduced to WHNF (weak head normal form) before {@code f@} is reduced.
 * @return the result of evaluating {@code (f x)@}.
 */
//public strict f !x = seq x (f x);
strict :: (a -> b) -> a -> b;
public strict f !x = f x;

/**
 * The {@link deepSeq@} function is similar to the {@link seq@} function, except that {@code deepSeq x y@} evaluates the
 * argument {@code x@} to normal form (instead of weak head normal form). What this means is that it evaluates the argument
 * {@code x@} to reduce it to a primitive value (such as an {@link Int@} or {@link String@}), a function, or a data constructor.
 * If it is a data constructor, it then evaluates (i.e. {@link deepSeq@}'s) all of the data constructor's arguments as well,
 * in left-to-right order.
 * 
 * In general, using {@link seq@} is preferable to using {@link deepSeq@}. {@link deepSeq@} is a heavy-weight tool that can
 * reduce the lazyness of your program more than necessary. However, in certain cases it does come in handy, such as when
 * performing benchmarks on intermediate computations.
 */
primitive public deepSeq :: a -> b -> b;

/**
 * Strict function application. The argument {@code x@} of {@code f@} is reduced to normal form before {@code f@} is reduced.
 * 
 * @arg f the function to be applied.
 * @arg x the argument to {@code f@}, to be reduced to normal form before {@code f@} is reduced.
 * @return the result of evaluating {@code (f x)@}.
 */
deepStrict :: (a -> b) -> a -> b;    
public deepStrict f !x = deepSeq x (f x);    

/**
 * {@link eager@} is used to force a strict evaluation of its argument to weak-head normal form.
 * This forced evaluation occurs even when the application of eager is in lazy context. (In a strict context
 * the expression will be evaluated to weak-head normal form anyways and so calling {@link eager@} is redundant and will
 * generate identical underlying code). 
 * 
 * {@link eager@} should be used with care since forcing the evaluation changes the normal reduction ordering and can affect
 * laziness. {@link eager@} should only be used in cases where the argument expression is known to have no side effects
 * (including throwing an exception).
 * 
 * With proper care eager can provide a significant performance boost since forcing the strict evaluation 
 * of the argument means we avoid building a lazy graph for it.
 * 
 * One way of thinking about {@link eager@} is that it instructs the compiler to unconditionally generate code to evaluate an
 * expression to weak-head normal form instead of building a lazy suspension or thunk. The compiler builds such a thunk
 * when it can't be sure that the resulting expression will be evaluated. There are many examples of the use of {@link eager@} in 
 * the {@link module = "Cal.Collections.Array"@} module. Some characteristic uses are commented in the definitions of {@link "Cal.Collections.Array.find"@},
 * {@link "Cal.Collections.Array.zip"@} and {@link "Cal.Collections.Array.binarySearchBy"@}. Typically we use {@link eager@} within an expression e.g.
 * {@code ... expr ...@} ---> {@code ... (eager expr) ...@} or for a let variable assignment e.g. {@code let x = expr@} --->
 * {@code let x = (eager expr)@}.
 * 
 * Some reasons for using eager:
 * {@orderedList
 * {@item we know that {@code expr@} is going to get evaluated to weak-head normal form later in the function's definition
 *        (and there is no side-effect or exception risk in doing the evaluation early).@}
 * {@item we don't know that {@code expr@} is going to be evaluated eventually, but we do know that evaluating to WHNF is
 *        less expensive than allocating memory for the suspended computation. For example, perhaps the expression is a call
 *        to an inexpensive function and all the arguments are known to be evaluated.@}
 * @}
 *    
 * To get the most use of {@link eager@}, one needs to know about the reduction order of CAL i.e. left-most outermost reduction,
 * also known as lazy evaluation, as well as plinging and {@link seq@}. Note that in contrast to {@link eager@}, {@link seq@} in
 * a lazy context does not evaluate anything - it just enforces sequencing of evaluations when such evaluations occur.
 * 
 * @arg value the value to compile strictly
 * @return the argument value
 * @see Prelude.seq, Prelude.deepSeq
 */
primitive public eager :: a -> a;
    
//////////////////////////////////////////////////////////////////////
// Standard list functions

// Function for testing for empty lists.
// Returns True if the input list is empty. 
isEmptyList :: [a] -> Boolean;
private isEmptyList !list = 
    case list of
    [] -> True;
    _ : _ -> False;
    ;   
    
/* @example */
equalsListExamples :: Boolean;
private equalsListExamples =
    assert (["abc", "def"] == ["abc", "def"])
    && assert (['a','b','\t','c'] == ['a','b','\t','c'])
    && assert (not (equals ['a','b','c'] ['A','B','C']))
    && assert (equals [] ([] :: [Double]))
    && assert (not (equals ['a'] []));
                             
//todoBI In Visual Basic, "a" > "A" while in Crystal Reports "A" > "a". We will need to carefully consider what
//the default ordering mechanism for characters will be in CAL.
/* @example */
greaterThanListExamples :: Boolean;
private greaterThanListExamples = 
    assert (['a'] > ['A'])
    && assert (['z','a','p'] > [])
    && assert (not ([] > ['z','a','p']))
    && assert (['a','b','c','d','f'] > ['a','b','c','d','e'])
    && assert (['a','b','c','d','e'] > ['a','b','c']);

/**
The {@link Appendable@} type class is used to represent types that support the notion of their value being
appended together or concatenated.

{@link String@} and {@link List@} are both instances of the {@link Appendable@} type class. In particular, this allows
both the {@link List@} type and the {@link String@} type to work with the {@code ++@} operator.

When appending more than two values it is generally more efficient to use {@link concat@} instead of 
multiple calls to {@link append@}
e.g. {@code {@link concat@} ["Apple", " ", "Pear", " ", "Orange"]@} 
instead of
{@code "Apple" ++ " " + "Pear" ++ "  " + "Orange".@}

{@link concat@} could be defined in terms of {@link append@} and {@link empty@}, but it is included as a class method for reasons 
of efficiency in its implementation for specific instances.

Instances of {@link Appendable@} should satisfy various algebraic laws in order for the functions that are defined 
using them to make intuitive sense. These laws basically say that the definitions of the various methods for a particular instance
are mutually consistent. For example,

{@unorderedList
{@item {@code {@link isEmpty@} {@link empty@} == {@link True@}@}@}
{@item {@code {@link empty@} ++ list == list@}@}
{@item {@code list ++ {@link empty@} == list@}@}
{@item {@code {@link concat@} list = {@link foldRight@} {@link append@} {@link empty@} list;@}@}
@}

The {@link append@} class method can be used in its built-in operator form {@code ++@}. For example, instead of writing
{@code {@link append@} "Fred" "Anton"@} you can write {@code "Fred" ++ "Anton"@}.
*/
public class Appendable a where
    /**
     * Returns the empty value of the instance type.
     * @return the empty value.
     */
    public empty :: a;
    
    /**
     * Returns whether the specified value is the empty value.
     * @arg value the value to check.
     * @return {@link True@} if the argument is the empty value; {@link False@} otherwise.
     */
    public isEmpty :: a -> Boolean;
    
    /**
     * Returns the concatenation of the two values.
     * 
     * The operator form of append is {@code ++@}.
     * 
     * @arg x the first value to be concatenated.
     * @arg y the second value to be concatenated.
     * @return the concatenation of {@code x@} and {@code y@}.
     */
    public append :: a -> a -> a;
    
    /**
     * Returns the concatenation of the values in the specified list.
     * 
     * @arg listOfValues the list of values to be concatenated together.
     * @return the concatenation of the values in the list.
     */
    public concat :: [a] -> a
        default concatDefault;
    ;

concatDefault :: Appendable a => [a] -> a;
private concatDefault = foldRight append empty;
 

instance Appendable [a] where
    empty = emptyList; 
    isEmpty = isEmptyList;  
    append = appendList;
    concat = concatList;    
    ;

emptyList :: [a];    
private emptyList = [];

//Concatenates 2 lists. Do not confuse with the function concat which concatenates multiple lists.
appendList :: [a] -> [a] -> [a];
private appendList !list1 list2 =
    case list1 of
    [] -> list2;
    list1Head : list1Tail ->
        list1Head : appendList list1Tail list2;
    ;      

//Concatenates multiple lists into a single list.
concatList :: [[a]] -> [a];
private concatList = foldRight append empty;   
    

instance Appendable String where
    empty = emptyString;  
    isEmpty = isEmptyString;
    append = appendString;
    concat = concatString;
    ;

emptyString :: String;
private emptyString = "";

//todoBI clean up this implementation
concatString :: [String] -> String;
private concatString !listOfStrings = jStringBuilder_toString (foldLeftStrict jStringBuilder_append2 jStringBuilder_new listOfStrings);

/**
 * The ++ operator on the Ordering type corresponds to the notion of lexicographic order.
 */ 
instance Appendable Ordering where
    empty = emptyOrdering;
    isEmpty = isEmptyOrdering;
    append = appendOrdering;
    ;

emptyOrdering :: Ordering;
private emptyOrdering = EQ;

isEmptyOrdering :: Ordering -> Boolean;
private isEmptyOrdering !ordering =
    case ordering of
    EQ -> True;
    _ -> False;
    ;

appendOrdering :: Ordering -> Ordering -> Ordering;
private appendOrdering !ord1 ord2 =
    case ord1 of
    LT -> LT;
    EQ -> ord2;
    GT -> GT;
    ;


/**
 * {@code map mapFunction list@} applies the function {@code mapFunction@} to each element of the list and returns
 * the resulting list.
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Collections.List.map"@}.
 * 
 * @arg mapFunction
 *        a function to be applied to each element of the list.
 * @arg list
 *        the list.
 * @return the list obtained by applying mapFunction to each element of the list.
 */
map :: (a -> b) -> [a] -> [b];
protected map mapFunction !list =
    case list of
    []     -> [];
    listHead : listTail -> mapFunction listHead : map mapFunction listTail;
    ;
    
/**
 * Returns the length of the specified list. This function is O(n) in time, where n is the length of the list.
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Collections.List.length"@}.
 * 
 * @arg list the list whose length is to be returned.
 * @return the length of the list.
 */
length :: [a] -> Int;
protected length !list =
    let
        lengthHelper :: Int -> [a] -> Int;
        lengthHelper !acc !list =
            case list of
            [] -> acc;
            listHead : listTail -> lengthHelper (acc + 1) listTail;
            ;
    in  
        lengthHelper 0 list;
 
/**
 * This is the strict version of {@link "Cal.Collections.List.foldLeft"@}. It is used for efficiency reasons in certain situations.
 * the main purpose is that so the {@link "Cal.Collections.List.length"@}, {@link "Cal.Collections.List.sum"@} and {@link "Cal.Collections.List.product"@} functions can be
 * constant space functions.
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Collections.List.foldLeftStrict"@}.
 * 
 * @arg foldFunction the function to be used in folding the list.
 * @arg initialValue the initial value for the folding process.
 * @arg list the list to be folded over.
 * @return the single result obtained from folding {@code foldFunction@} over the list.
 */
/*
 * @implementation notice that the difference between the implementation of foldLeftStrict and
 * foldLeft is just in the plinging of the initialValue argument.
 */    
foldLeftStrict ::  (a -> b -> a) -> a -> [b] -> a;
protected foldLeftStrict foldFunction !initialValue !list =
    case list of
    [] -> initialValue;
    listHead : listTail -> foldLeftStrict foldFunction (foldFunction initialValue listHead) listTail;
    ;       

/**
 * Similar to {@link "Cal.Collections.List.foldLeft"@}, except that the folding process on the list is started with its rightmost element.
 * Often the result of applying {@link "Cal.Collections.List.foldLeft"@} or {@link foldRight@} is the same, and the choice between them is a matter of
 * efficiency. Which is better depends on the nature of the folding function. As a general rule, if the folding
 * function is strict in both arguments, {@link foldLeftStrict@} is a good choice. Otherwise {@link foldRight@} is often best.
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Collections.List.foldRight"@}.
 * 
 * @arg foldFunction the function to be used in folding the list.
 * @arg initialValue the initial value for the folding process.
 * @arg list the list to be folded over.
 * @return the single result obtained from folding {@code foldFunction@} over the list.
 * @see foldLeftStrict
 */
foldRight :: (a -> b -> b) -> b -> [a] -> b;
protected foldRight foldFunction initialValue !list = 
    case list of
    [] -> initialValue;
    listHead : listTail -> foldFunction listHead (foldRight foldFunction initialValue listTail);
    ;

/**
 * {@code iterate f x@} returns the infinite list {@code [x, f x, f(f x), f(f(f x)), ...]@}.
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Collections.List.iterate"@}.
 * 
 * @arg iterationFunction the iteration function.
 * @arg initialValue the initial value.
 * @return the infinite list
 *         {@code [initialValue, iterationFunction initialValue, iterationFunction(iterationFunction initialValue), ...]@}
 */  
iterate :: (a -> a) -> a -> [a];
protected iterate iterationFunction initialValue = 
    initialValue : iterate iterationFunction (iterationFunction initialValue);

/**
 * {@code repeat valueToRepeat@} returns the infinite list {@code [valueToRepeat, valueToRepeat, valueToRepeat, ...]@}.
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Collections.List.repeat"@}.
 * 
 * @arg valueToRepeat the value to be repeated.
 * @return the infinite list {@code [valueToRepeat, valueToRepeat, valueToRepeat, ...]@} 
 */
repeat :: a -> [a];
protected repeat valueToRepeat =
    let
        //note that this is a recursive definition of repeatedValueList
        repeatedValueList = valueToRepeat : repeatedValueList;
    in
        repeatedValueList;

/**
 * {@code replicate nCopies valueToReplicate@} is a list of length {@code nCopies@}, with every element equal to
 * {@code valueToReplicate@}.
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Collections.List.replicate"@}.
 * 
 * @arg nCopies the number of copies.
 * @arg valueToReplicate the value to be replicated.
 * @return a list of length {@code nCopies@}, with every element equal to {@code valueToReplicate@}.
 */
replicate :: Int -> a -> [a];
protected replicate !nCopies valueToReplicate = take nCopies (repeat valueToReplicate);

/**
 * {@code take nElements list@} returns a list consisting of the first {@code nElements@} elements of {@code list@}.
 * If the list has fewer than {@code nElements@} elements, it just returns the list.
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Collections.List.take"@}.
 * 
 * @arg nElements the number of elements to take.
 * @arg list the list from which elements are to be taken.
 * @return a list of the requested elements from the list.
 */
take :: Int -> [a] -> [a];
protected take !nElements list =
    if nElements <= 0 then
        []
    else
        case list of
        [] -> [];
        listHead : listTail ->
            listHead : take (nElements - 1) listTail;
    ;

/**
 * {@code takeWhile takeWhileTrueFunction list@} returns the longest prefix of the list for which {@code takeWhileTrueFunction@}
 * is {@link True@} for each element.
 * 
 * e.g. {@code takeWhile {@link isEven@} [6, 2, 1, 2] = [6, 2]@}
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Collections.List.takeWhile"@}.
 * 
 * @arg takeWhileTrueFunction a predicate to be applied to the elements of the list.
 * @arg list the list from which elements are to be taken.
 * @return the longest prefix of the list for which {@code takeWhileTrueFunction@} is {@link True@} 
 *         for each element.
 */
takeWhile :: (a -> Boolean) -> [a] -> [a];
protected takeWhile takeWhileTrueFunction !list =
    case list of
    [] -> [];
    listHead : listTail ->
        if takeWhileTrueFunction listHead then
            listHead : takeWhile takeWhileTrueFunction listTail
        else
            [];
    ;             
  
/**
 * {@code concatMap mapFunction list@} applies {@code mapFunction@} to each element of list and then concatenates the resulting
 * list. The result type of the {@code mapFunction@} ({@code b@} in the type declaration) is {@link Appendable@} to allow for
 * the concatenation.
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Collections.List.concatMap"@}.
 * 
 * @arg mapFunction a function to be applied to the elements in the list.
 * @arg list the list whose elements are to be mapped.
 * @return the concatenation of the values obtained from mapping {@code mapFunction@} to the elements in the list.
 */
concatMap :: (Appendable b) => (a -> b) -> [a] -> b;
protected concatMap mapFunction = compose concat (map mapFunction);

/**
 * Converts two lists into a list of corresponding pairs.
 * If one input list is short, excess elements of the longer list are discarded.
 * 
 * e.g. {@code zip [6, 3] [10, 20, 30] = [(6,10), (3, 20)]@}
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Collections.List.zip"@}.
 * 
 * @arg list1 the first list to be zipped.
 * @arg list2 the second list to be zipped.
 * @return a list of corresponding pairs.
 */
//todoBI * @see zipWith
zip :: [a] -> [b] -> [(a,b)];
//public zip = zipWith tuple2;
protected zip !list1 list2 =
    case list1 of
    x : xs ->
        case list2 of
        y : ys -> (x, y) : zip xs ys;
        [] -> [];
        ;
    [] -> [];
    ;               

//////////////////////////////////////////////////////////////////////
// More list functions - initial version based on the Hugs List module
                   
/**
 * This function takes an element and a list and "intersperses" that element
 * between the elements of the list.
 * 
 * e.g. {@code intersperse 0 [1, 2, 3] = [1, 0, 2, 0, 3]@}
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Collections.List.intersperse"@}.
 * 
 * @arg separator the element to be interspersed between the elements of the list.
 * @arg list the list whose elements are to be interspersed by the separator.
 * @return the interspersed list.
 */
intersperse :: a -> [a] -> [a];
protected intersperse separator !list =
    case list of
    [] -> [];
    listHead : listTail ->
        if isEmpty listTail then
            listHead : []
        else
            listHead : separator : intersperse separator listTail;
    ;
                                                                                  
//////////////////////////////////////////////////////////////////////
// Maybe - initial version based on the Hugs Maybe module

/**
 * Returns {@link True@} iff the argument is of the form {@code {@link Just@} _@}.
 * 
 * @arg maybeValue the value to be checked.
 * @return {@link True@} if {@code maybeValue@} is of the form {@code {@link Just@} _@}; {@link False@} otherwise.
 */
isJust :: Maybe a -> Boolean;
public isJust !maybeValue = 
    case maybeValue of
    Just {}  -> True;
    Nothing -> False;
    ;

/**
 * Returns {@link True@} iff the argument is {@link Nothing@}.
 * 
 * @arg maybeValue the value to be checked.
 * @return {@link True@} if maybeValue is {@link Nothing@}; {@link False@} otherwise.
 */
isNothing :: Maybe a -> Boolean;
public isNothing !maybeValue =
    case maybeValue of
    Nothing -> True;
    Just {}  -> False;
    ;

/**
 * Extracts the element out of a {@link Just@} or terminates in an error if the {@link Maybe@} value
 * is {@link Nothing@}.
 * 
 * @arg maybeValue the value from which the element is to be extracted.
 * @return the element out of a {@link Just@}, or terminates in an error if the argument is {@link Nothing@}.
 */
fromJust :: Maybe a -> a;
public fromJust !maybeValue = 
    case maybeValue of
    Just value -> value;
    Nothing -> error "Nothing.";
    ;

/**
 * Extracts the element out of a {@link Just@} or returns the specified default value if the {@link Maybe@} value
 * is {@link Nothing@}.
 * 
 * @arg defaultValue the default value to be returned if the argument is {@link Nothing@}.
 * @arg maybeValue the value from which the element is to be extracted.
 * @return the element out of a {@link Just@}, or the specified default value if the argument is {@link Nothing@}.
 */
fromMaybe :: a -> Maybe a -> a;
public fromMaybe defaultValue !maybeValue =
    case maybeValue of
    Just value -> value;
    Nothing -> defaultValue;
    ;

/**
 * Returns an empty list when given {@link Nothing@} or a singleton list when not given {@link Nothing@}.
 * 
 * @arg maybeValue the {@link Maybe@} value.
 * @return an empty list if maybeValue is {@link Nothing@}, or a singleton list containing the element out of a {@link Just@}.
 */
maybeToList :: Maybe a -> [a];
public maybeToList !maybeValue =
    case maybeValue of
    Nothing -> [];
    Just value -> [value];
    ;

/**
 * Returns {@link Nothing@} on an empty list or {@code {@link Just@} firstElement@} where {@code firstElement@} is
 * the first element of the list.
 * 
 * @arg list the list to be converted to a Maybe value.
 * @return {@link Nothing@} if the list is empty, or {@code {@link Just@} firstElement@} where {@code firstElement@} is
 *         the first element of the list.
 */
listToMaybe :: [a] -> Maybe a;
public listToMaybe !list =
    case list of
    [] -> Nothing;
    listHead : _  -> Just listHead;
    ;

/**
 * Returns {@link Nothing@} on {@link Nothing@} or {@code {@link Just@} (func maybeArg)@} on {@code {@link Just@} maybeArg@}.
 * 
 * @arg func the function to be applied to a {@link Maybe@} value.
 * @arg maybeArg the {@link Maybe@} value argument.
 * @return {@link Nothing@} on {@link Nothing@} or {@code {@link Just@} (func maybeArg)@} on {@code {@link Just@} maybeArg@}.
 */
maybeApply :: (a -> b) -> Maybe a -> Maybe b;
public maybeApply func !maybeArg =
    case maybeArg of
    Nothing -> Nothing;
    Just arg -> Just $ func arg;
    ;
                                                                
//////////////////////////////////////////////////////////////////////
// instances of the Inputable and Outputable type classes.
 
/*
Inputable/Outputable facilitate:
a. providing the arguments to a CAL function as Java values.
b. interpreting the result of a CAL function as a Java value.
c. combining a and b to provide the arguments for, and then interpret the result of, a CAL function using Java.
*/

/**
The {@link Inputable@} type class provides a way to create a CAL value from a corresponding external Java value via
its single {@link input@} class method.
 
Instances of {@link Inputable@} should comment on what the representation of the CAL value in Java is.
For example, when inputting {@code 2 :: Int@} you need to provide a Java value which is a {@code java.lang.Integer@} holding
the Java {@code int@} value 2. When inputting the list {@code [1 :: Int, 2, 3]@}, one way is to provide a {@code java.lang.List@} having size
3, with each element being a {@code java.lang.Integer@}.

{@link Outputable@} and {@link Inputable@} are intended to be inverses of each other. See the documentation of
{@link Outputable@} for more details on what this means.

The {@link Inputable@} type class can be used in {@em deriving@} clauses. For a type with n arguments, {@code T a1 ... an@}, this will
automatically create an instance definition {@code instance (Inputable a1, Inputable a2, ..., Inputable an) => Inputable (T a1 ... an) where ...@} using a
canonical boilerplate definition for the {@link input@} instance method. Although convenient, deriving an instance of Inputable
to a certain extent exposes the implementation details of the instance type. Thus, care must be taken to ensure that it is indeed
an appropriate thing to do. Derived instances of {@link Inputable@} work well with derived instances of {@link Outputable@}.

When T is an algebraic type, the derived {@code input@} class method inputs a value from a Java object of Java type 
{@code org.openquark.cal.foreignsupport.module.Prelude.AlgebraicValue@}. This value holds onto the name and ordinal of the
data constructor to be input, as well as all the field values of the data constructor to be input, in the order in which the
fields are declared within the definition of the data constructor. Calling {@link input@} then creates the corresponding CAL data constructor
and calls the {@link input@} class method on each of the field values in the AlgebraicValue to initialize the field values of the CAL value.
In general, deriving an instance of {@link Inputable@} for an algebraic type is mainly intended for prototyping code and non-performance
intense code. This is because marshaling from the Java class AlgebraicValue exposes the names and ordinals of the data constructors of
the type, which breaks the encapsulation of the type. Moreover, such a marshaling is likely not a very efficient Java representation,
nor the most convenient for Java clients to use.

When T is a foreign type whose underlying implementation type is a Java object type, the derived {@link input@} class method is
implemented by simply doing a Java cast on the argument object to ensure that it is of the correct implementation type.

When T is a foreign type whose underlying type is a Java primitive type (char, boolean, byte, short, int, long, float, or double),
the derived {@link input@} class method inputs from one of the standard Java primitive wrapper types  (java.lang.Character,
java.lang.Boolean, java.lang.Byte, java.lang.Short, java.lang.Integer, java.lang.Long, java.lang.Float or java.lang.Double 
as appropriate).

Deriving an {@link Inputable@} instance for a foreign type is often quite handy. The main caution is if the foreign type is mutable,
then this can provide a back-hand way for Java clients to mutate values of the type. In that case, a custom instance declaration that
creates a copy of the value can be safer. 
*/
public class Inputable a where
    /**
     * Converts a Java value into a value of the instance type.
     * @arg jobject the JObject to be converted.
     * @return the corresponding value in the instance type.
     */
    public input :: JObject -> a;
    ;

/**
The {@link Outputable@} type class provides a way to convert a CAL value to an appropriate Java value via its
single {@link output@} class method.
 
Instances of {@link Outputable@} should comment on what the representation of the CAL value in Java is.
For example, {@code {@link output@} (2 :: Int)@} produces a {@code java.lang.Integer@} holding the int value 2.
and {@code {@link output@} [1 :: Int, 2, 3]@} produces a {@code java.lang.List@} having size 3, with each element being
a {@code java.lang.Integer@}.
 
The value output should be a complete representation of the CAL value i.e. with enough specific
information to reconstruct the CAL value if necessary.
 
{@link Outputable@} and {@link Inputable@} are intended to be inverses of each other. What this means is that if
we define {@code outThenIn@} by:
{@code
outThenIn :: (Outputable a, {@link Inputable@} a) => a -> a;
outThenIn x = {@link input@} ({@link output@} x);
@}
then for {@code x@}, {@code outThenIn x@} should work, and not produce a runtime error i.e. the Java classes used
by {@link Prelude.input@} and {@link Prelude.output@} for a particular type should be compatible.

If in addition, the type is in the {@link Eq@} type class, the following algebraic law should hold:
For all x, {@code outThenIn x == x@}.

The {@link Outputable@} type class can be used in {@em deriving@} clauses. For a type with n arguments, {@code T a1 ... an@}, this will
automatically create an instance definition {@code instance (Outputable a1, Outputable a2, ..., Outputable an) => Outputable (T a1 ... an) where ...@} using a
canonical boilerplate definition for the {@link output@} instance method. Although convenient, deriving an instance of Outputable
exposes the implementation details of the instance type to a certain extent. Thus, care must be taken to ensure that it is indeed
an appropriate thing to do. Derived instances of {@link Outputable@} work well with derived instances of {@link Inputable@}.

When T is an algebraic type, the derived {@link output@} class method produces a value of Java type 
{@code org.openquark.cal.foreignsupport.module.Prelude.AlgebraicValue@}. This value holds onto the name and ordinal of the
data constructor that was output. It also holds onto the outputted values of the fields of the data constructor. These are produced
by calling the {@link output@} class method on each of the fields of the data constuctor in the order in which they are declared within
the definition of the data constructor. The Java class AlgebraicValue provides methods to query the name and the ordinal of the
data constructor that was output, as well as the outputted values of each of the fields. In general, deriving an instance of
{@link Outputable@} for an algebraic type is mainly intended for prototyping code and non-performance intense code. This is because marshaling
to the Java class AlgebraicValue exposes the names and ordinals of the data constructors of the type, which breaks the encapsulation of
the type. Moreover, such a marshaling is likely not a very efficient Java representation, nor the most convenient for Java
clients to use.

When T is a foreign type whose underlying implementation type is a Java object type, the derived {@link output@} class method is
implemented by simply returning the underlying Java object.

When T is a foreign type whose underlying type is a Java primitive type (char, boolean, byte, short, int, long, float, or double),
the derived {@link output@} class method returns the underlying primitive value wrapped by one of the standard Java
primitive wrapper types (java.lang.Character, java.lang.Boolean, java.lang.Byte, java.lang.Short, java.lang.Integer, java.lang.Long,
java.lang.Float or java.lang.Double as appropriate).

Deriving an {@link Outputable@} instance for a foreign type is often quite handy. The main caution is if the foreign type is mutable,
then this can provide a back-hand way for Java clients to mutate values of the type. In that case, a custom instance declaration that
creates a copy of the value can be safer. 
*/
public class Outputable a where
    /**
     * Converts a value of the instance type into a Java value.
     * @arg value the value to be converted.
     * @return the representation of value as a JObject.
     */
    public output :: a -> JObject;
    ;

///////////////////////////////////////////////////////////////////////////////////////////
//algebraic values

/**
 * This CAL type is primarily for internal use to support derived {@link Inputable@} and {@link Outputable@} instances.
 * 
 * {@link AlgebraicValue@} can be used as a default way of representing values of a CAL data type defined by a non-foreign
 * data declaration in a way that is accessible to Java clients. They are often not the most efficient representation
 * of a value in Java. Note: even though they are not an efficient representation in Java, they are efficient within
 * CAL itself because of the amount of sharing that CAL supports.
 */
data foreign unsafe import jvm public "org.openquark.cal.foreignsupport.module.Prelude.AlgebraicValue"
    public AlgebraicValue deriving Inputable, Outputable;

/**
 * This function is for internal use to support derived {@link Inputable@} and {@link Outputable@} instances.
 * 
 * Constructs a general {@link AlgebraicValue@}.
 * 
 * @arg dataConstructorName the fully-qualified name of the data constructor (that constructs this value
 *                          (eg {@code "Cal.Core.Prelude.Just"@}).
 * @arg dataConstructorOrdinal the ordinal of the data constructor that constructs this value.
 * @arg argumentValues a {@link JList@} of arguments to the data constructor.
 * @return an {@link AlgebraicValue@} that represents the value returned by applying the specified arguments to the
 *         specified data constructor. 
 */
foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.Prelude.AlgebraicValue.makeGeneralAlgebraicValue"
    protected internal_algebraicValue_new :: String -> Int -> JList -> AlgebraicValue;
    
/**
 * This function is for internal use to support derived {@link Inputable@} and {@link Outputable@} instances.
 * 
 * Constructs an {@link AlgebraicValue@} representing a data constructor with no arguments.
 * 
 * @arg dataConstructorName the fully-qualified name of the data constructor (that constructs this value
 *                          (eg {@code "Cal.Core.Prelude.Just"@}).
 * @arg dataConstructorOrdinal the ordinal of the data constructor that constructs this value.
 * @return an {@link AlgebraicValue@} that represents the value returned by the specified data constructor. 
 */
foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.Prelude.AlgebraicValue.makeZeroArgumentAlgebraicValue"
    protected internal_algebraicValue_new0 :: String -> Int -> AlgebraicValue;
    
/**
 * This function is for internal use to support derived {@link Inputable@} and {@link Outputable@} instances.
 * 
 * Constructs an {@link AlgebraicValue@} representing a data constructor with a single argument.
 * 
 * @arg dataConstructorName the fully-qualified name of the data constructor (that constructs this value (eg {@code "Cal.Core.Prelude.Just"@}).
 * @arg dataConstructorOrdinal the ordinal of the data constructor that constructs this value.
 * @arg argumentValue the single argument to the data constructor.
 * @return an {@link AlgebraicValue@} that represents the value returned by applying the specified argument to the
 *         specified data constructor. 
 */
foreign unsafe import jvm "static method org.openquark.cal.foreignsupport.module.Prelude.AlgebraicValue.makeSingleArgumentAlgebraicValue"
    protected internal_algebraicValue_new1 :: String -> Int -> JObject -> AlgebraicValue;
    
/**
 * This function is for internal use to support derived {@link Inputable@} and {@link Outputable@} instances.
 * 
 * Returns the name of the data constructor corresponding to the {@link AlgebraicValue@} expanded to a string.
 * 
 * @arg algebraicValue the {@link AlgebraicValue@}.
 * @return the name of the data constructor.
 */
foreign unsafe import jvm "method getDataConstructorName"
    protected internal_algebraicValue_getDataConstructorName :: AlgebraicValue -> String;
    
/**
 * This function is for internal use to support derived {@link Inputable@} and {@link Outputable@} instances.
 * 
 * Returns the ordinal of the data constructor corresponding to the {@link AlgebraicValue@}.
 * 
 * @arg algebraicValue the {@link AlgebraicValue@}.
 * @return the ordinal of the data constructor.
 */
foreign unsafe import jvm "method getDataConstructorOrdinal"
    protected internal_algebraicValue_getDataConstructorOrdinal :: AlgebraicValue -> Int;
    
/**
 * This function is for internal use to support derived {@link Inputable@} and {@link Outputable@} instances.
 * 
 * Returns the number of arguments that the data constructor represented by the {@link AlgebraicValue@} is holding.
 * 
 * @arg algebraicValue the {@link AlgebraicValue@}.
 * @return the number of arguments that the data constructor is holding.
 */
foreign unsafe import jvm "method getNArguments"
    protected internal_algebraicValue_getNArguments :: AlgebraicValue -> Int;
    
/**
 * This function is for internal use to support derived {@link Inputable@} and {@link Outputable@} instances.
 * 
 * Returns the argument value corresponding to the argNth argument held by the data constructor represented by the
 * {@link AlgebraicValue@}.
 * 
 * @arg algebraicValue the {@link AlgebraicValue@}.
 * @arg argN the zero-based index to an argument held by the data constructor represented by the {@link AlgebraicValue@}.
 * @return the argument value corresponding to the argNth argument.
 */    
foreign unsafe import jvm "method getNthArgument"
    protected internal_algebraicValue_getNthArgument :: AlgebraicValue -> Int -> JObject;    
   
 
//Handle helper functions for Inputable and Outputable instances for the types: 
//Char, Boolean, Byte, Short, Int, Long, Float, Double, Unit and String

//Char
    
data foreign unsafe import jvm "java.lang.Character"
    private JChar deriving Outputable;

/**
 * Used to implement the {@link output@} instance function for derived instances of
 * {@link Outputable@} for foreign types having implementation type "char".
 */
foreign unsafe import jvm "static method java.lang.Character.valueOf"
    private outputChar :: Char -> JChar;
  
/**
 * Used to implement the {@link input@} instance function for derived instances of
 * {@link Inputable@} for foreign types having implementation type "char".
 * If the argument is not actually a {@code java.lang.Character@}, then we get a class-cast exception at runtime. 
 */    
foreign unsafe import jvm "static method org.openquark.cal.internal.foreignsupport.module.Prelude.Cast.objectToChar"
    private inputChar :: JObject -> Char; 

//Boolean

/**
 * Outputs to an object of Java type {@code java.lang.Boolean@}.
 */
instance Outputable Boolean where
    output = outputBooleanToJObject;
    ;
  
/**
 * Inputs from an object of Java type {@code java.lang.Boolean@}.
 */
instance Inputable Boolean where
    input = inputBoolean;
    ;
    
data foreign unsafe import jvm "java.lang.Boolean"
    private JBoolean deriving Outputable;

/**
 * Used to implement the {@link output@} instance function for derived instances of
 * {@link Outputable@} for foreign types having implementation type "boolean".
 */
foreign unsafe import jvm "static method java.lang.Boolean.valueOf"
    private outputBoolean :: Boolean -> JBoolean;

//outputBooleanToJObject will be an alias of outputBoolean so will incur no runtime penalty.   
outputBooleanToJObject :: Boolean -> JObject;
private outputBooleanToJObject !booleanValue = output (outputBoolean booleanValue);    

/**
 * Used to implement the {@link input@} instance function for derived instances of
 * {@link Inputable@} for foreign types having implementation type "boolean".
 * If the argument is not actually a {@code java.lang.Boolean@}, then we get a class-cast exception at runtime. 
 */
foreign unsafe import jvm "static method org.openquark.cal.internal.foreignsupport.module.Prelude.Cast.objectToBoolean"
    private inputBoolean :: JObject -> Boolean;    


//Byte 
        
data foreign unsafe import jvm "java.lang.Byte" private JByte deriving Outputable;

/**
 * Used to implement the {@link output@} instance function for derived instances of
 * {@link Outputable@} for foreign types having implementation type "byte".
 */
foreign unsafe import jvm "static method java.lang.Byte.valueOf"
    private outputByte :: Byte -> JByte;

/**
 * Used to implement the {@link input@} instance function for derived instances of
 * {@link Inputable@} for foreign types having implementation type "byte".
 * If the argument is not actually a {@code java.lang.Byte@}, then we get a class-cast exception at runtime. 
 */    
foreign unsafe import jvm "static method org.openquark.cal.internal.foreignsupport.module.Prelude.Cast.objectToByte"
    private inputByte :: JObject -> Byte;    

//Short
    
data foreign unsafe import jvm "java.lang.Short" private JShort deriving Outputable;

/**
 * Used to implement the {@link output@} instance function for derived instances of
 * {@link Outputable@} for foreign types having implementation type "short".
 */
foreign unsafe import jvm "static method java.lang.Short.valueOf"
    private outputShort :: Short -> JShort;

/**
 * Used to implement the {@link input@} instance function for derived instances of
 * {@link Inputable@} for foreign types having implementation type "short".
 * If the argument is not actually a {@code java.lang.Short@}, then we get a class-cast exception at runtime. 
 */      
foreign unsafe import jvm "static method org.openquark.cal.internal.foreignsupport.module.Prelude.Cast.objectToShort"
    private inputShort :: JObject -> Short;    

//Int
    
data foreign unsafe import jvm "java.lang.Integer" private JInt deriving Outputable;

/**
 * Used to implement the {@link output@} instance function for derived instances of
 * {@link Outputable@} for foreign types having implementation type "int".
 */
foreign unsafe import jvm "static method java.lang.Integer.valueOf"
    private outputInt :: Int -> JInt;

/**
 * Used to implement the {@link input@} instance function for derived instances of
 * {@link Inputable@} for foreign types having implementation type "int".
 * If the argument is not actually a {@code java.lang.Integer@}, then we get a class-cast exception at runtime. 
 */     
foreign unsafe import jvm "static method org.openquark.cal.internal.foreignsupport.module.Prelude.Cast.objectToInt"
    private inputInt :: JObject -> Int;    

//Long
    
data foreign unsafe import jvm "java.lang.Long" private JLong deriving Outputable;

/**
 * Used to implement the {@link output@} instance function for derived instances of
 * {@link Outputable@} for foreign types having implementation type "long".
 */
foreign unsafe import jvm "static method java.lang.Long.valueOf"
    private outputLong :: Long -> JLong;    
 
/**
 * Used to implement the {@link input@} instance function for derived instances of
 * {@link Inputable@} for foreign types having implementation type "long". 
 * If the argument is not actually a {@code java.lang.Long@}, then we get a class-cast exception at runtime. 
 */      
foreign unsafe import jvm "static method org.openquark.cal.internal.foreignsupport.module.Prelude.Cast.objectToLong"
    private inputLong :: JObject -> Long;    

//Float
    
data foreign unsafe import jvm "java.lang.Float" private JFloat deriving Outputable;

/**
 * Used to implement the {@link output@} instance function for derived instances of
 * {@link Outputable@} for foreign types having implementation type "float".
 */
foreign unsafe import jvm "constructor"
    private outputFloat :: Float -> JFloat;
 
/**
 * Used to implement the {@link input@} instance function for derived instances of
 * {@link Inputable@} for foreign types having implementation type "float".
 * If the argument is not actually a {@code java.lang.Float@}, then we get a class-cast exception at runtime. 
 */     
foreign unsafe import jvm "static method org.openquark.cal.internal.foreignsupport.module.Prelude.Cast.objectToFloat"
    private inputFloat :: JObject -> Float;    

//Double
    
data foreign unsafe import jvm "java.lang.Double" private JDouble deriving Outputable;

/**
 * Used to implement the {@link output@} instance function for derived instances of
 * {@link Outputable@} for foreign types having implementation type "double".
 */
foreign unsafe import jvm "constructor"
    private outputDouble :: Double -> JDouble; 
 
/**
 * Used to implement the {@link input@} instance function for derived instances of
 * {@link Inputable@} for foreign types having implementation type "double". 
 * If the argument is not actually a {@code java.lang.Double@}, then we get a class-cast exception at runtime. 
 */     
foreign unsafe import jvm "static method org.openquark.cal.internal.foreignsupport.module.Prelude.Cast.objectToDouble"
    private inputDouble :: JObject -> Double;    

//Unit

/**
 * Inputs from an object of Java type {@code org.openquark.cal.foreignsupport.module.Prelude.UnitValue@}, 
 * which is a convenient and efficient Java representation for values of the {@link typeConstructor = Unit@} type.
 */    
instance Inputable () where
    input = inputUnit;
    ;
 
/**
 * Outputs to an object of Java type {@code org.openquark.cal.foreignsupport.module.Prelude.UnitValue@}, 
 * which is a convenient and efficient Java representation for values of the {@link typeConstructor = Unit@} type.
 */  
instance Outputable () where
    output = outputUnit;
    ;
    
inputUnit :: JObject -> ();
private inputUnit !value =
    //this will do a down cast from JObject to JUnit, so we will get a failure if the input value is not appropriate.
    (input value :: JUnitValue)
    `seq`
    ();

outputUnit :: () -> JObject;
private outputUnit !value = output unitValue_UNIT;
    
data foreign unsafe import jvm "org.openquark.cal.foreignsupport.module.Prelude.UnitValue"
    private JUnitValue deriving Inputable, Outputable;

foreign unsafe import jvm "static field org.openquark.cal.foreignsupport.module.Prelude.UnitValue.UNIT"
    private unitValue_UNIT :: JUnitValue;

    
//String
    
foreign unsafe import jvm "cast"
    private inputStringFromJObject :: JObject -> String;    

//List

/**
 * Inputs a CAL list from a Java object of type {@code java.util.Collection@}, {@code java.util.Iterator@}, 
 * {@code java.util.Enumeration@} or a Java array (can be a primitive array or a reference array). 
 * 
 * For example, in the case of {@code java.util.Collection@}, {@link input@} is called on each element of the {@code java.util.Collection@}
 * in the order specified by the iterator on the collection returned by {@code java.util.Collection.iterator()@}.
 * 
 * As another example, to input a CAL value of type {@code [Double]@}, it is possible to use:
 * {@unorderedList
 *    {@item a {@code java.util.List@} of {@code java.lang.Double@} objects. 
 *           This works since {@code java.util.List@} is a subtype of {@code java.util.Collection@}.@}
 *    {@item a Java iterator, such that calls to the {@code next()@} method return values of Java type {@code java.lang.Double@}@}
 *    {@item a primitive array of Java type {@code double[]@}. The primitive {@code double@} is automatically boxed to a {@code java.lang.Double@}
 *            before applying {@link input@}.@}
 *    {@item a reference array of Java type {@code java.lang.Double[]@}@}
 * @}
 */
instance Inputable a => Inputable [a] where
    input = inputListFromJObject;
    ;
    
inputListFromJObject :: Inputable a => JObject -> [a];
private inputListFromJObject !object =
    
    if isJCollection object then
        listFromJCollection (input object)
        
    else if isJIterator object then
        listFromJIterator (input object)
        
    else if isJavaArray object then
        listFromJIterator (javaArrayToJIterator object)
        
    else if isJEnumeration object then
        listFromJIterator (jEnumerationToJIterator (input object))
        
    else
        error "Expecting a Java object of type java.util.Collection, java.util.Iterator, java.util.Enumeration or a Java array.";

/**
 * A CAL foreign type corresponding to the Java type {@code java.util.Collection@}.
 */
data foreign unsafe import jvm public "java.util.Collection"
    public JCollection deriving Inputable, Outputable;

foreign unsafe import jvm "instanceof java.util.Collection"
    private isJCollection :: JObject -> Boolean;


/**
 * Converts a Java collection to a CAL list.
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Collections.List.fromJCollection"@}.
 * 
 * @arg collection the Java collection.
 * @return the corresponding CAL list.
 */
listFromJCollection :: Inputable a => JCollection -> [a];
protected listFromJCollection !collection = listFromJCollectionWith collection input;
   
/**
 * Converts a Java collection to a CAL list using the element mapping function {@code f@} of type {@code {@link JObject@} -> a@} 
 * to convert elements of the Java list.
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Collections.List.fromJCollectionWith"@}.
 * 
 * @arg javaCollection the Java collection.
 * @arg elementMappingFunction the mapping function converting elements of the Java list to CAL values.
 * @return the corresponding CAL list. 
 */
listFromJCollectionWith :: JCollection -> (JObject -> a) -> [a];
protected listFromJCollectionWith !javaCollection elementMappingFunction =    
    //We use an iterator to traverse javaCollection so that performance will be good for non-random access lists
    //such as java.util.LinkedList. Note that testing showed that handling lists that implement the 
    //java.util.RandomAccess interface separately using "get" based traversal does not improve performance.
    listFromJIteratorWith (collection_iterator javaCollection) elementMappingFunction;


/**
 * Converts a Java iterator to a CAL list.
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Collections.List.fromJIterator"@}.
 * 
 * @arg iterator the Java iterator
 * @return the corresponding CAL list.
 */
listFromJIterator :: Inputable a => JIterator -> [a];
protected listFromJIterator !iterator = listFromJIteratorWith iterator input;


/**
 * Converts a Java iterator to a CAL list using the element mapping function {@code f@} of 
 * type {@code {@link JObject@} -> a@} to convert iteration elements.
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Collections.List.fromJIteratorWith"@}.
 * 
 * @arg iterator the Java iterator
 * @arg elementMappingFunction the mapping function converting iteration elements to CAL values.
 * @return the corresponding CAL list.
 */
listFromJIteratorWith :: JIterator -> (JObject -> a) -> [a];
protected listFromJIteratorWith !iterator elementMappingFunction =   
    if iterator_hasNext iterator then
        //the call to eager is necessary to force the iterator to advance. Alternatively, this could be handled
        //using the seq function.
        elementMappingFunction (eager (iterator_next iterator)) : listFromJIteratorWith iterator elementMappingFunction
    else
        [];
    
data foreign unsafe import jvm "java.util.Iterator"
    private JIterator deriving Inputable, Outputable;

foreign unsafe import jvm "method iterator"
    private collection_iterator :: JCollection -> JIterator;
    
foreign unsafe import jvm "method hasNext"
    private iterator_hasNext :: JIterator -> Boolean;
    
foreign unsafe import jvm "method next"
    private iterator_next :: JIterator -> JObject;

foreign unsafe import jvm "instanceof java.util.Iterator"
    private isJIterator :: JObject -> Boolean;


    
data foreign unsafe import jvm "java.util.Enumeration"
    private JEnumeration deriving Inputable, Outputable;

foreign unsafe import jvm "instanceof java.util.Enumeration"
    private isJEnumeration :: JObject -> Boolean;

foreign unsafe import jvm "static method org.openquark.cal.internal.foreignsupport.module.Prelude.PreludeSupport.enumerationToIterator"
    private jEnumerationToJIterator :: JEnumeration -> JIterator;


foreign unsafe import jvm "static method org.openquark.cal.internal.foreignsupport.module.Prelude.PreludeSupport.isArray"
    private isJavaArray :: JObject -> Boolean;

foreign unsafe import jvm "static method org.openquark.cal.internal.foreignsupport.module.Prelude.PreludeSupport.arrayToIterator"
    private javaArrayToJIterator :: JObject -> JIterator;



/**
 * The {@link output@} class method on CAL lists outputs to a {@code java.util.List@} value. The {@code java.util.List@} is guaranteed to
 * implement the Java interfaces {@code java.util.RandomAccess@} and {@code java.io.Serializable@} as well as to
 * be modifiable. However, the list is not in general extendable (i.e. supporting the add and remove methods
 * of {@code java.util.List@}).
*/    
instance Outputable a => Outputable [a] where
    output = outputListToJObject;
    ;

//will be an alias of outputList    
outputListToJObject :: Outputable a => [a] -> JObject;    
private outputListToJObject !list = output (outputList list);

/**
 * Converts a CAL list to a Java list.
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Collections.List.outputList"@}.
 * 
 * @arg list the CAL list.
 * @return the corresponding Java list.
 */
outputList :: Outputable a => [a] -> JList;
protected outputList !list = outputListWith list output;

/**
 * Converts a CAL list to a Java list using the element mapping function {@code f@} of type {@code a -> {@link JObject@}@} 
 * to convert elements of the CAL list.
 * 
 * This function is defined in the {@link Prelude@} module for implementation purposes only. 
 * The public api version is {@link "Cal.Collections.List.outputListWith"@}.
 * 
 * @arg list the CAL list.
 * @arg f the mapping function converting elements of the list to {@link JObject@} values.
 * @return the corresponding {@link JList@}.
 */
//implementation note: for lists of length > 7, the resulting list is in fact a java.util.ArrayList. For lists of
//shorter length, more efficient fixed length Java lists are used. These are more efficient in both space and time
//requirements.
outputListWith :: [a] -> (a -> JObject) -> JList;
protected outputListWith !list f =
    
    case list of
    [] -> jList0;
    x0 : list0 ->  
    
    case list0 of
    [] -> jList1 (f x0);
    x1 : list1 ->
    
    case list1 of           
    [] -> jList2 (f x0) (f x1);
    x2 : list2 ->
    
    case list2 of
    [] -> jList3 (f x0) (f x1) (f x2);
    x3 : list3 ->
    
    case list3 of
    [] -> jList4 (f x0) (f x1) (f x2) (f x3);
    x4 : list4 ->
    
    case list4 of
    [] -> jList5 (f x0) (f x1) (f x2) (f x3) (f x4);
    x5 : list5 ->
    
    case list5 of
    [] -> jList6 (f x0) (f x1) (f x2) (f x3) (f x4) (f x5);
    x6 : list6 ->
    
    case list6 of
    [] -> jList7 (f x0) (f x1) (f x2) (f x3) (f x4) (f x5) (f x6);
    x7 : list7 ->
    
        let  
            javaList :: JList;
            javaList = jArrayList_new;
     
            outputListWithHelper :: [a] -> (a -> JObject) -> JList -> JList;    
            outputListWithHelper !list elementMappingFunction !javaList =
                case list of
                [] -> javaList;
                x : xs -> 
                    jList_add javaList (elementMappingFunction x)
                    `seq`
                    outputListWithHelper xs elementMappingFunction javaList;                     
                ;
        in  
            (jList_add javaList (f x0))
            `seq`
            (jList_add javaList (f x1))
            `seq`
            (jList_add javaList (f x2))
            `seq`
            (jList_add javaList (f x3))
            `seq`
            (jList_add javaList (f x4))
            `seq`
            (jList_add javaList (f x5))
            `seq`
            (jList_add javaList (f x6))
            `seq`
            (jList_add javaList (f x7))
            `seq`
            outputListWithHelper list7 f javaList;;;;;;;;;    
                                       
foreign unsafe import jvm "static field java.util.Collections.EMPTY_LIST"
    private jList0 :: JList;
foreign unsafe import jvm "static method org.openquark.cal.util.FixedSizeList.make"
    private jList1 :: JObject -> JList;
foreign unsafe import jvm "static method org.openquark.cal.util.FixedSizeList.make"
    private jList2 :: JObject -> JObject -> JList;
foreign unsafe import jvm "static method org.openquark.cal.util.FixedSizeList.make"
    private jList3 :: JObject -> JObject -> JObject -> JList;
foreign unsafe import jvm "static method org.openquark.cal.util.FixedSizeList.make"
    private jList4 :: JObject -> JObject -> JObject -> JObject -> JList;
foreign unsafe import jvm "static method org.openquark.cal.util.FixedSizeList.make"
    private jList5 :: JObject -> JObject -> JObject -> JObject -> JObject -> JList;
foreign unsafe import jvm "static method org.openquark.cal.util.FixedSizeList.make"
    private jList6 :: JObject -> JObject -> JObject -> JObject -> JObject -> JObject -> JList;
foreign unsafe import jvm "static method org.openquark.cal.util.FixedSizeList.make"
    private jList7 :: JObject -> JObject -> JObject -> JObject -> JObject -> JObject -> JObject -> JList;
                             
foreign unsafe import jvm "constructor java.util.ArrayList" private jArrayList_new :: JList;
foreign unsafe import jvm "method add" private jList_add :: JList -> JObject -> Boolean;


//Records 

//////////////////////////////////////////////////////////////////////
// Additional Prelude functions

/**
 * Exposes the functionality of "if-then-else" as a function.
 * {@link iff@} can be thought of as the function form of the "if-the-else" construct.
 * 
 * @arg condition the condition to test.
 * @arg trueValue the value to return if the condition holds.
 * @arg falseValue the value to return if the condition does not hold.
 * @return {@code trueValue@} if {@code condition@} evaluates to {@link True@}, otherwise {@code falseValue@}.
 */
iff :: Boolean -> a -> a -> a;
public iff !condition trueValue falseValue =
    if condition then
        trueValue
    else
        falseValue;

/**
 * The {@link error@} function will cause execution to stop immediately. An exception will be thrown.
 * The exception contains the error message string. In addition, the exception
 * will contain an error information object that has information about the position in the
 * source code of the error call.
 * 
 * @arg message A message that will be shown as part of the error message.
 * @return The return value is bottom.
 * @see assert, undefined
 */
primitive public error :: String -> a;

/**
 * {@link assert@} evaluates the given expression. If the expresion equals {@link True@} then the return value 
 * will be {@link True@}. If the expression equals {@link False@} then the execution will stop. An exception will
 * be thrown. The exception contains the error message string. In addition, the exception
 * will contain an error information object that has information about the position in the 
 * source code of the {@link assert@} call. Note, this is not the position of the {@link error@} call in the 
 * {@link assert@} function body.
 *  
 * @arg expr An expression that evaluates to a {@link Boolean@} value.
 * @return The return value will be {@link True@} iff {@code expr@} evaluates to {@link True@}. Otherwise the return value
 *         is {@em bottom@}.
 * @see undefined, error
 */
assert :: Boolean -> Boolean;
public assert !expr = 
    expr || error "Assert failed";

/**
 * The {@link undefined@} function will cause execution to stop immediately. An exception will be thrown.
 * The exception contains the error message string. In addition, the exception
 * will contain an error information object that has information about the position in the
 * source code of the undefined call. Note, this is not the position of the {@link error@} call
 * in the undefined function body.
 * 
 * @return The return value is {@em bottom@}.
 * @see error, assert
 */
undefined :: a;
public undefined =
    error "Undefined called.";

//////////////////////////////////////////////////////////////////////
// Proposed prelude functions
// this is a good place to put functions that you want to propose for
// eventual formal inclusion in the Prelude.
// Your function should be debugged before being included here!

/**
 * Reverses the order of a comparator (also known as a comparison function) so the
 * comparisons that result in {@link LT@} become {@link GT@} and those that result in {@link GT@} become {@link LT@}.
 * 
 * @arg comparator the comparison function to be reversed.
 * @arg x the first argument to the reversed comparator.
 * @arg y the second argument to the reversed comparator.
 * @return the result of applying the reversed comparison function.
 */
reverseComparator :: (a -> a -> Ordering) -> (a -> a -> Ordering);
public reverseComparator !comparator !x !y =
    case comparator x y of
    LT -> GT;
    EQ -> EQ;
    GT -> LT;
    ;

/**
 * Combines two comparators to form a new comparator. First comparison is done with {@code comparator1@}.
 * If {@code comparator1@} returns {@link EQ@} then the comparison is done with {@code comparator2@}.
 * 
 * @arg comparator1 the main comparator to use for comparison.
 * @arg comparator2 the comparator to use in the event that {@code comparator1@} returns {@link EQ@}.
 * @arg x the first argument to the combined comparator.
 * #arg y the second argument to the combined comparator.
 * @return the result of comparing {@code x@} and {@code y@} using the combined comparator.
 */    
combineComparators :: (a -> a -> Ordering) -> (a -> a -> Ordering) -> (a -> a -> Ordering);
public combineComparators !comparator1 comparator2 !x !y =
    case comparator1 x y of
    LT -> LT;
    EQ -> comparator2 x y;
    GT -> GT;
    ;
    
/**
 * Converts a comparator to an equality function. 
 * There are a variety of functions in CAL (usually with names ending in "By" such as "groupBy")
 * which take an equality function. Such an equality function can be obtained from a comparator
 * using this function.
 * 
 * @arg comparator the comparison function to be converted.
 * @arg x the first argument to compare for equality.
 * @arg y the second argument to compare for equality.
 * @return {@link True@} if {@code x@} and {@code y@} are equal according to comparator and {@link False@} otherwise.
 */
comparatorToEqualityFunction :: (a -> a -> Ordering) -> (a -> a -> Boolean);
public comparatorToEqualityFunction !comparator !x !y = 
    case comparator x y of
    EQ -> True;
    _  -> False;
    ; 

/**
 * Induces an equality function on a type {@code a@} via projecting to a type {@code b@} and using the {@link Eq@} instance
 * on {@code b@}.
 * 
 * @arg projectionFunction projects the type {@code a@} into the type {@code b@}, where {@link Prelude.equals@} is used for
 *      the comparison.
 * @arg x first argument of the induced equality function.
 * @arg y second argument of the induced equality function.
 * @return the result of applying the induced equality function on {@code x@} and {@code y@}.
 */    
induceEqualityFunction :: Eq b => (a -> b) -> (a -> a -> Boolean);
public induceEqualityFunction !projectionFunction !x !y =
    projectionFunction x == projectionFunction y;

/**
 * Induces an comparator on a type {@code a@} via projecting to a type {@code b@} and using the {@link Ord@} instance on {@code b@}.
 * 
 * @arg projectionFunction projects the type {@code a@} into the type {@code b@}, where {@link Prelude.compare@} is used
 *                         for the comparison.
 * @arg x first argument of the induced comparator.
 * @arg y second argument of the induced comparator.
 * @return the result of applying the induced comparator on {@code x@} and {@code y@}.
 */   
induceComparator :: Ord b => (a -> b) -> (a -> a -> Ordering);
public induceComparator !projectionFunction !x !y =
    compare (projectionFunction x) (projectionFunction y);
    


/** The special not-a-number value for a {@link Double@}. */
foreign unsafe import jvm "static field java.lang.Double.NaN"
    public notANumber :: Double;

/**
 * Checks whether a {@link Double@} value is the special not-a-number value.
 * 
 * @arg doubleValue the Double value to be checked.
 * @return True if doubleValue is the special not-a-number value.
 */
foreign unsafe import jvm "static method java.lang.Double.isNaN"
    public isNotANumber :: Double -> Boolean;

/** The special positive infinity value for a {@link Double@}. */
foreign unsafe import jvm "static field java.lang.Double.POSITIVE_INFINITY" 
    public positiveInfinity :: Double;

/** The special negative infinity value for a {@link Double@}. */
foreign unsafe import jvm "static field java.lang.Double.NEGATIVE_INFINITY"
    public negativeInfinity :: Double;

/**
 * Parses a string representation of an integer value into an {@link Int@} value.
 * 
 * The characters in the string must all be decimal digits, except that the
 * first character may be an ASCII minus sign '-' to indicate a negative value.
 * 
 * @arg stringRep the string representation of an integer value.
 * @return the corresponding {@link Int@} value.
 */
foreign unsafe import jvm "static method java.lang.Integer.parseInt" 
    public stringToInt :: String -> Int;

/**
 * Parses a string representation of an integer value in the specified radix
 * into an {@link Int@} value.
 * 
 * The characters in the string must all be digits of the specified radix,
 * except that the first character may be an ASCII minus sign '-' to indicate a
 * negative value.
 * 
 * @arg stringRep the string representation of an integer value in the specified radix.
 * @arg radix the radix to be used while parsing {@code stringRep@}.
 * @return the corresponding {@link Int@} value.
 */
foreign unsafe import jvm "static method java.lang.Integer.parseInt"
    public stringToIntRadix :: String -> Int -> Int;

/**
 * Parses a string representation of a long integer value into a {@link Long@} value.
 * 
 * The characters in the string must all be decimal digits, except that the
 * first character may be an ASCII minus sign '-' to indicate a negative value.
 * 
 * @arg stringRep the string representation of a long integer value.
 * @return the corresponding {@link Long@} value.
 */
foreign unsafe import jvm "static method java.lang.Long.parseLong" 
    public stringToLong :: String -> Long;

/**
 * Parses a string representation of a long integer value in the specified radix
 * into a {@link Long@} value.
 * 
 * The characters in the string must all be digits of the specified radix,
 * except that the first character may be an ASCII minus sign '-' to indicate a
 * negative value.
 * 
 * @arg stringRep the string representation of a long integer value in the specified radix.
 * @arg radix the radix to be used while parsing {@code stringRep@}.
 * @return the corresponding {@link Long@} value.
 */
foreign unsafe import jvm "static method java.lang.Long.parseLong"
    public stringToLongRadix :: String -> Int -> Long;

/**
 * Parses a string representation of a double value into a {@link Double@} value.
 * 
 * @arg stringRep the string representation of a double value.
 * @return the corresponding {@link Double@} value.
 */
foreign unsafe import jvm "static method java.lang.Double.parseDouble"
    public stringToDouble :: String -> Double;




//////////////////////////////////////////////////////////////////////
// End of CAL standard prelude 



//////////////////////////////////////////////////////////////////////
// Crystal Reports functions


//// Crystal Report's Basic syntax string functions
//

/**
 * Replicates a list for a specified number of times.
 * 
 * @arg list the list.
 * @arg nCopies the number of copies to make.
 * @return a list of {@code nCopies@} of the list concatenated together.
 * @deprecated use {@link "Cal.Collections.List.replicateList"@}
 */
replicateList :: [a] -> Int -> [a];
private replicateList list !nCopies = concat (replicate nCopies list);

data foreign unsafe import jvm "java.lang.StringBuilder"
    private JStringBuilder;
foreign unsafe import jvm "constructor"
    private jStringBuilder_new :: JStringBuilder;
foreign unsafe import jvm "method append"
    private jStringBuilder_append2 :: JStringBuilder -> String -> JStringBuilder;
foreign unsafe import jvm "method append"
    private jStringBuilder_append :: JStringBuilder -> Char -> JStringBuilder;
foreign unsafe import jvm "method toString"
    jStringBuilder_toString :: JStringBuilder -> String;

// Foreign functions to allow appending different types to a string.
/**
 * Converts a {@link Double@} value to its string representation.
 * 
 * @arg value the {@link Double@} value.
 * @return the string representation.
 */
foreign unsafe import jvm "static method java.lang.Double.toString"
    public doubleToString :: Double -> String;

/**
 * Converts a {@link Integer@} value to its string representation.
 * 
 * @arg value the {@link Integer@} value.
 * @return the string representation.
 */
foreign unsafe import jvm "static method java.lang.Integer.toString"
    public intToString :: Int -> String;

/**
 * Converts a {@link Long@} value to its string representation.
 * 
 * @arg value the {@link Long@} value.
 * @return the string representation.
 */
foreign unsafe import jvm "static method java.lang.Long.toString"
   public longToString :: Long -> String;


/**
 * A CAL foreign type corresponding to the Java type {@code java.util.List@}.
 */
data foreign unsafe import jvm public "java.util.List"
   public JList deriving Inputable, Outputable;
         

//////////////////////////////////////////////////////////////////////
// End of Crystal Reports functions

/**
 * {@link unsafeCoerce@} is equivalent to the identity function operationally.
 * It is an unsafe function because it circumvents the type system and is intended as a compiler
 * hook to implement certain safe functions. Use with extreme caution!
 * 
 * It is only safe to use {@link unsafeCoerce@} when you know what the actual type of a value is, and
 * want to convey this information to the CAL compiler. Note: {@link unsafeCoerce@} coerces the compiler, it does
 * not do anything to the value. In particular, {@link unsafeCoerce@} cannot be used to "cast" a value to a type
 * that it actually is not, even for innocuous seeming casts as from {@link Short@} to {@link Int@}.
 * 
 * To perform a Java upcast between two foreign Java reference types, use foreign "cast" function, or
 * the {@link output@} function. Do not use {@link unsafeCoerce@} for this purpose since it will interfere
 * with compiler optimizations.
 * 
 * @arg value the value to coerce into another type.
 * @return the value in the coerced type.
 */
primitive public unsafeCoerce :: a -> b;

/**
The {@link Typeable@} type class is primarily intended to support working with types at runtime, for example,
via the use of the {@link typeConstructor = "Cal.Core.Dynamic.Dynamic"@} type. The {@link typeConstructor = "Cal.Core.Dynamic.Dynamic"@} type supports
type-discovery of CAL values at runtime in a completely safe way.

Almost every type defined in CAL is automatically made an instance of {@link Typeable@} by the compiler.
For example, for the {@link Int@} type, there is an instance {@code 
instance Typeable Int where ...
@}

For polymorphic types, the instance is a constrained instance. For example, for the {@link Either@} type it is 
{@code instance (Typeable a, Typeable b) => Typeable (Either a b) where ...@} and for the List type it is 
{@code instance (Typeable a) => Typeable [a] where ...@}

The only types that are not instances of Typeable are parametric types having a type variable that does not have kind *.
These are extremely rare in practice.
*/ 
public class Typeable a where
    /**
     * Returns the {@link TypeRep@} value representing the type of the argument.
     * 
     * @arg value the value whose type is to be returned as a {@link TypeRep@} value.
     * @return the {@link TypeRep@} value representing the type of the argument.
     */
    public typeOf :: a -> TypeRep;
    ;

// Checks the new special case data constructors
/* @example */
typeOfExamples :: Boolean;
typeOfExamples =    
    assert (typeOf 'C' == CharTypeRep) &&
    assert (typeOf "Str" == StringTypeRep) &&
    assert (typeOf (1 :: Int) == IntTypeRep) &&
    assert (typeOf 1.0 == DoubleTypeRep) &&
    assert (typeOf False == BooleanTypeRep) &&
    assert (typeOf (intToByte 1) == ByteTypeRep) &&
    assert (typeOf (intToShort 1) == ShortTypeRep) &&
    assert (typeOf minBoundLong == LongTypeRep) &&
    assert (typeOf (doubleToFloat 1.0) == FloatTypeRep) &&
    assert (typeOf EQ == AlgebraicTypeRep "Cal.Core.Prelude.Ordering" (listToTypeReps [])) &&
    assert (typeOf (1 :: Integer) == ForeignTypeRep "Cal.Core.Prelude.Integer" (executionContext_getForeignClass executionContext "Cal.Core.Prelude.Integer" "java.math.BigInteger")) &&
    assert (typeOf (Just "this") == AlgebraicTypeRep "Cal.Core.Prelude.Maybe" (listToTypeReps [StringTypeRep])) &&
    assert (typeOf (Left 'c' :: Either Char String) == AlgebraicTypeRep "Cal.Core.Prelude.Either" (listToTypeReps [CharTypeRep, StringTypeRep])) &&
    assert (isRecordType (typeOf {})) &&
    assert (typeOf {} == typeOf (undefined :: {})) &&
    assert (isRecordType (typeOf ('c', 45.0, "str", 'd'))) &&
    assert (typeOf ('c', 45.0, "str", 'd') == typeOf (undefined :: (Char, Double, String, Char))) &&
    assert (isRecordType (typeOf {#1='c', #2="str", x=10.0, y=(1::Int)})) &&
    assert (typeOf {#1='c', #2="str", x=10.0, y=(1::Int)} == typeOf (undefined :: {#1 :: Char, #2 :: String, x :: Double, y :: Int})) &&
    assert (isRecordType (typeOf {#3='c', #5=10.0, #9999="str"})) &&
    assert (typeOf {#3='c', #5=10.0, #9999="str"} == typeOf (undefined :: {#3 :: Char, #5 :: Double, #9999 :: String})) &&
    assert (isRecordType (typeOf {#3='c', x="str"})) &&
    assert (typeOf {#3='c', x="str"} == typeOf (undefined :: {#3 :: Char, x :: String}))
    ;
        
    
/**
 * A type used to define a representation of a non-polymorphic CAL type.
 */ 
data public TypeRep =
    /**
     * Used for algebraic type constructors not supported via special TypeRep data constructors.
     * @arg typeConsName root type constructor
     * @arg argTypes type representation of the arguments
     */
    protected AlgebraicTypeRep 
        typeConsName :: !String 
        argTypes :: !TypeRepArray |
    
    /**
     * Used for foreign types i.e. the implementation type is a Java object type or a Java primitive
     * type. Not used for {@link String@}, {@link Char@}, {@link Byte@}, {@link Short@}, {@link Int@},
     * {@link Long@}, {@link Float@} and {@link Double@} which have their own special data constructors
     * even though they are technically foreign types.
     * 
     * @arg typeConsName the name of the foreign type.
     * @arg foreignClass the class corresponding to the foreign type.
     */
    protected ForeignTypeRep
        typeConsName :: !String
        foreignClass :: !JClass |               
    
    /**
     * Used for representing records.
     * @arg dictionary A {@link RecordType@} object that points to a machine-specific {@link Typeable@} dictionary for the 
     *                 record in question.  
     */
    protected RecordTypeRep dictionary :: !RecordType | 
           
    /**
     * Used for the {@link Prelude.Function@} type constructor "->" when fully saturated.
     * @arg domainType
     * @arg codomainType
     */
    protected FunctionTypeRep 
        domainType :: !TypeRep 
        codomainType :: !TypeRep |
    
    /**
     * Used for the {@link Prelude.List@} type constructor when fully saturated.
     * @arg elementType
     */
    protected ListTypeRep 
        elementType :: !TypeRep |    

    /**
     * Used for the {@link typeConstructor = Prelude.Unit@} type constructor.
     * representation of the {@code ()@} type
     */
    protected UnitTypeRep |    
    
    /**
     * Used for the {@link Boolean@} type constructor.
     * representation of the {@link Boolean@} type
     */
    protected BooleanTypeRep |
    
    /**
     * Used for the {@link Prelude.Int@} type constructor.
     * representation of the {@link Int@} type
     */
    protected IntTypeRep |
    
    /**
     * Used for the {@link Prelude.Byte@} type constructor.
     * representation of the {@link Byte@} type
     */
    protected ByteTypeRep |
    
    /**
     * Used for the {@link Prelude.Short@} type constructor.
     * representation of the {@link Short@} type
     */
    protected ShortTypeRep |
    
    /**
     * Used for the {@link Prelude.Long@} type constructor.
     * representation of the {@link Long@} type
     */
    protected LongTypeRep |
    
    /**
     * Used for the {@link Prelude.Float@} type constructor.
     * representation of the {@link Float@} type
     */
    protected FloatTypeRep |
    
    /**
     * Used for the {@link Prelude.Double@} type constructor.
     * representation of the {@link Double@} type
     */
    protected DoubleTypeRep |
    
    /**
     * Used for the {@link Prelude.Char@} type constructor.
     * representation of the {@link Char@} type
     */
    protected CharTypeRep |
    
    /**
     * Used for the {@link Prelude.String@} type constructor.
     * representation of the {@link String@} type
     */
    protected StringTypeRep  
    
    deriving Eq;

data foreign unsafe import jvm "org.openquark.cal.runtime.CalValue[]" 
    private TypeRepArray deriving Inputable, Outputable;

foreign unsafe import jvm "newArray" 
    typeRepArray_new :: Int -> TypeRepArray;

foreign unsafe import jvm "subscriptArray"
    typeRepArray_subscript :: TypeRepArray -> Int -> CalValue;
subscriptTypeReps :: TypeRepArray -> Int -> TypeRep;
subscriptTypeReps !typeReps !index = unsafeFromCalValue (typeRepArray_subscript typeReps index);

foreign unsafe import jvm "updateArray" 
    typeRepArray_update :: TypeRepArray -> Int -> CalValue -> CalValue;
updateTypeReps :: TypeRepArray -> Int -> TypeRep -> TypeRep;
updateTypeReps !typeReps !index !typeRep = unsafeFromCalValue (typeRepArray_update typeReps index (toCalValue typeRep));

foreign unsafe import jvm "lengthArray"
    lengthTypeReps :: TypeRepArray -> Int;

instance Eq TypeRepArray where
    equals = equalsTypeReps;
    notEquals = notEqualsTypeReps;
    ;

equalsTypeReps :: TypeRepArray -> TypeRepArray -> Boolean;
private equalsTypeReps !typeReps1 !typeReps2 =
    let
        len = eager (lengthTypeReps typeReps1);
    in
        if len != lengthTypeReps typeReps2 then
            False
        else
            let
                equalsHelper :: Int -> Boolean;
                equalsHelper !index =
                    if index < len then
                        if subscriptTypeReps typeReps1 index != subscriptTypeReps typeReps2 index then
                            False
                        else
                            equalsHelper (index + 1)
                    else
                        True;
            in
                equalsHelper 0;
    
notEqualsTypeReps :: TypeRepArray -> TypeRepArray -> Boolean; 
private notEqualsTypeReps !typeReps1 !typeReps2 = not (typeReps1 == typeReps2);

listToTypeReps :: [TypeRep] -> TypeRepArray;
private listToTypeReps !typeRepList =
    let
        size = eager (length typeRepList);
        
        typeRepArray = eager (typeRepArray_new size);
        
        toTypeRepsHelper :: [TypeRep] -> Int -> TypeRepArray;
        toTypeRepsHelper !typeRepList !index =            
            case typeRepList of
            typeRep : typeRepListTail ->
                updateTypeReps typeRepArray index typeRep 
                `seq`
                toTypeRepsHelper typeRepListTail (index + 1);
            [] -> typeRepArray;
            ;
    in
        toTypeRepsHelper typeRepList 0; 

typeRepsToList :: TypeRepArray -> [TypeRep];
private typeRepsToList !typeReps =
    let
        size = eager (lengthTypeReps typeReps);
        
        toListHelper :: Int -> [TypeRep];
        toListHelper !index =
            if index >= size then
                [] 
            else 
                (eager (subscriptTypeReps typeReps index)) : (toListHelper (eager (index + 1)));            
    in
        toListHelper 0;
        

data foreign unsafe import jvm protected "java.lang.Class"
    protected JClass deriving Eq, Inputable, Outputable;

foreign unsafe import jvm "method toString"
    class_toString :: JClass -> String;

foreign unsafe import jvm "method isPrimitive"
    class_isPrimitive :: JClass -> Boolean;

foreign unsafe import jvm "class char"
    class_char :: JClass;
foreign unsafe import jvm "class byte"
    class_byte :: JClass;
foreign unsafe import jvm "class short"
    class_short :: JClass;
foreign unsafe import jvm "class int"
    class_int :: JClass;
foreign unsafe import jvm "class long" 
    class_long :: JClass;
foreign unsafe import jvm "class float" 
    class_float :: JClass;
foreign unsafe import jvm "class double"
    class_double :: JClass;
foreign unsafe import jvm "class java.lang.String"
    class_String :: JClass;

/**
 * @arg executionContext
 * @arg typeConsName the fully-qualified type constructor name as a String e.g. "Cal.Core.Prelude.Maybe".
 * @arg foreignName the name of the foreign class as returned by {@code Class.getName()@}.
 * @return the Java class object corresponding to this type for a foreign type. Otherwise null.
 */
foreign unsafe import jvm "method getForeignClass"  
    private executionContext_getForeignClass :: ExecutionContext -> String -> String -> JClass;

/**
 * @arg typeRep
 * @return {@code {@link Just@} javaClass@}, where {@code javaClass@} is the underlying Java class object
 *     of the foreign type, if {@link TypeRep@} represents a non-foreign type. Otherwise {@link Nothing@}. 
 */
foreignClass :: TypeRep -> Maybe JClass;
protected foreignClass !typeRep =
    case typeRep of   
    
    (AlgebraicTypeRep |
     FunctionTypeRep | 
     ListTypeRep |
     UnitTypeRep |     
     BooleanTypeRep |
     RecordTypeRep) {}
         -> Nothing;
    
    ForeignTypeRep {foreignClass} ->
        Just foreignClass;
    
    IntTypeRep -> 
        Just class_int;  
    
    ByteTypeRep ->
        Just class_byte;
    
    ShortTypeRep ->
        Just class_short;
    
    LongTypeRep ->
        Just class_long;
    
    FloatTypeRep ->
        Just class_float;
    
    DoubleTypeRep ->
        Just class_double;
    
    CharTypeRep -> 
        Just class_char;
    
    StringTypeRep -> 
        Just class_String;
    ;             

/**
 * @arg typeRep runtime type representation of a value, typically obtained by calling {@link typeOf@} on a value.
 * @return {@link True@} if the type of the value is a foreign type, that corresponds to a foreign reference
 *   type i.e. not a primitive type such as "int".
 */
isForeignReferenceType :: TypeRep -> Boolean;
protected isForeignReferenceType !typeRep =
    case foreignClass typeRep of
    Nothing -> False;
    Just javaClass -> not (class_isPrimitive javaClass);   
    ;

/* @example */
isForeignReferenceTypeExamples :: Boolean;
isForeignReferenceTypeExamples =
    assert (isForeignReferenceType $ typeOf (1 :: Integer)) &&
    assert (isForeignReferenceType $ typeOf (undefined :: TypeRepArray)) &&
    assert (isForeignReferenceType $ typeOf "Str") &&
    assert (not $ isForeignReferenceType $ typeOf 'C') &&
    assert (not $ isForeignReferenceType $ typeOf (1 :: Int)) &&
    assert (not $ isForeignReferenceType $ typeOf 1.0) &&
    assert (not $ isForeignReferenceType $ typeOf False) &&
    assert (not $ isForeignReferenceType $ typeOf (intToByte 1)) &&
    assert (not $ isForeignReferenceType $ typeOf (intToShort 1)) &&
    assert (not $ isForeignReferenceType $ typeOf minBoundLong) &&
    assert (not $ isForeignReferenceType $ typeOf (doubleToFloat 1.0)) &&
    assert (not $ isForeignReferenceType $ typeOf EQ) &&
    assert (not $ isForeignReferenceType $ typeOf (Just "this")) &&
    assert (not $ isForeignReferenceType $ typeOf (Left 'c' :: Either Char String))
    ;

/**
 * @arg typeRep runtime type representation of a value, typically obtained by calling {@link typeOf@} on a value.
 * @return {@link True@} if the type was declared with a foreign data declaration.
 */
isForeignType :: TypeRep -> Boolean;
isForeignType !typeRep =
    case typeRep of
    (StringTypeRep | ForeignTypeRep) {} -> True;
    _ -> False;
    ;
            

/**
 * Returns {@link True@} if the runtime type representation is that of a {@link List@} and {@link False@} otherwise.
 * For example, the function returns {@link True@} for values of type {@code [Double]@} and {@code [(Char, Double)]@} 
 * but {@link False@} for values of type {@link Double@} and {@code ([Double], Boolean)@}. Note that the type
 * {@code ([Double], Boolean)@} involves a {@link List@} type, but this function looks only at the outermost type,
 * which is a 2-tuple in this case and thus not a {@link List@}.
 * 
 * @arg typeRep runtime type representation of a value, typically obtained by calling {@link typeOf@} on a value.
 * @return {@link True@} if the runtime type representation is that of a {@link List@} and {@link False@} otherwise.
 */
isListType :: TypeRep -> Boolean;
public isListType !typeRep =
    case typeRep of
    ListTypeRep {} -> True;
    _ -> False;
    ;
    
/* @example */
isListTypeExamples :: Boolean;
isListTypeExamples =
    assert (isListType # typeOf $ [2.0, 3.0])
    && assert (isListType # typeOf $ [(True, 2.0)])
    && assert (not # isListType # typeOf $ 4.0)
    && assert (not # isListType # typeOf $ (4.0, "abc"))
    ;
    
/**
 * Returns {@link True@} if the runtime type representation is that of a record type and {@link False@} otherwise.
 * Note that record types include tuple types.
 * 
 * @arg typeRep runtime type representation of a value, typically obtained by calling {@link typeOf@} on a value.
 * @return {@link True@} if the runtime type representation is that of a record or tuple type and {@link False@} otherwise. 
 */
isRecordType :: TypeRep -> Boolean;
public isRecordType !typeRep =
    case typeRep of      
    RecordTypeRep _ -> True;
     _ -> False;
     ;
     
/* @example */
isRecordTypeExamples :: Boolean;
isRecordTypeExamples =
    assert (isRecordType # typeOf $ {})
    && assert (isRecordType # typeOf $ (2.0, "abc"))
    && assert (isRecordType # typeOf $ {(2.0, "abc") | name = "Anton"})
    && assert (isRecordType # typeOf $ {#2 = "abc", #4 = "Anton"})
    && assert (isRecordType # typeOf $ {str = "abc", name = "Anton", food = "apples"})
    && assert (not # isRecordType # typeOf $ [2.0, 3.0])
    && assert (not # isRecordType # typeOf $ Just "oranges")
    ;



/**
 * Returns {@link True@} if the runtime type representation is that of a function type and {@link False@} otherwise.
 * Note that the function type must be fully saturated i.e. {@code Int -> Char@} returns {@link True@} but
 * {@code Function Int@} and {@link typeConstructor = Function@} return {@link False@}.
 * 
 * @arg typeRep runtime type representation of a value, typically obtained by calling {@link typeOf@} on a value.
 * @return {@link True@} if the runtime type representation is that of a function type and {@link False@} otherwise. 
 */
isFunctionType :: TypeRep -> Boolean;
public isFunctionType !typeRep =
    case typeRep of
    FunctionTypeRep {} -> True;
    _ -> False;
    ;
    
/* @example */
isFunctionTypeExamples :: Boolean;
isFunctionTypeExamples =
   assert (isFunctionType # typeOf $ absDouble)
   //note that the type signature to specialize the type of Cons is necessary since otherwise we would get an
   //ambiguous overloading resolution error.
   && assert (isFunctionType # typeOf $ (Cons :: Int -> [Int] -> [Int]))
   //will not work due to the fact that there is no way to resolve the
   //assert (isFunctionType # typeOf $ head)
   && assert (isFunctionType # typeOf $ (add 1.0))
   && assert (not # isFunctionType # typeOf $ "abc")
   && assert (not # isFunctionType #typeOf $ Just absDouble)
   ;
 
/**
 * Returns {@link True@} if the runtime type representation is that of one of the types defined in the Prelude
 * module as instances of the {@link Num@} type class ({@link Byte@}, {@link Short@}, {@link Int@},
 * {@link Long@}, {@link Float@}, {@link Double@}, {@link Integer@}) or {@link Decimal@}
 * and False otherwise.
 * 
 * @arg typeRep runtime type representation of a value, typically obtained by calling {@link typeOf@} on a value.
 * @return {@link True@} if the runtime type representation is one of {@link Byte@}, {@link Short@}, {@link Int@},
 *     {@link Long@}, {@link Float@}, {@link Double@}, {@link Integer@} or {@link Decimal@}
 *     and False otherwise. 
 */
isPreludeNumType :: TypeRep -> Boolean;
public isPreludeNumType !typeRep =
    case typeRep of
   (ByteTypeRep   |
    ShortTypeRep  |
    IntTypeRep    |        
    LongTypeRep   |
    FloatTypeRep  |
    DoubleTypeRep) -> True;
    
    ForeignTypeRep {typeConsName} ->
        typeConsName == "Cal.Core.Prelude.Integer" || typeConsName == "Cal.Core.Prelude.Decimal";                                       
    _ -> False;
    ; 
    
/* @example */
isPreludeNumTypeExamples :: Boolean;
isPreludeNumTypeExamples =
    assert (isPreludeNumType # typeOf $ (10 :: Byte))
    && assert (isPreludeNumType # typeOf $ (11 :: Short))
    && assert (isPreludeNumType # typeOf $ (12 :: Int))
    && assert (isPreludeNumType # typeOf $ (20 :: Long))
    && assert (isPreludeNumType # typeOf $ doubleToFloat 100.5)
    && assert (isPreludeNumType # typeOf $ 123.4)
    && assert (isPreludeNumType # typeOf $ (10000000000000000000000000000000234 :: Integer))
    && assert (isPreludeNumType # typeOf $ (123 :: Decimal))
    && assert (not # isPreludeNumType # typeOf $ 'z');

/**
 * Returns {@link True@} if the runtime type representation is that of the {@link Boolean@} type and {@link False@} otherwise.
 * 
 * @arg typeRep runtime type representation of a value, typically obtained by calling {@link typeOf@} on a value.
 * @return {@link True@} if the runtime type representation is that of the {@link Boolean@} type and {@link False@} otherwise. 
 */
isBooleanType :: TypeRep -> Boolean;
public isBooleanType !typeRep =
    case typeRep of
    BooleanTypeRep -> True;
    _ -> False;
    ;

/**
 * Returns {@link True@} if the runtime type representation is that of the {@link Int@} type and {@link False@} otherwise.
 * 
 * @arg typeRep runtime type representation of a value, typically obtained by calling {@link typeOf@} on a value.
 * @return {@link True@} if the runtime type representation is that of the {@link Int@} type and {@link False@} otherwise. 
 */    
isIntType :: TypeRep -> Boolean;
public isIntType !typeRep =
    case typeRep of
    IntTypeRep -> True;
    _ -> False;
    ;
 
/**
 * Returns {@link True@} if the runtime type representation is that of the {@link Double@} type and {@link False@} otherwise.
 * 
 * @arg typeRep runtime type representation of a value, typically obtained by calling {@link typeOf@} on a value.
 * @return {@link True@} if the runtime type representation is that of the {@link Double@} type and {@link False@} otherwise. 
 */    
isDoubleType :: TypeRep -> Boolean;
public isDoubleType !typeRep =
    case typeRep of
    DoubleTypeRep -> True;
    _ -> False;
    ;
 
/**
 * Returns {@link True@} if the runtime type representation is that of the {@link Char@} type and {@link False@} otherwise.
 * 
 * @arg typeRep runtime type representation of a value, typically obtained by calling {@link typeOf@} on a value.
 * @return {@link True@} if the runtime type representation is that of the {@link Char@} type and {@link False@} otherwise. 
 */    
isCharType :: TypeRep -> Boolean;
public isCharType !typeRep =
    case typeRep of
    CharTypeRep -> True;
    _ -> False;
    ;
 
/**
 * Returns {@link True@} if the runtime type representation is that of the {@link String@} type and {@link False@} otherwise.
 * 
 * @arg typeRep runtime type representation of a value, typically obtained by calling {@link typeOf@} on a value.
 * @return {@link True@} if the runtime type representation is that of the {@link String@} type and {@link False@} otherwise. 
 */    
isStringType :: TypeRep -> Boolean;
public isStringType !typeRep =
    case typeRep of
    StringTypeRep -> True;
    _ -> False;
    ;

/**
 * Returns {@link True@} if the runtime type representation is that of the {@link Maybe@} type and {@link False@} otherwise.
 * For example, it will return {@link True@} for {@code Maybe Char@}, and {@code Maybe Int@} but {@link False@} for
 * {@code [Int]@} and {@code [Maybe Int]@}.
 * 
 * @arg typeRep runtime type representation of a value, typically obtained by calling {@link typeOf@} on a value.
 * @return {@link True@} if the runtime type representation is that of the {@link Maybe@} type and {@link False@} otherwise. 
 */    
isMaybeType :: TypeRep -> Boolean;
public isMaybeType !typeRep =
    case typeRep of
    AlgebraicTypeRep {typeConsName} ->
        typeConsName == "Cal.Core.Prelude.Maybe";
    _ -> False;
    ;
    
/* @example */
isMaybeTypeExamples :: Boolean;
isMaybeTypeExamples =
     assert (isMaybeType # typeOf $ (Just 'a'))
     && assert (isMaybeType # typeOf $ (Nothing :: Maybe Int))
     && assert (not # isMaybeType # typeOf $ [Just 'a'])
     ;
       
/**
 * Returns {@link True@} if the runtime type representation of the root types of the 2 arguments are the same.
 * 
 * For example, the root type of {@link Int@}, {@code Maybe String@}, {@code [Int]@} and {@code Int -> Char@} are
 * {@link Int@}, {@link Maybe@}, {@link List@} and {@link Function@} respectively.
 * 
 * For record type, {@code sameRootType@} returns true if both {@code typeRep1@} and {@code typeRep2@} are record types and they
 * have the exact same fields. 
 *  
 * @arg typeRep1 runtime type representation of a value, typically obtained by calling {@link typeOf@} on a value.
 * @arg typeRep2 runtime type representation of a value, typically obtained by calling {@link typeOf@} on a value.
 * @return {@link True@} if the runtime type representation of {@code typeRep1@} and {@code typeRep2@} have the same root types
 *     and {@link False@} otherwise. 
 */    
sameRootType :: TypeRep -> TypeRep -> Boolean;
public sameRootType !typeRep1 !typeRep2 =
    
    if ordinalValue typeRep1 != ordinalValue typeRep2 then
        False        
    else
        case typeRep1 of
        
        AlgebraicTypeRep {typeConsName} -> typeConsName == typeRep2.AlgebraicTypeRep.typeConsName;            
        ForeignTypeRep {typeConsName} -> typeConsName == typeRep2.ForeignTypeRep.typeConsName;
        RecordTypeRep {dictionary} ->
            recordType_sameFields dictionary typeRep2.RecordTypeRep.dictionary;
        
        FunctionTypeRep {} -> True;                
        ListTypeRep {} -> True;              
        UnitTypeRep -> True;               
        BooleanTypeRep -> True;    
        IntTypeRep -> True;
        ByteTypeRep -> True;    
        ShortTypeRep -> True;
        LongTypeRep -> True;
        FloatTypeRep -> True;
        DoubleTypeRep -> True;
        CharTypeRep -> True;
        StringTypeRep -> True;        
        ; 
        
/* @example */
sameRootTypeExamples :: Boolean;
sameRootTypeExamples =
    assert (sameRootType (typeOf 2.0) (typeOf (undefined :: Double)))
    && assert (sameRootType (typeOf ["abc", "def"]) (typeOf (undefined :: [Int])))
    && assert (sameRootType (typeOf absDouble) (typeOf (undefined :: Char -> Boolean -> Int)))
    && assert (sameRootType (typeOf (undefined :: Maybe Int)) (typeOf (undefined :: Maybe String)))
    && assert (sameRootType (typeOf (undefined :: Either Int Char)) (typeOf (undefined :: Either String Int)))
    && assert (sameRootType (typeOf (undefined :: {})) (typeOf (undefined :: {})))
    && assert (sameRootType (typeOf (undefined :: (Int, Char))) (typeOf (undefined :: (Boolean, [Int]))))
    && assert (sameRootType (typeOf (undefined :: {id :: Int, c :: Char})) (typeOf (undefined :: {id :: Boolean, c :: [Int]})))
    && assert (sameRootType (typeOf (undefined :: {#10 :: Boolean})) (typeOf (undefined :: {#10 :: Int -> Char})))    
    && assert (sameRootType (typeOf (undefined :: {#2 :: Boolean, id :: Int, c :: Char})) (typeOf (undefined :: {#2 :: Int -> Char, id :: Boolean, c :: [Int]})))
    && assert (sameRootType (typeOf (undefined :: {#1 :: Boolean, id :: Int, c :: Char})) (typeOf (undefined :: {#1 :: Char, id :: Boolean, c :: [Int]})))
    ;
 
/**
 * Returns the type arguments of a type representation. For example, for {@link Int@}, {@code Maybe String@}, {@code [Int]@}
 * and {@code Int -> Char@} these are {@code []@}, {@code [String]@}, {@code [Int]@} and {@code [Int, Char]@} respectively.
 * For a record type, it is the list of types of the fields, in field-name order.
 * Intuitively, the type arguments can be thought of as representing everything in the type except for the root type.
 * 
 * @see sameRootType, nTypeArguments
 * @arg typeRep runtime type representation of a value, typically obtained by calling {@link typeOf@} on a value.
 * @return list of type arguments of the type
 */
typeArguments :: TypeRep -> [TypeRep];
public typeArguments !typeRep =
    case typeRep of 
    
    AlgebraicTypeRep {argTypes} -> typeRepsToList argTypes;
    ForeignTypeRep {} -> [];        
    RecordTypeRep dictionary -> recordType_fieldTypes dictionary;
    
    FunctionTypeRep {domainType, codomainType} -> [domainType, codomainType]; 
    ListTypeRep {elementType} -> [elementType];
    UnitTypeRep -> [];            
    BooleanTypeRep -> [];
    IntTypeRep -> [];    
    ByteTypeRep -> [];
    ShortTypeRep -> [];    
    LongTypeRep -> [];
    FloatTypeRep -> [];    
    DoubleTypeRep -> [];
    CharTypeRep -> [];    
    StringTypeRep -> [];   
    ;
    
/* @example */
typeArgumentsExamples :: Boolean;
typeArgumentsExamples =
    assert (typeArguments (typeOf (undefined :: [Double])) ==
        [typeOf (undefined :: Double)])
        
    && assert (typeArguments (typeOf (undefined :: Int -> Char)) == 
        [typeOf (undefined :: Int), typeOf (undefined :: Char)])
    ;
  
/**
 * Returns the number of type arguments. i.e. {@code nTypeArguments typeRep == {@link length@} ({@link typeArguments@} typeRep)@}.
 * 
 * @see typeArguments, sameRootType
 * @arg typeRep runtime type representation of a value, typically obtained by calling {@link typeOf@} on a value.
 * @return the number of type arguments
 */    
nTypeArguments :: TypeRep -> Int;     
public nTypeArguments !typeRep =
    case typeRep of 
    
    AlgebraicTypeRep {argTypes} -> lengthTypeReps argTypes;
    ForeignTypeRep {} -> 0;  
    RecordTypeRep {dictionary} -> recordType_getNFields dictionary;    
    FunctionTypeRep {} -> 2;    
    ListTypeRep {} -> 1;
    UnitTypeRep -> 0;            
    BooleanTypeRep -> 0;
    IntTypeRep -> 0;    
    ByteTypeRep -> 0;
    ShortTypeRep -> 0;    
    LongTypeRep -> 0;
    FloatTypeRep -> 0;    
    DoubleTypeRep -> 0;
    CharTypeRep -> 0;    
    StringTypeRep -> 0;    
    ;

/**
 * Returns the canonical string representation of a {@link TypeRep@} value.
 * 
 * @arg typeRep the {@link TypeRep@} value to be converted into a string.
 * @return the string representation of the {@link TypeRep@} value.
 */
typeRepToString :: TypeRep -> String;
public typeRepToString !typeRep =
    let
        /**
         * Parenthesizes type constructors of positive arity and the function constructor
         * needed so that types like {@code Maybe (Either Int Char)@} and {@code Either (Int -> Char) Boolean@}
         * display correctly.
         */     
        typeRepToStringForArg :: TypeRep -> String;
        typeRepToStringForArg !typeRep =
            case typeRep of
            AlgebraicTypeRep rootType argTypes ->
                if lengthTypeReps argTypes == 0 then
                    typeRepToString typeRep
                else
                    concat ["(", rootType, " ", concat (intersperse " " (map typeRepToStringForArg (typeRepsToList argTypes))), ")"];
                                   
            FunctionTypeRep domainType codomainType ->
                concat ["(", typeRepToStringForDomain domainType, " -> ", typeRepToString codomainType, ")"];
                      
            _ -> typeRepToString typeRep;
            ;
    
        /**
         * Needed so that types like {@code Maybe Char -> Int@} and {@code (Int -> Boolean) -> Char@} display properly.
         */
        typeRepToStringForDomain :: TypeRep -> String;
        typeRepToStringForDomain !typeRep =
            case typeRep of
            FunctionTypeRep domainType codomainType ->
                concat ["(", typeRepToStringForDomain domainType, " -> ", typeRepToString codomainType, ")"];
            
            _ -> typeRepToString typeRep;
            ;
        
        ordinalToFieldName :: Int -> String;
        ordinalToFieldName ordinal =
            "#" ++ intToString ordinal;
    in     
        case typeRep of
        
        AlgebraicTypeRep {typeConsName, argTypes} ->       
            if lengthTypeReps argTypes == 0 then
                typeConsName
            else
                concat [typeConsName, " ", concat (intersperse " " (map typeRepToStringForArg (typeRepsToList argTypes)))];
        
        RecordTypeRep {dictionary} ->
            let
                fieldString :: Int -> String;
                fieldString !n =
                    concat [fieldNameToString (recordType_getNthFieldName dictionary n), " :: ", typeRepToString (recordType_getNthFieldType dictionary n)];
            
                fieldTypeString :: Int -> String;
                fieldTypeString !n =
                    typeRepToString (recordType_getNthFieldType dictionary n);
            in
                if recordType_isTuple2OrMoreRecord dictionary then
                    concat ["(",
                            concat (intersperse ", " (map fieldTypeString (upFromTo 0 (recordType_getNFields dictionary - 1)))),
                            ")"]
                else
                    concat ["{",
                            concat (intersperse ", " (map fieldString (upFromTo 0 (recordType_getNFields dictionary - 1)))),
                            "}"];        
    
        ForeignTypeRep {typeConsName} ->
            typeConsName;
                       
        FunctionTypeRep {domainType, codomainType} ->                         
            concat [typeRepToStringForDomain domainType, " -> ", typeRepToString codomainType];
            
        ListTypeRep {elementType} ->
            concat ["[", typeRepToString elementType, "]"];

        UnitTypeRep ->
            "()";
                 
        BooleanTypeRep ->
            "Cal.Core.Prelude.Boolean";
        
        IntTypeRep ->
            "Cal.Core.Prelude.Int";
        
        ByteTypeRep ->
            "Cal.Core.Prelude.Byte";
        
        ShortTypeRep ->
            "Cal.Core.Prelude.Short";
        
        LongTypeRep ->
            "Cal.Core.Prelude.Long";
        
        FloatTypeRep ->
            "Cal.Core.Prelude.Float";
        
        DoubleTypeRep ->
            "Cal.Core.Prelude.Double";
        
        CharTypeRep ->
            "Cal.Core.Prelude.Char";
        
        StringTypeRep ->
            "Cal.Core.Prelude.String";            
        ;

/* @example */
typeRepToStringExamples :: Boolean;
typeRepToStringExamples =
    assert (typeRepToString (typeOf (undefined :: String -> String -> Ordering)) ==
        "Cal.Core.Prelude.String -> Cal.Core.Prelude.String -> Cal.Core.Prelude.Ordering")
    && assert (typeRepToString (typeOf (undefined :: String -> [Char])) ==
        "Cal.Core.Prelude.String -> [Cal.Core.Prelude.Char]")
    && assert (typeRepToString (typeOf ([2.0, 3.0], (True, LT), (abs :: Double -> Double), abs 2.0)) ==
        "([Cal.Core.Prelude.Double], (Cal.Core.Prelude.Boolean, Cal.Core.Prelude.Ordering), Cal.Core.Prelude.Double -> Cal.Core.Prelude.Double, Cal.Core.Prelude.Double)")
    && assert (typeRepToString (typeOf (let x :: (Int -> Boolean) -> [Int] -> [Int]; x = undefined; in x)) ==
        "(Cal.Core.Prelude.Int -> Cal.Core.Prelude.Boolean) -> [Cal.Core.Prelude.Int] -> [Cal.Core.Prelude.Int]")
    && assert (typeRepToString (typeOf ((), ())) ==
        "((), ())")
    && assert (typeRepToString (typeOf (Just (Just (Just 'a')))) ==
        "Cal.Core.Prelude.Maybe (Cal.Core.Prelude.Maybe (Cal.Core.Prelude.Maybe Cal.Core.Prelude.Char))")
    && assert (typeRepToString (typeOf [Right True, Left (Left (Left 'a')), Left (Right absDouble), Left (Left (Right addInt))]) ==
        "[Cal.Core.Prelude.Either (Cal.Core.Prelude.Either (Cal.Core.Prelude.Either Cal.Core.Prelude.Char (Cal.Core.Prelude.Int -> Cal.Core.Prelude.Int -> Cal.Core.Prelude.Int)) (Cal.Core.Prelude.Double -> Cal.Core.Prelude.Double)) Cal.Core.Prelude.Boolean]")
    
    && assert (typeRepToString (typeOf {#1 = 2.0, #2 = ["abc"], #3 = {abc = "abc", def = Just "def"}}) ==  
        "(Cal.Core.Prelude.Double, [Cal.Core.Prelude.String], {abc :: Cal.Core.Prelude.String, def :: Cal.Core.Prelude.Maybe Cal.Core.Prelude.String})")
    && assert (typeRepToString (typeOf {#2 = ["abc"], #3 = {abc = "abc", def = Just "def"}}) ==  
        "{#2 :: [Cal.Core.Prelude.String], #3 :: {abc :: Cal.Core.Prelude.String, def :: Cal.Core.Prelude.Maybe Cal.Core.Prelude.String}}")        
    //the record value should not be inspected at all    
    && assert (typeRepToString (typeOf (let x :: {#1 :: Cal.Core.Prelude.Double, #2 :: Cal.Core.Prelude.Char}; x = Cal.Core.Prelude.undefined; in x)) ==
        "(Cal.Core.Prelude.Double, Cal.Core.Prelude.Char)")
    && assert (typeRepToString (typeOf (let x :: {#3 :: Cal.Core.Prelude.Double, #2 :: Cal.Core.Prelude.Char}; x = Cal.Core.Prelude.undefined; in x)) ==
        "{#2 :: Cal.Core.Prelude.Char, #3 :: Cal.Core.Prelude.Double}")
    && assert (typeRepToString (typeOf (let x :: {z :: Cal.Core.Prelude.Double, q :: Cal.Core.Prelude.Char}; x = Cal.Core.Prelude.undefined; in x)) ==
        "{q :: Cal.Core.Prelude.Char, z :: Cal.Core.Prelude.Double}")
    && assert (typeRepToString (typeOf (let x :: {#1 :: Cal.Core.Prelude.Int, #2 :: Cal.Core.Prelude.Int, z :: Cal.Core.Prelude.Double, q :: Cal.Core.Prelude.Char}; x = Cal.Core.Prelude.undefined; in x)) ==
        "{#1 :: Cal.Core.Prelude.Int, #2 :: Cal.Core.Prelude.Int, q :: Cal.Core.Prelude.Char, z :: Cal.Core.Prelude.Double}")
    && assert (typeRepToString (typeOf (let x :: {#2 :: Cal.Core.Prelude.Int, #90 :: Cal.Core.Prelude.Int, z :: Cal.Core.Prelude.Double, q :: Cal.Core.Prelude.Char}; x = Cal.Core.Prelude.undefined; in x)) ==
        "{#2 :: Cal.Core.Prelude.Int, #90 :: Cal.Core.Prelude.Int, q :: Cal.Core.Prelude.Char, z :: Cal.Core.Prelude.Double}")
    && assert (typeRepToString (typeOf {}) == "{}")
    && assert (typeRepToString (typeOf (1.0, 2.0)) == "(Cal.Core.Prelude.Double, Cal.Core.Prelude.Double)")
    && assert (typeRepToString (typeOf {a = "StrVal", b = 'C', c = Just (1 :: Int)}) == "{a :: Cal.Core.Prelude.String, b :: Cal.Core.Prelude.Char, c :: Cal.Core.Prelude.Maybe Cal.Core.Prelude.Int}")
    && assert (typeRepToString (typeOf {a = "StrVal", #1 = 9.0, b = 'C', c = Just (1 :: Int)}) == "{#1 :: Cal.Core.Prelude.Double, a :: Cal.Core.Prelude.String, b :: Cal.Core.Prelude.Char, c :: Cal.Core.Prelude.Maybe Cal.Core.Prelude.Int}")
    && assert (typeRepToString (typeOf (Just {field1 = (negate :: Double -> Double)})) ==
        "Cal.Core.Prelude.Maybe {field1 :: Cal.Core.Prelude.Double -> Cal.Core.Prelude.Double}")
    && assert (typeRepToString (typeOf (let x :: ({#1 :: Char} -> Boolean) -> [{#1 :: Char}] -> [{#1 :: Char}]; x = undefined; in x)) ==
        "({#1 :: Cal.Core.Prelude.Char} -> Cal.Core.Prelude.Boolean) -> [{#1 :: Cal.Core.Prelude.Char}] -> [{#1 :: Cal.Core.Prelude.Char}]")      
    && assert (typeRepToString (typeOf (undefined :: Integer)) == "Cal.Core.Prelude.Integer")
    && assert (typeRepToString (typeOf (undefined :: JObject)) == "Cal.Core.Prelude.JObject")
    && assert (typeRepToString (typeOf (undefined :: Decimal)) == "Cal.Core.Prelude.Decimal")
    ;    

/** 
 * Extracts the machine-internal type dictionary from a record.  This is used internally to do fast type operations
 * on record values.
 */
primitive protected recordTypeDictionary :: Typeable r => {r} -> RecordType;

/**
 * A common interface that is implemented by the machine-internal record type dictionaries for both
 * the lecc and g machines.  The {@link TypeRep@} for record types ({@link RecordTypeRep@}) has a
 * {@link RecordType@} field which is referred to for obtaining the type information for a record's fields.
 */
data foreign unsafe import jvm protected "org.openquark.cal.internal.runtime.RecordType"
    protected RecordType;

/**
 * @return The number of fields that the record represented by the {@link RecordType@} contains.
 */
foreign unsafe import jvm "method getNFields"
    protected recordType_getNFields :: RecordType -> Int;

/**
 * @return The nth value contained by the {@link RecordType@} object.  This will be an internal CAL value representing a function
 *          that accepts a single, ignored argument and returns a {@link TypeRep@} representing the type of
 *          the nth field of the record represented by the {@link RecordType@}.
 */
foreign unsafe import jvm "method getNthFieldValue"
    protected recordType_getNthFieldValue :: RecordType -> Int -> CalValue;


data foreign unsafe import jvm "org.openquark.cal.compiler.FieldName" 
    FieldName deriving Inputable, Outputable;

foreign unsafe import jvm "method getCalSourceForm"
    fieldNameToString :: FieldName -> String;

/**
 * @return The name of the nth field of the record whose type is represented by the {@link RecordType@}.
 */
foreign unsafe import jvm "method getNthFieldName"
    private recordType_getNthFieldName :: RecordType -> Int -> FieldName;

/**
 * @return {@link True@} if the record whose type is represented by the {@link RecordType@} is a tuple with 2 or more
 *          fields, and {@link False@} otherwise.
 */
foreign unsafe import jvm "method isTuple2OrMoreRecord"
    protected recordType_isTuple2OrMoreRecord :: RecordType -> Boolean;

/**
 * @return {@link True@} if the two {@link RecordType@}s have the same set of field names (not necessarily field types).
 *          Used internally to implemented {@link sameRootType@} for records. 
 */
foreign unsafe import jvm "method sameFields"
    protected recordType_sameFields :: RecordType -> RecordType -> Boolean;

/**
 * @arg dictionary A {@link RecordType@} that represents the type of a record value
 * @arg index A 0-based index indicating the field to retrieve the {@link TypeRep@} for
 * @return a {@link TypeRep@} representing the type of the nth field in the record whose type
 *          is represented by dictionary.
 */
recordType_getNthFieldType :: RecordType -> Int -> TypeRep;
protected recordType_getNthFieldType !dictionary !index =
    let
        // Record dictionary field values are a function of type a -> TypeRep that ignores its argument.
        toTypeRep :: CalValue -> TypeRep;
        toTypeRep !x = (unsafeCoerce x) undefined;
    in
        toTypeRep (recordType_getNthFieldValue dictionary index);

/**
 * @arg dictionary a {@link RecordType@} representing the type of a record value
 * @return A list of {@link TypeRep@}s representing the types of each field of the record value.
 *          The 0th element of the list represents the type of the 0th field of the record,
 *          and so forth. 
 */
recordType_fieldTypes :: RecordType -> [TypeRep];
protected recordType_fieldTypes !dictionary =
    let
        fieldTypes :: RecordType -> Int -> Int -> [TypeRep];
        fieldTypes !dictionary !i !len =
            if i < len then
                recordType_getNthFieldType dictionary i : fieldTypes dictionary (i + 1) len
            else
                [];
    in
        fieldTypes dictionary 0 (recordType_getNFields dictionary);

instance Eq RecordType where
    equals = equalsRecordType;
    notEquals = notEqualsRecordType;
    ;
    
notEqualsRecordType :: RecordType -> RecordType -> Boolean;
private notEqualsRecordType !dictionary1 !dictionary2 =
    not (equalsRecordType dictionary1 dictionary2);

equalsRecordType :: RecordType -> RecordType -> Boolean;
private equalsRecordType !dictionary1 !dictionary2 =
    let
        fieldTypesEqual :: RecordType -> RecordType -> Int -> Int -> Boolean;
        fieldTypesEqual !dictionary1 !dictionary2 !i !len=
            if i < len then
                (recordType_getNthFieldType dictionary1 i) == (recordType_getNthFieldType dictionary2 i) &&
                fieldTypesEqual dictionary1 dictionary2 (i + 1) len
            else
                True;
    in
        recordType_sameFields dictionary1 dictionary2 &&
        fieldTypesEqual dictionary1 dictionary2 0 (recordType_getNFields dictionary1);
    
typeOfRecord :: Typeable r => {r} -> TypeRep;
private typeOfRecord recordValue =
    RecordTypeRep (recordTypeDictionary recordValue);

/**
 * Casts the argument value to the desired return type in a type-safe fashion.
 * This function makes a runtime test that compares the type of the argument and
 * the return type. If they are the same type, {@code {@link Just@} castValue@} is returned, where
 * {@code castValue@} is the argument value cast into the desired type, or {@link Nothing@}, if
 * the value cannot be cast into the desired type.
 * 
 * Type-safe casts let polymorphic functions behave differently depending on the
 * runtime type of an argument.
 * 
 * @arg x the value to be cast.
 * @return {@code {@link Just@} castValue@}, where {@code castValue@} is the argument value cast into the
 *         desired type, or {@link Nothing@}, if the value cannot be cast into the
 *         desired type.
 */
cast :: (Typeable a, Typeable b) => a -> Maybe b;
public cast x = 
    let 
        argType :: Maybe a -> a;
        argType = undefined;
        
        y :: Typeable a => Maybe a;
        y = if (typeOf x) == typeOf (argType y) then
                Just (unsafeCoerce x)
            else
                Nothing;
    in
        y;

castExamples :: Boolean;
castExamples =
    assert ((cast 2.0 :: Maybe String) == Nothing)
    && assert ((cast 3.0 :: Maybe Double) == Just 3.0)
    && assert ((cast ['a', 'b'] :: Maybe Integer) == Nothing)
    && assert ((cast ['c', 'd'] :: Maybe [Char]) == Just ['c', 'd'])
    ;
        
/**
 * {@code makeTransform f x@} applies {@code f@} to {@code x@} if {@code x@}'s type is the same as {@code f@}'s argument type,
 * and otherwise applies the identity function {@link Prelude.id@} to {@code x@}.
 * 
 * For example:
 * {@unorderedList
 * {@item {@code makeTransform {@link not@} {@link True@} == {@link False@}@}@}
 * {@item {@code makeTransform {@link not@} 'a'  == 'a'@}@}
 * @}
 * 
 * @arg f the function to be applied if its argument type matches that of {@code x@}.
 * @arg x the argument to be supplied to {@code f@}, if its type matches {@code f@}'s argument type.
 * @return {@code (f x)@} if {@code f@}'s argument type is the same as {@code x@}'s type, or {@code x@} otherwise.
 */
makeTransform :: (Typeable a, Typeable b) => (a -> a) -> (b -> b);
public makeTransform f =
    case (cast f) of
    Just g  -> g;
    Nothing -> id;
    ;

/**
 * {@code makeQuery defaultResult f x@} behaves as follows: if {@code x@}'s type is the same as {@code f@}'s
 * argument type, use {@code f@} to interrogate {@code x@}; otherwise return {@code defaultResult@}.
 * 
 * For example:
 * {@unorderedList
 * {@item {@code makeQuery 22 {@link charToInt@} 'a'  == 97@}@}
 * {@item {@code makeQuery 22 {@link charToInt@} 'b'  == 98@}@}
 * {@item {@code makeQuery 22 {@link charToInt@} {@link True@} == 22@}@}
 * @}
 * 
 * @arg defaultResult the default value to return if {@code x@}'s type is not the same as {@code f@}'s argument type.
 * @arg f the query function.
 * @arg x the argument to be supplied to {@code f@}.
 * @return {@code (f x)@} if {@code x@}'s type is the same as {@code f@}'s argument type, or {@code defaultResult@} otherwise.
 */
makeQuery :: (Typeable a, Typeable b) => r -> (a -> r) -> (b -> r);
public makeQuery defaultResult f x =
    case (cast x) of
    Just y  -> f y;
    Nothing -> defaultResult;
    ;               


//////////////////////////////////////////////////////////////////////
// Record related functions
 

/**
 * Extracts the first field of the specified tuple / the ordinal field {@code #1@} of the specified record.
 * 
 * @arg r the tuple / record with the ordinal field {@code #1@}.
 * @return the requested field.
 */
field1 :: r\#1 => {r | #1 :: a} -> a;
public field1 !r = r.#1;

/**
 * Extracts the second field of the specified tuple / the ordinal field {@code #2@} of the specified record.
 * 
 * @arg r the tuple / record with the ordinal field {@code #2@}.
 * @return the requested field.
 */
field2 :: r\#2 => {r | #2 :: a} -> a;
public field2 !r = r.#2;

/**
 * Extracts the third field of the specified tuple / the ordinal field {@code #3@} of the specified record.
 * 
 * @arg r the tuple / record with the ordinal field {@code #3@}.
 * @return the requested field.
 */
field3 :: r\#3 => {r | #3 :: a} -> a;
public field3 !r = r.#3;

/**
 * Extracts the fourth field of the specified tuple / the ordinal field {@code #4@} of the specified record.
 * 
 * @arg r the tuple / record with the ordinal field {@code #4@}.
 * @return the requested field.
 */
field4 :: r\#4 => {r | #4 :: a} -> a;
public field4 !r = r.#4;

/**
 * Extracts the fifth field of the specified tuple / the ordinal field {@code #5@} of the specified record.
 * 
 * @arg r the tuple / record with the ordinal field {@code #5@}.
 * @return the requested field.
 */
field5 :: r\#5 => {r | #5 :: a} -> a;
public field5 !r = r.#5;

/**
 * Extracts the sixth field of the specified tuple / the ordinal field {@code #6@} of the specified record.
 * 
 * @arg r the tuple / record with the ordinal field {@code #6@}.
 * @return the requested field.
 */
field6 :: r\#6 => {r | #6 :: a} -> a;
public field6 !r = r.#6;

/**
 * Extracts the seventh field of the specified tuple / the ordinal field {@code #7@} of the specified record.
 * 
 * @arg r the tuple / record with the ordinal field {@code #7@}.
 * @return the requested field.
 */
field7 :: r\#7 => {r | #7 :: a} -> a;
public field7 !r = r.#7;

    
//class instance support for records

//All records are instances of the Eq, Ord, Inputable, Outputable and Typeable type classes, provided that the types of their
//fields are also instances of the corresponding type classes. This support is built-in. The instance methods (such as
//equalsRecords below) are also built-in.


primitive private equalsRecord :: Eq r => {r} -> {r} -> Boolean;
primitive private notEqualsRecord :: Eq r => {r} -> {r} -> Boolean;

lessThanRecord :: Ord r => {r} -> {r} -> Boolean;
private lessThanRecord !r1 !r2 = compareRecord r1 r2 == LT;

lessThanEqualsRecord :: Ord r => {r} -> {r} -> Boolean;
private lessThanEqualsRecord !r1 !r2 = compareRecord r1 r2 != GT;

greaterThanEqualsRecord :: Ord r => {r} -> {r} -> Boolean;
private greaterThanEqualsRecord !r1 !r2 = compareRecord r1 r2 != LT; 

greaterThanRecord :: Ord r => {r} -> {r} -> Boolean;
private greaterThanRecord !r1 !r2 = compareRecord r1 r2 == GT;

/**
 * @arg r1
 * @arg r2
 * @return comparison using field-name ordering.
 */
primitive private compareRecord :: Ord r => {r} -> {r} -> Ordering;

maxRecord :: Ord r => {r} -> {r} -> {r};
private maxRecord !r1 !r2 = if r1 <= r2 then r2 else r1;
     
minRecord :: Ord r => {r} -> {r} -> {r};
private minRecord !r1 !r2 = if r1 <= r2 then r1 else r2;


/**
 * Any record type whose field types are all members of the {@link Eq@} type class is itself a member of the {@link Eq@} type class.
 * In particular, any tuple type whose component types are all members of the {@link Eq@} type class is itself a member of the 
 * {@link Eq@} type class.
 * 
 * The meaning of {@code {f1 = v1, f2 = v2, ..., fn = vn} == {f1 = w1, f2 = w2, ..., fn = wn}@} is by definition
 * {@code (v1 == w1) && (v2 == w2) && ... && (vn == wn)@}, where the fields f1, f2, ..., fn are in field-name order. 
 * Field-name order is an ordering on field-names such that ordinal fields are first, in numeric order, followed by
 * the textual fields, in alphabetic order.
 * 
 * Intuitively, two records are equal if the value of all their fields are equal, where computing the values of the fields
 * is done in field-name order.
 * 
 * For example, {@code {name = error "don't call this", age = 1.0} != {name = "Anton", age = 2.0}@} returns {@link True@} rather
 * than terminating in an error, because the {@code age@} fields are compared first, and the 2 records are already found to
 * be not equal, so the {@code name@} fields do not need to be compared.
 */
instance Eq r => Eq {r} where
    equals = equalsRecord;
    notEquals = notEqualsRecord;
    ;
 
/**
 * Any record type whose field types are all members of the {@link Ord@} type class is itself a member of the {@link Ord@} type class.
 * In particular, any tuple type whose component types are all members of the {@link Ord@} type class is itself a member of the 
 * {@link Ord@} type class.
 * 
 * The ordering on records is via lexicographic order. Intuitively, this means that when two records are compared, the values of
 * the first field (in field-name order) is used to make the comparison. If this is not sufficient, then the second field is used,
 * and so on. More precisely, {@code compare {f1 = v1, f2 = v2, ..., fn = vn} {f1 = w1, f2 = w2, ..., fn = wn}@} is equal to
 * {@code compare v1 w1@} if {@code compare v1 w1 != EQ@}. Otherwise, it is defined inductively by comparing the remaining elements:
 * {@code compare {f2 = v2, ..., fn = vn} {f2 = w2, ..., fn = wn}@}, where {@code compare {} {}@} is defined to return {@link EQ@}.
 * The fields f1, f2, ..., fn above are assumed to be ordered in field-name order i.e. ordinal fields are first, in numeric order, 
 * followed by the textual fields, in alphabetic order.
 */    
instance Ord r => Ord {r} where
    lessThan = lessThanRecord;
    lessThanEquals = lessThanEqualsRecord;
    greaterThanEquals = greaterThanEqualsRecord;
    greaterThan = greaterThanRecord;
    compare = compareRecord;
    max = maxRecord;
    min = minRecord;    
    ;

/**
 * The CAL record obtained by applying {@link input@} to each element of the Java list. The nth element of the Java list is
 * mapped to the nth field (in field-name order) in the CAL record. For example, if the Java list is {@code [x1, x2, x3]@}, then the resulting
 * CAL record is {@code {f1 = input x1, f2 = input x2, f3 = input x3}@}. Note that the length of the Java list must be the same as the number
 * of fields in the CAL record or an exception results. This condition is mainly intended to help users catch bugs in their code
 * at an early stage.
 * 
 * @arg javaList must be a {@code java.util.List@} of {@code java.lang.Object@} values of the appropriate Java sub-types for marshaling to
 *    the result record. 
 * @return the CAL record obtained by applying {@link input@} to each element of the Java list.
 */
primitive private recordFromJListPrimitive :: Inputable r => JList -> {r};

/**
 * The CAL record obtained by applying {@link input@} to each value of the Java map from {@code org.openquark.cal.compiler.FieldName@}
 * to {@code java.lang.Object@}. The nth element of the Java map (in field-name order) is mapped to the nth field (in field-name order) in
 * the CAL record. For example, if the Java map is {@code {f1 = x1, f2 = x2, f3 = x3}@}, then the resulting CAL record is
 * {@code {f1 = input x1, f2 = input x2, f3 = input x3}@}. Note that the size of the Java map must be the same as the number of fields 
 * in the CAL record or an exception results. Similarly the field-names of the Java map must exactly match the field-names in the CAL record.
 * These conditions are mainly intended to help users catch bugs in their code at an early stage.
 * 
 * @arg javaMap must be a {@code java.util.Map@} of {@code org.openquark.cal.compiler.FieldName@} to {@code java.lang.Object@}.
 * @return the CAL record obtained by applying {@link input@} to each value of the Java map.
 */
primitive private recordFromJMapPrimitive :: Inputable r => JMap -> {r};

/**
 * Returns a {@code java.util.List@} value whose elements are obtained by applying {@link input@} to each field in the CAL record 
 * in field-name order. For example, if the CAL record is {f1 = x1, f2 = x2, f3 = x3}, then the resulting Java list
 * would be [output x1, output x2, output x3].
 * 
 * @arg record CAL record to marshal to a Java list
 * @return a Java list whose elements are obtained by applying {@link input@} to each field in the CAL record in field-name order.
 */
primitive private recordToJListPrimitive :: Outputable r => {r} -> JList;

inputRecord :: Inputable r => JObject -> {r};
private inputRecord !record =
    if isJList record then
        recordFromJListPrimitive (jObjectToJList record)
    else if isJMap record then
        recordFromJMapPrimitive (jObjectToJMap record)
    else
        error "Expecting a Java object of type java.util.List or java.util.Map.";

outputRecord :: Outputable r => {r} -> JObject;
private outputRecord !record =
    output (recordToJListPrimitive record);
        
        
foreign unsafe import jvm "instanceof java.util.List"
    private isJList :: JObject -> Boolean;

foreign unsafe import jvm "cast"
    private jObjectToJList :: JObject -> JList;

/**
 * A CAL foreign type corresponding to the Java type {@code java.util.Map@}.
 */
data foreign unsafe import jvm public "java.util.Map"
    public JMap deriving Inputable, Outputable;

foreign unsafe import jvm "instanceof java.util.Map"
    private isJMap :: JObject -> Boolean;

foreign unsafe import jvm "cast"
    private jObjectToJMap :: JObject -> JMap;


/**
 * Any record type whose field types are all members of the {@link Inputable@} type class is itself a member of the {@link Inputable@} type class.
 * In particular, any tuple type whose component types are all members of the {@link Inputable@} type class is itself a member of the 
 * {@link Inputable@} type class.
 * 
 * The {@link input@} class method for records accepts input from a {@code java.util.List@} value or from a {@code java.util.Map@} value
 * with keys of type {@code org.openquark.cal.compiler.FieldName@} and values of type {@code java.lang.Object@}.
 * 
 * In the case of a Java list, the CAL record is obtained by applying {@link input@} to each element of the Java list.
 * The nth element of the Java list is mapped to the nth field (in field-name order) in the CAL record. For example, if the Java list is 
 * {@code [x1, x2, x3]@}, then the resulting CAL record is {@code {f1 = input x1, f2 = input x2, f3 = input x3}@}.
 * Note that the length of the Java list must be the same as the number of fields in the CAL record or an exception results. 
 * This condition is mainly intended to help users catch bugs in their code at an early stage.
 * 
 * For exampe, for a {@code java.util.List@} whose element 0 is a {@code java.lang.Double@} object of value 2.0, and whose element 1 is a
 * {@code java.lang.String@} object with value {@code "Anton"@}, then inputting to a record of type {@code {name :: String, age :: Double}@}
 * would result in a CAL record {@code {name = "Anton", age = 2.0}@}. This is because the age field is before the name field in
 * field-name order. If the {@code java.util.List@} had its elements reversed, CAL would throw an exception, since a {@link Double@} type is
 * expected but a {@code java.lang.String@} value was supplied, which is incompatible with the {@code Inputable Double@} instance.
 * 
 * Int the case of a Java map, the CAL record is obtained by applying {@link input@} to each value of the Java map from
 * {@code org.openquark.cal.compiler.FieldName@} to {@code java.lang.Object@}. The nth element of the Java map 
 * (in field-name order) is mapped to the nth field (in field-name order) in the CAL record. 
 * For example, if the Java map is {@code {f1 = x1, f2 = x2, f3 = x3}@}, then the resulting CAL record is
 * {@code {f1 = input x1, f2 = input x2, f3 = input x3}@}. Note that the size of the Java map must be the same as the number of fields 
 * in the CAL record or an exception results. Similarly the field-names of the Java map must exactly match the field-names in the CAL record.
 * These conditions are mainly intended to help users catch bugs in their code at an early stage.
 */    
instance Inputable r => Inputable {r} where
	input = inputRecord;
	;

/**
 * Any record type whose field types are all members of the {@link Outputable@} type class is itself a member of the {@link Outputable@} type class.
 * In particular, any tuple type whose component types are all members of the {@link Outputable@} type class is itself a member of the 
 * {@link Outputable@} type class.
 * 
 * The {@link output@} class method on records outputs to a {@code java.util.List@} value. The fields are output in field-name
 * order i.e. ordinal fields first in numeric order, followed by textual fields, in alphabetic order by field-name.
 * Note that the output format does not include the field-names. The field-names can be obtained by using the 
 * {@link function = "Cal.Core.Record.fieldNames"@} function.
 *
 * For example, the record {@code {name = "Anton", age = 1.5}@} outputs to a Java list having 2 elements. The element 0 is a
 * {@code java.lang.Double@} object of value 1.5, the element 1 is a {@code java.lang.String@} object with value {@code "Anton"@}. 
 *
 * The {@code java.util.List@} is guaranteed to implement the Java interfaces {@code java.util.RandomAccess@} and {@code java.io.Serializable@}
 * as well as to be modifiable. However, the list is not in general extendable (i.e. supporting the add and remove methods of {@code java.util.List@}).
 */      
instance Outputable r => Outputable {r} where
	output = outputRecord;
	;
	
instance Typeable r => Typeable {r} where
	typeOf = typeOfRecord;
	;


//////////////////////////////////////////////////////////////////////
// Enum type class

/**
 * {@link Enum@} is a type class intended to represent types whose values can be enumerated
 * one by one, such as {@link Int@}, {@link Long@}, {@link Integer@} and {@link Ordering@}. It is also used for types
 * such as {@link Double@}, where an enumeration can be defined on a subset of the values,
 * such as the series of values 1, 1.5, 2, 2.5, 3.
 * 
 * The {@link Enum@} type class can be used in {@em deriving@} clauses for {@em enumeration@} types. An enumeration type
 * is an algebraic type having no type arguments, and such that each data constructor has no fields. The derived class methods
 * take their ordering from the declaration ordering of the data constructors within the type definition.
 */
public class Enum a where  
    /**
     * For numeric types, {@code upFrom start creates@} the list {@code [start, start + 1, start + 2, ...]@}.
     *
     * @arg start the start value.
     * @return the list {@code [start, start + 1, start + 2, ...]@}.
     */
    //Same as the Haskell syntax [start ..].     
    public upFrom :: a -> [a];

    /**
     * For numeric types, {@code upFromThen start next@} creates the arithmetic sequence with first 2 terms {@code start@} and
     * {@code next@}. and then following with that difference i.e.
     * {@code [start, next, next + (next - start), next + 2*(next - start),...]@}.    
     * 
     * @arg start the start value.
     * @arg next the second value in the returned list.
     * @return the list {@code [start, next, next + (next - start), next + 2*(next - start),...]@}.
     */   
    //Same as the Haskell syntax [start, next ..].
    public upFromThen :: a -> a -> [a];
    
    /**
     * For numeric types, {@code upFromTo start end@} creates the list {@code [start, start + 1, start + 2, ..., end]@}.
     *   
     * @arg start the start value.
     * @arg end the end value.
     * @return the list {@code [start, start + 1, start + 2, ..., end]@}.
     */
    //Same as the Haskell syntax [start .. end].    
    public upFromTo :: a -> a -> [a];
    
    /**
     * For numeric types, {@code upFromThenTo start next edn@}, creates the arithmetic sequence with first 2 terms {@code start@}
     * and {@code next@}. and then following with that difference i.e.
     * {@code [start, next, next + (next - start), next + 2*(next - start),..., end]@}.
     *
     * @arg start the start value.
     * @arg next the second value in the returned list.
     * @arg end the end value.
     * @return the list {@code [start, next, next + (next - start), next + 2*(next - start),..., end]@}.
     */     
    // Same as the Haskell syntax [start, next .. end].    
    public upFromThenTo :: a -> a -> a -> [a];   
    ;

/**
 * {@code downFrom start@} creates the infinite list {@code [start, start - 1, start - 2, ...]@}.
 * 
 * @arg start the start value
 * @return the infinite list {@code [start, start - 1, start - 2, ...]@}.
 */    
downFrom :: (Num a, Enum a) => a -> [a];
public downFrom !start = upFromThen start (start - 1);    

testEnumInstances :: Boolean;
testEnumInstances =
    assert testEnumIntInstance
    && assert testEnumLongInstance
    && assert testEnumByteInstance
    && assert testEnumShortInstance
    && assert testEnumIntegerInstance
    && assert testEnumDecimalInstance
    && assert testEnumOrderingInstance
    && assert testEnumDoubleInstance
    && assert testEnumFloatInstance
    && assert testEnumBooleanInstance
	; 
 
    
instance Enum Int where
	upFrom = upFromInt;
	upFromThen = upFromThenInt;
	upFromTo = upFromToInt;
	upFromThenTo = upFromThenToInt;
	;
	
/* @test */
testEnumIntInstance :: Boolean;
testEnumIntInstance =
	assert upFromIntExamples
	&& assert upFromThenIntExamples
	&& assert upFromToIntExamples
	&& assert upFromThenToIntExamples
	;

upFromInt :: Int -> [Int];
private upFromInt !start = 
	if (start < maxBound) then
		start : upFromInt (start + 1)
	else
		[start];

/* @example */
upFromIntExamples :: Boolean;		
private upFromIntExamples =
    assert (take 3 (upFromInt 5) == [5, 6, 7])
	&& assert (take 4 (upFromInt (-2)) == [-2, -1, 0, 1])
	&& assert (upFromInt maxBound == [maxBound])
	&& assert (upFromInt (maxBound - 1) == [maxBound - 1, maxBound]) 
	&& assert (take 3 (upFromInt minBound) == [minBound, minBound + 1, minBound + 2])
	;
	
upFromThenInt :: Int -> Int -> [Int];
private upFromThenInt !start !next =
	upFromThenToInt start next (if start <= next then maxBound else minBound);

/* @example */
upFromThenIntExamples :: Boolean;
private upFromThenIntExamples =
    assert ((take 4 (upFromThenInt 10 12)) == [10, 12, 14, 16])
    && assert ((take 4 (upFromThenInt 10 8)) == [10, 8, 6, 4])
    && assert ((take 4 (upFromThenInt 10 10)) == [10, 10, 10, 10])    
    && assert ((take 3 (upFromThenInt 10 (-10))) == [10, -10, -30])
    && assert (take 3 (upFromThenInt maxBound maxBound) == [maxBound, maxBound, maxBound])
    && assert (upFromThenInt minBound 0 == [minBound, 0])
    && assert (upFromThenInt (maxBound - 1) maxBound == [maxBound - 1, maxBound])
    && assert (upFromThenInt (maxBound - 5) (maxBound - 3) == [maxBound - 5, maxBound - 3, maxBound - 1])
    && assert (take 3 (upFromThenInt minBound minBound) == [minBound, minBound, minBound])
    && assert (upFromThenInt (minBound + 1) minBound == [minBound + 1, minBound])
    && assert (upFromThenInt (minBound + 5) (minBound + 3) == [minBound + 5, minBound + 3, minBound + 1])
    && assert (upFromThenInt minBound maxBound == [minBound, maxBound])
    ;
    
upFromToInt :: Int -> Int -> [Int];
private upFromToInt !start !end = upFromByUpToInt start 1 end;

/* @example */
upFromToIntExamples :: Boolean;
upFromToIntExamples = 
    assert (upFromToInt 3 7 == [3, 4, 5, 6, 7])
    && assert (upFromToInt 3 3 == [3])
    && assert (upFromToInt 3 (-7) == [])
    && assert (upFromToInt 5 3 == [])   
    && assert (upFromToInt (-30) (-28) == [-30, -29, -28])
    && assert (upFromToInt maxBound maxBound == [maxBound])
    && assert (upFromToInt (maxBound - 1) maxBound == [maxBound - 1, maxBound])
    ;	

upFromThenToInt :: Int -> Int -> Int -> [Int];
private upFromThenToInt !start !next !end  =
	if start <= next then
		upFromByUpToInt start (next - start) end	
	else
		upFromByDownToInt start (start - next) end;

/* @example */
upFromThenToIntExamples :: Boolean;		
upFromThenToIntExamples =
    assert (upFromThenToInt 10 12 18 == [10, 12, 14, 16, 18])
    && assert (upFromThenToInt 10 9 5 == [10, 9, 8, 7, 6, 5])
    && assert (upFromThenToInt 10 12 (-18) == [])
    && assert (upFromThenToInt (maxBound - 5) (maxBound - 2) maxBound == [maxBound - 5, maxBound - 2])  
    && assert (upFromThenToInt maxBound 0 minBound == [maxBound, 0, minBound + 1])
    && assert (upFromThenToInt maxBound (-1) minBound == [maxBound, -1])  
    ;  				

/**
 * @arg start
 * @arg step may be {@code < 0@} in certain calls e.g. {@code {@link upFromThenInt@} {@link minBound@} {@link maxBound@}@},
 *           then {@code step@} is -1, but the function still works.
 * @arg end
 */
upFromByUpToInt :: Int -> Int -> Int -> [Int];	
private upFromByUpToInt !start !step !end =
	if (start > end) then
		[]
	else
		let
			next :: Int;
            next = start + step;
		in
		 	if (next > end || next < start) then
			//assuming that step >= 0, the condition that next < start
			//occurs only when start + step overflows the Int type.
			//In this case, start is the last element of the sequence.
			[start]
		else
			start : upFromByUpToInt next step end;
			
upFromByDownToInt :: Int -> Int -> Int -> [Int];
private upFromByDownToInt !start !step !end =
	if (start < end) then
		[]
	else
		let
			next :: Int;
            next = start - step;
		in
			if (next < end || next > start) then
			//since we assume that step >= 0, the condition that next > start
			//occurs only when start - step underflows the Int type.
			//In this case, start is the last element of the sequence.		
			[start]
		else
			start : upFromByDownToInt next step end;
		
		
		
instance Enum Long where
	upFrom = upFromLong;
	upFromThen = upFromThenLong;
	upFromTo = upFromToLong;
	upFromThenTo = upFromThenToLong;
	;
		
/* @test */
testEnumLongInstance :: Boolean;
testEnumLongInstance =
	assert upFromLongExamples
	&& assert upFromThenLongExamples
	&& assert upFromToLongExamples
	&& assert upFromThenToLongExamples
	;

upFromLong :: Long -> [Long];
private upFromLong !start = 
	if (start < maxBound) then
		start : upFromLong (start + 1)
	else
		[start];

/* @example */
upFromLongExamples :: Boolean;		
private upFromLongExamples =
    assert (take 3 (upFromLong 5) == [5, 6, 7])
	&& assert (take 4 (upFromLong (-2)) == [-2, -1, 0, 1])
	&& assert (upFromLong maxBound == [maxBound])
	&& assert (upFromLong (maxBound - 1) == [maxBound - 1, maxBound]) 
	&& assert (take 3 (upFromLong minBound) == [minBound, minBound + 1, minBound + 2])
	;
	
upFromThenLong :: Long -> Long -> [Long];
private upFromThenLong !start !next =
	upFromThenToLong start next (if start <= next then maxBound else minBound);

/* @example */
upFromThenLongExamples :: Boolean;
private upFromThenLongExamples =
    assert ((take 4 (upFromThenLong 10 12)) == [10, 12, 14, 16])
    && assert ((take 4 (upFromThenLong 10 8)) == [10, 8, 6, 4])
    && assert ((take 4 (upFromThenLong 10 10)) == [10, 10, 10, 10])    
    && assert ((take 3 (upFromThenLong 10 (-10))) == [10, -10, -30])
    && assert (take 3 (upFromThenLong maxBound maxBound) == [maxBound, maxBound, maxBound])
    && assert (upFromThenLong (maxBound - 1) maxBound == [maxBound - 1, maxBound])
    && assert (upFromThenLong (maxBound - 5) (maxBound - 3) == [maxBound - 5, maxBound - 3, maxBound - 1])
    && assert (take 3 (upFromThenLong minBound minBound) == [minBound, minBound, minBound])
    && assert (upFromThenLong (minBound + 1) minBound == [minBound + 1, minBound])
    && assert (upFromThenLong (minBound + 5) (minBound + 3) == [minBound + 5, minBound + 3, minBound + 1])
    && assert (upFromThenLong minBound maxBound == [minBound, maxBound])
    ;
    
upFromToLong :: Long -> Long -> [Long];
private upFromToLong !start !end = upFromByUpToLong start 1 end;

/* @example */
upFromToLongExamples :: Boolean;
upFromToLongExamples = 
    assert (upFromToLong 3 7 == [3, 4, 5, 6, 7])
    && assert (upFromToLong 3 3 == [3])
    && assert (upFromToLong 3 (-7) == [])
    && assert (upFromToLong 5 3 == [])   
    && assert (upFromToLong (-30) (-28) == [-30, -29, -28])
    && assert (upFromToLong maxBound maxBound == [maxBound])
    && assert (upFromToLong (maxBound - 1) maxBound == [maxBound - 1, maxBound])
    ;	

upFromThenToLong :: Long -> Long -> Long -> [Long];
private upFromThenToLong !start !next !end  =
	if start <= next then
		upFromByUpToLong start (next - start) end	
	else
		upFromByDownToLong start (start - next) end;

/* @example */
upFromThenToLongExamples :: Boolean;		
upFromThenToLongExamples =
    assert (upFromThenToLong 10 12 18 == [10, 12, 14, 16, 18])
    && assert (upFromThenToLong 10 9 5 == [10, 9, 8, 7, 6, 5])
    && assert (upFromThenToLong 10 12 (-18) == [])
    && assert (upFromThenToLong (maxBound - 5) (maxBound - 2) maxBound == [maxBound - 5, maxBound - 2])  
    && assert (upFromThenToLong maxBound 0 minBound == [maxBound, 0, minBound + 1])
    && assert (upFromThenToLong maxBound (-1) minBound == [maxBound, -1])  
    ;  				

/**
 * @arg start
 * @arg step may be {@code < 0@} in certain calls e.g. {@code {@link upFromThenLong@} {@link minBound@} {@link maxBound@}@},
 *           then {@code step@} is -1, but the function still works.
 * @arg end
 */
upFromByUpToLong :: Long -> Long -> Long -> [Long];	
private upFromByUpToLong !start !step !end =
	if (start > end) then
		[]
	else
		let
			next :: Long;
            next = start + step;
		in
		 	if (next > end || next < start) then
			//assuming that step >= 0, the condition that next < start
			//occurs only when start + step overflows the Long type.
			//In this case, start is the last element of the sequence.
			[start]
		else
			start : upFromByUpToLong next step end;
			
upFromByDownToLong :: Long -> Long -> Long -> [Long];
private upFromByDownToLong !start !step !end =
	if (start < end) then
		[]
	else
		let
			next :: Long;
            next = start - step;
		in
			if (next < end || next > start) then
			//since we assume that step >= 0, the condition that next > start
			//occurs only when start - step underflows the Long type.
			//In this case, start is the last element of the sequence.		
			[start]
		else
			start : upFromByDownToLong next step end;	
		
		

instance Enum Byte where
	upFrom = upFromByte;
	upFromThen = upFromThenByte;
	upFromTo = upFromToByte;
	upFromThenTo = upFromThenToByte;
	;
	
/* @test */
testEnumByteInstance :: Boolean;
testEnumByteInstance =
	assert upFromByteExamples
	&& assert upFromThenByteExamples
	&& assert upFromToByteExamples
	&& assert upFromThenToByteExamples
	;

upFromByte :: Byte -> [Byte];
private upFromByte !start = 
	if (start < maxBound) then
		start : upFromByte (start + 1)
	else
		[start];

/* @example */
upFromByteExamples :: Boolean;		
private upFromByteExamples =
    assert (take 3 (upFromByte 5) == [5, 6, 7])
	&& assert (take 4 (upFromByte (-2)) == [-2, -1, 0, 1])
	&& assert (upFromByte maxBound == [maxBound])
	&& assert (upFromByte (maxBound - 1) == [maxBound - 1, maxBound]) 
	&& assert (take 3 (upFromByte minBound) == [minBound, minBound + 1, minBound + 2])
	;
	
upFromThenByte :: Byte -> Byte -> [Byte];
private upFromThenByte !start !next =
	upFromThenToByte start next (if start <= next then maxBound else minBound);

/* @example */
upFromThenByteExamples :: Boolean;
private upFromThenByteExamples =
    assert ((take 4 (upFromThenByte 10 12)) == [10, 12, 14, 16])
    && assert ((take 4 (upFromThenByte 10 8)) == [10, 8, 6, 4])
    && assert ((take 4 (upFromThenByte 10 10)) == [10, 10, 10, 10])    
    && assert ((take 3 (upFromThenByte 10 (-10))) == [10, -10, -30])
    && assert (take 3 (upFromThenByte maxBound maxBound) == [maxBound, maxBound, maxBound])
    && assert (upFromThenByte minBound 0 == [minBound, 0])
    && assert (upFromThenByte (maxBound - 1) maxBound == [maxBound - 1, maxBound])
    && assert (upFromThenByte (maxBound - 5) (maxBound - 3) == [maxBound - 5, maxBound - 3, maxBound - 1])
    && assert (take 3 (upFromThenByte minBound minBound) == [minBound, minBound, minBound])
    && assert (upFromThenByte (minBound + 1) minBound == [minBound + 1, minBound])
    && assert (upFromThenByte (minBound + 5) (minBound + 3) == [minBound + 5, minBound + 3, minBound + 1])
    && assert (upFromThenByte minBound maxBound == [minBound, maxBound])
    ;
    
upFromToByte :: Byte -> Byte -> [Byte];
private upFromToByte !start !end = upFromByUpToByte start 1 end;

/* @example */
upFromToByteExamples :: Boolean;
upFromToByteExamples = 
    assert (upFromToByte 3 7 == [3, 4, 5, 6, 7])
    && assert (upFromToByte 3 3 == [3])
    && assert (upFromToByte 3 (-7) == [])
    && assert (upFromToByte 5 3 == [])   
    && assert (upFromToByte (-30) (-28) == [-30, -29, -28])
    && assert (upFromToByte maxBound maxBound == [maxBound])
    && assert (upFromToByte (maxBound - 1) maxBound == [maxBound - 1, maxBound])
    ;	

upFromThenToByte :: Byte -> Byte -> Byte -> [Byte];
private upFromThenToByte !start !next !end  =
	if start <= next then
		upFromByUpToByte start (next - start) end	
	else
		upFromByDownToByte start (start - next) end;

/* @example */
upFromThenToByteExamples :: Boolean;		
upFromThenToByteExamples =
    assert (upFromThenToByte 10 12 18 == [10, 12, 14, 16, 18])
    && assert (upFromThenToByte 10 9 5 == [10, 9, 8, 7, 6, 5])
    && assert (upFromThenToByte 10 12 (-18) == [])
    && assert (upFromThenToByte (maxBound - 5) (maxBound - 2) maxBound == [maxBound - 5, maxBound - 2])  
    && assert (upFromThenToByte maxBound 0 minBound == [maxBound, 0, minBound + 1])
    && assert (upFromThenToByte maxBound (-1) minBound == [maxBound, -1])  
    ;  				

/**
 * @arg start
 * @arg step may be {@code < 0@} in certain calls e.g. {@code {@link upFromThenByte@} {@link minBound@} {@link maxBound@}@},
 *      then {@code step@} is -1, but the function still works.
 * @arg end
 */
upFromByUpToByte :: Byte -> Byte -> Byte -> [Byte];	
private upFromByUpToByte !start !step !end =
	if (start > end) then
		[]
	else
		let
			next :: Byte;
            next = start + step;
		in
		 	if (next > end || next < start) then
			//assuming that step >= 0, the condition that next < start
			//occurs only when start + step overflows the Byte type.
			//In this case, start is the last element of the sequence.
			[start]
		else
			start : upFromByUpToByte next step end;
			
upFromByDownToByte :: Byte -> Byte -> Byte -> [Byte];
private upFromByDownToByte !start !step !end =
	if (start < end) then
		[]
	else
		let
			next :: Byte;
            next = start - step;
		in
			if (next < end || next > start) then
			//since we assume that step >= 0, the condition that next > start
			//occurs only when start - step underflows the Byte type.
			//In this case, start is the last element of the sequence.		
			[start]
		else
			start : upFromByDownToByte next step end;
		

    
instance Enum Char where
    upFrom = upFromChar;
    upFromThen = upFromThenChar;
    upFromTo = upFromToChar;
    upFromThenTo = upFromThenToChar;
    ;
    
/* @test */
testEnumCharInstance :: Boolean;
testEnumCharInstance =
    assert upFromCharExamples
    && assert upFromThenCharExamples
    && assert upFromToCharExamples
    && assert upFromThenToCharExamples
    ;

upFromChar :: Char -> [Char];
private upFromChar !start = 
    if (start < maxBound) then
        start : upFromChar (intToChar (charToInt start + 1))
    else
        [start];

/* @example */
upFromCharExamples :: Boolean;      
private upFromCharExamples =
    assert (take 3 (upFromChar 'a') == ['a', 'b', 'c'])
    && assert (take 4 (upFromChar ('M')) == ['M', 'N', 'O', 'P'])
    && assert (upFromChar maxBound == [maxBound])
    && assert (upFromChar (intToChar (charToInt maxBound - 1)) == [intToChar (charToInt maxBound - 1), maxBound]) 
    && assert (take 3 (upFromChar minBound) == [minBound, intToChar (charToInt minBound + 1), intToChar (charToInt minBound + 2)])
    ;
    
upFromThenChar :: Char -> Char -> [Char];
private upFromThenChar !start !next =
    upFromThenToChar start next (if start <= next then maxBound else minBound);

/* @example */
upFromThenCharExamples :: Boolean;
private upFromThenCharExamples =
    assert ((take 4 (upFromThenChar 'b' 'd')) == ['b', 'd', 'f', 'h'])
    && assert ((take 4 (upFromThenChar 'q' 'o')) == ['q', 'o', 'm', 'k'])
    && assert ((take 4 (upFromThenChar 'j' 'j')) == ['j', 'j', 'j', 'j'])    
    && assert (take 3 (upFromThenChar maxBound maxBound) == [maxBound, maxBound, maxBound])
    && assert (upFromThenChar minBound (intToChar ((charToInt minBound + charToInt maxBound) / 2 + 1)) == [minBound, intToChar ((charToInt minBound + charToInt maxBound) / 2 + 1)])
    && assert (upFromThenChar (intToChar (charToInt maxBound - 1)) maxBound == [intToChar (charToInt maxBound - 1), maxBound])
    && assert (upFromThenChar (intToChar (charToInt maxBound - 5)) (intToChar (charToInt maxBound - 3)) == [intToChar (charToInt maxBound - 5), intToChar (charToInt maxBound - 3), intToChar (charToInt maxBound - 1)])
    && assert (take 3 (upFromThenChar minBound minBound) == [minBound, minBound, minBound])
    && assert (upFromThenChar (intToChar (charToInt minBound + 1)) minBound == [intToChar (charToInt minBound + 1), minBound])
    && assert (upFromThenChar (intToChar (charToInt minBound + 5)) (intToChar (charToInt minBound + 3)) == [intToChar (charToInt minBound + 5), intToChar (charToInt minBound + 3), intToChar (charToInt minBound + 1)])
    && assert (upFromThenChar minBound maxBound == [minBound, maxBound])
    ;
    
upFromToChar :: Char -> Char -> [Char];
private upFromToChar !start !end = upFromByUpToChar start 1 end;

/* @example */
upFromToCharExamples :: Boolean;
upFromToCharExamples = 
    assert (upFromToChar 'c' 'g' == ['c', 'd', 'e', 'f', 'g'])
    && assert (upFromToChar 'c' 'c' == ['c'])
    && assert (upFromToChar 'c' 'a' == [])
    && assert (upFromToChar 'e' 'c' == [])   
    && assert (upFromToChar maxBound maxBound == [maxBound])
    && assert (upFromToChar (intToChar (charToInt maxBound - 1)) maxBound == [intToChar (charToInt maxBound - 1), maxBound])
    ;   

upFromThenToChar :: Char -> Char -> Char -> [Char];
private upFromThenToChar !start !next !end  =
    if start <= next then
        upFromByUpToChar start (charToInt next - charToInt start) end   
    else
        upFromByDownToChar start (charToInt start - charToInt next) end;

/* @example */
upFromThenToCharExamples :: Boolean;        
upFromThenToCharExamples =
    assert (upFromThenToChar 'j' 'l' 'r' == ['j', 'l', 'n', 'p', 'r'])
    && assert (upFromThenToChar 'j' 'i' 'e' == ['j', 'i', 'h', 'g', 'f', 'e']) 
    && assert (upFromThenToChar 'j' 'l' 'b' == [])
    && assert (upFromThenToChar (intToChar (charToInt maxBound - 5)) (intToChar (charToInt maxBound - 2)) maxBound == [intToChar (charToInt maxBound - 5), intToChar (charToInt maxBound - 2)])  
    ;               

//step may be < 0 in certain calls e.g. upFromThenChar minBound maxBound, then step is -1, but the function still works.
upFromByUpToChar :: Char -> Int -> Char -> [Char]; 
private upFromByUpToChar !start !step !end =
    if (start > end) then
        []
    else
        let
            nextIdx :: Int;
            nextIdx = charToInt start + step;
            
            next :: Char;
            next = if nextIdx <= 65535 then intToChar nextIdx else minBoundChar;
        in
            if (next > end || next < start) then
            //assuming that step >= 0, the condition that next < start
            //occurs only when start + step overflows the Char type.
            //In this case, start is the last element of the sequence.
            [start]
        else
            start : upFromByUpToChar next step end;
            
upFromByDownToChar :: Char -> Int -> Char -> [Char];
private upFromByDownToChar !start !step !end =
    if (start < end) then
        []
    else
        let
            nextIdx :: Int;
            nextIdx = charToInt start - step;
            
            next :: Char;
            next = if nextIdx >= 0 then intToChar nextIdx else maxBoundChar;
        in
            if (next < end || next > start) then
            //since we assume that step >= 0, the condition that next > start
            //occurs only when start - step underflows the Char type.
            //In this case, start is the last element of the sequence.      
            [start]
        else
            start : upFromByDownToChar next step end;

        
instance Enum Short where
	upFrom = upFromShort;
	upFromThen = upFromThenShort;
	upFromTo = upFromToShort;
	upFromThenTo = upFromThenToShort;
	;
	
/* @test */
testEnumShortInstance :: Boolean;
testEnumShortInstance =
	assert upFromShortExamples
	&& assert upFromThenShortExamples
	&& assert upFromToShortExamples
	&& assert upFromThenToShortExamples
	;

upFromShort :: Short -> [Short];
private upFromShort !start = 
	if (start < maxBound) then
		start : upFromShort (start + 1)
	else
		[start];

/* @example */
upFromShortExamples :: Boolean;		
private upFromShortExamples =
    assert (take 3 (upFromShort 5) == [5, 6, 7])
	&& assert (take 4 (upFromShort (-2)) == [-2, -1, 0, 1])
	&& assert (upFromShort maxBound == [maxBound])
	&& assert (upFromShort (maxBound - 1) == [maxBound - 1, maxBound]) 
	&& assert (take 3 (upFromShort minBound) == [minBound, minBound + 1, minBound + 2])
	;
	
upFromThenShort :: Short -> Short -> [Short];
private upFromThenShort !start !next =
	upFromThenToShort start next (if start <= next then maxBound else minBound);

/* @example */
upFromThenShortExamples :: Boolean;
private upFromThenShortExamples =
    assert ((take 4 (upFromThenShort 10 12)) == [10, 12, 14, 16])
    && assert ((take 4 (upFromThenShort 10 8)) == [10, 8, 6, 4])
    && assert ((take 4 (upFromThenShort 10 10)) == [10, 10, 10, 10])    
    && assert ((take 3 (upFromThenShort 10 (-10))) == [10, -10, -30])
    && assert (take 3 (upFromThenShort maxBound maxBound) == [maxBound, maxBound, maxBound])
    && assert (upFromThenShort minBound 0 == [minBound, 0])
    && assert (upFromThenShort (maxBound - 1) maxBound == [maxBound - 1, maxBound])
    && assert (upFromThenShort (maxBound - 5) (maxBound - 3) == [maxBound - 5, maxBound - 3, maxBound - 1])
    && assert (take 3 (upFromThenShort minBound minBound) == [minBound, minBound, minBound])
    && assert (upFromThenShort (minBound + 1) minBound == [minBound + 1, minBound])
    && assert (upFromThenShort (minBound + 5) (minBound + 3) == [minBound + 5, minBound + 3, minBound + 1])
    && assert (upFromThenShort minBound maxBound == [minBound, maxBound])
    ;
    
upFromToShort :: Short -> Short -> [Short];
private upFromToShort !start !end = upFromByUpToShort start 1 end;

/* @example */
upFromToShortExamples :: Boolean;
upFromToShortExamples = 
    assert (upFromToShort 3 7 == [3, 4, 5, 6, 7])
    && assert (upFromToShort 3 3 == [3])
    && assert (upFromToShort 3 (-7) == [])
    && assert (upFromToShort 5 3 == [])   
    && assert (upFromToShort (-30) (-28) == [-30, -29, -28])
    && assert (upFromToShort maxBound maxBound == [maxBound])
    && assert (upFromToShort (maxBound - 1) maxBound == [maxBound - 1, maxBound])
    ;	

upFromThenToShort :: Short -> Short -> Short -> [Short];
private upFromThenToShort !start !next !end  =
	if start <= next then
		upFromByUpToShort start (next - start) end	
	else
		upFromByDownToShort start (start - next) end;

/* @example */
upFromThenToShortExamples :: Boolean;		
upFromThenToShortExamples =
    assert (upFromThenToShort 10 12 18 == [10, 12, 14, 16, 18])
    && assert (upFromThenToShort 10 9 5 == [10, 9, 8, 7, 6, 5])
    && assert (upFromThenToShort 10 12 (-18) == [])
    && assert (upFromThenToShort (maxBound - 5) (maxBound - 2) maxBound == [maxBound - 5, maxBound - 2])  
    && assert (upFromThenToShort maxBound 0 minBound == [maxBound, 0, minBound + 1])
    && assert (upFromThenToShort maxBound (-1) minBound == [maxBound, -1])  
    ;  				

/**
 * @arg start
 * @arg step may be {@code < 0@} in certain calls e.g. {@code {@link upFromThenShort@} {@link minBound@} {@link maxBound@}@},
 *           then {@code step@} is -1, but the function still works.
 * @arg end
 */
upFromByUpToShort :: Short -> Short -> Short -> [Short];	
private upFromByUpToShort !start !step !end =
	if (start > end) then
		[]
	else
		let
			next :: Short;
            next = start + step;
		in
		 	if (next > end || next < start) then
			//assuming that step >= 0, the condition that next < start
			//occurs only when start + step overflows the Short type.
			//In this case, start is the last element of the sequence.
			[start]
		else
			start : upFromByUpToShort next step end;
			
upFromByDownToShort :: Short -> Short -> Short -> [Short];
private upFromByDownToShort !start !step !end =
	if (start < end) then
		[]
	else
		let
			next :: Short;
            next = start - step;
		in
			if (next < end || next > start) then
			//since we assume that step >= 0, the condition that next > start
			//occurs only when start - step underflows the Short type.
			//In this case, start is the last element of the sequence.		
			[start]
		else
			start : upFromByDownToShort next step end;
		
		
    
instance Enum Integer where
    upFrom = upFromInteger;
    upFromThen = upFromThenInteger;
    upFromTo = upFromToInteger;
    upFromThenTo = upFromThenToInteger;
    ;
    
/* @test */
testEnumIntegerInstance :: Boolean;
testEnumIntegerInstance =
    assert upFromIntegerExamples
    && assert upFromThenIntegerExamples
    && assert upFromToIntegerExamples
    && assert upFromThenToIntegerExamples
    ;

//note the strictness annotation is essential here to have correct space behavior.
upFromInteger :: Integer -> [Integer];
private upFromInteger !start = start : upFromInteger (start + 1);

/* @example */
upFromIntegerExamples :: Boolean;       
private upFromIntegerExamples =
    assert (take 3 (upFromInteger 5) == [5, 6, 7])
    && assert (take 4 (upFromInteger (-2)) == [-2, -1, 0, 1])
    ;
    
upFromThenInteger :: Integer -> Integer -> [Integer];
private upFromThenInteger !start !next =
    start : upFromThenInteger next (2*next - start);    

/* @example */
upFromThenIntegerExamples :: Boolean;
private upFromThenIntegerExamples =
    assert ((take 4 (upFromThenInteger 10 12)) == [10, 12, 14, 16])
    && assert ((take 4 (upFromThenInteger 10 8)) == [10, 8, 6, 4])
    && assert ((take 4 (upFromThenInteger 10 10)) == [10, 10, 10, 10])    
    && assert ((take 3 (upFromThenInteger 10 (-10))) == [10, -10, -30])  
    ;
    
upFromToInteger :: Integer -> Integer -> [Integer];
private upFromToInteger !start !end = upFromByUpToInteger start 1 end;

/* @example */
upFromToIntegerExamples :: Boolean;
upFromToIntegerExamples = 
    assert (upFromToInteger 3 7 == [3, 4, 5, 6, 7])
    && assert (upFromToInteger 3 3 == [3])
    && assert (upFromToInteger 3 (-7) == [])
    && assert (upFromToInteger 5 3 == [])   
    && assert (upFromToInteger (-30) (-28) == [-30, -29, -28])  
    ; 

upFromThenToInteger :: Integer -> Integer -> Integer -> [Integer];
private upFromThenToInteger !start !next !end  =
    if start <= next then
        upFromByUpToInteger start (next - start) end    
    else
        upFromByDownToInteger start (start - next) end;

/* @example */
upFromThenToIntegerExamples :: Boolean;     
upFromThenToIntegerExamples =
    assert (upFromThenToInteger 10 12 18 == [10, 12, 14, 16, 18])
    && assert (upFromThenToInteger 10 9 5 == [10, 9, 8, 7, 6, 5])
    && assert (upFromThenToInteger 10 12 (-18) == [])   
    ;                 

/**
 * This function assumes that {@code step >= 0@}.
 */
upFromByUpToInteger :: Integer -> Integer -> Integer -> [Integer];  
private upFromByUpToInteger !start !step !end =
    if (start > end) then
        []
    else if (start + step > end) then       
        [start]
    else
        start : upFromByUpToInteger (start + step) step end;
            
upFromByDownToInteger :: Integer -> Integer -> Integer -> [Integer];
private upFromByDownToInteger !start !step !end =
    if (start < end) then
        []
    else if (start - step < end) then       
        [start]
    else
        start : upFromByDownToInteger (start - step) step end;
        
        
instance Enum Decimal where
    upFrom = upFromDecimal;
    upFromThen = upFromThenDecimal;
    upFromTo = upFromToDecimal;
    upFromThenTo = upFromThenToDecimal;
    ;
    
/* @test */
testEnumDecimalInstance :: Boolean;
testEnumDecimalInstance =
    assert upFromDecimalExamples
    && assert upFromThenDecimalExamples
    && assert upFromToDecimalExamples
    && assert upFromThenToDecimalExamples
    ;

//note the strictness annotation is essential here to have correct space behavior.
upFromDecimal :: Decimal -> [Decimal];
private upFromDecimal !start = start : upFromDecimal (start + 1);

/* @example */
upFromDecimalExamples :: Boolean;       
private upFromDecimalExamples =
    assert (take 3 (upFromDecimal 5) == [5, 6, 7])
    && assert (take 4 (upFromDecimal (-2)) == [-2, -1, 0, 1])
    ;
    
upFromThenDecimal :: Decimal -> Decimal -> [Decimal];
private upFromThenDecimal !start !next =
    start : upFromThenDecimal next (2*next - start);    

/* @example */
upFromThenDecimalExamples :: Boolean;
private upFromThenDecimalExamples =
    assert ((take 4 (upFromThenDecimal 10 12)) == [10, 12, 14, 16])
    && assert ((take 4 (upFromThenDecimal 10 8)) == [10, 8, 6, 4])
    && assert ((take 4 (upFromThenDecimal 10 10)) == [10, 10, 10, 10])    
    && assert ((take 3 (upFromThenDecimal 10 (-10))) == [10, -10, -30])  
    ;
    
upFromToDecimal :: Decimal -> Decimal -> [Decimal];
private upFromToDecimal !start !end = upFromByUpToDecimal start 1 end;

/* @example */
upFromToDecimalExamples :: Boolean;
upFromToDecimalExamples = 
    assert (upFromToDecimal 3 7 == [3, 4, 5, 6, 7])
    && assert (upFromToDecimal 3 3 == [3])
    && assert (upFromToDecimal 3 (-7) == [])
    && assert (upFromToDecimal 5 3 == [])   
    && assert (upFromToDecimal (-30) (-28) == [-30, -29, -28])  
    ; 

upFromThenToDecimal :: Decimal -> Decimal -> Decimal -> [Decimal];
private upFromThenToDecimal !start !next !end  =
    if start <= next then
        upFromByUpToDecimal start (next - start) end    
    else
        upFromByDownToDecimal start (start - next) end;

/* @example */
upFromThenToDecimalExamples :: Boolean;     
upFromThenToDecimalExamples =
    assert (upFromThenToDecimal 10 12 18 == [10, 12, 14, 16, 18])
    && assert (upFromThenToDecimal 10 9 5 == [10, 9, 8, 7, 6, 5])
    && assert (upFromThenToDecimal 10 12 (-18) == [])   
    ;                 

/**
 * This function assumes that {@code step >= 0@}
 */
upFromByUpToDecimal :: Decimal -> Decimal -> Decimal -> [Decimal];  
private upFromByUpToDecimal !start !step !end =
    if (start > end) then
        []
    else if (start + step > end) then       
        [start]
    else
        start : upFromByUpToDecimal (start + step) step end;
            
upFromByDownToDecimal :: Decimal -> Decimal -> Decimal -> [Decimal];
private upFromByDownToDecimal !start !step !end =
    if (start < end) then
        []
    else if (start - step < end) then       
        [start]
    else
        start : upFromByDownToDecimal (start - step) step end;
        
        
    
/* @test */
testEnumOrderingInstance :: Boolean;
testEnumOrderingInstance =
    assert upFromOrderingExamples
    && assert upFromThenOrderingExamples
    && assert upFromToOrderingExamples
    && assert upFromThenToOrderingExamples
    ;

/* @example */
upFromOrderingExamples :: Boolean;      
private upFromOrderingExamples =
    assert (upFrom LT == [LT, EQ, GT])
    && assert (upFrom EQ == [EQ, GT])
    && assert (upFrom GT == [GT])
    ;

/* @example */
upFromThenOrderingExamples :: Boolean;
private upFromThenOrderingExamples =
    assert (upFromThen LT EQ == [LT, EQ, GT])
    && assert ((take 4 (upFromThen LT LT)) == [LT, LT, LT, LT])
    && assert ((take 4 (upFromThen GT GT)) == [GT, GT, GT, GT])    
    && assert (upFromThen GT EQ == [GT, EQ, LT])
    && assert (upFromThen LT GT == [LT, GT])
    && assert (upFromThen GT LT == [GT, LT])   
    ;
    
/* @example */
upFromToOrderingExamples :: Boolean;
upFromToOrderingExamples = 
    assert (upFromTo LT EQ == [LT, EQ])
    && assert (upFromTo EQ LT == [])
    && assert (upFromTo LT GT == [LT, EQ, GT])
    && assert (upFromTo EQ EQ == [EQ])      
    ;    

/* @example */
upFromThenToOrderingExamples :: Boolean;        
upFromThenToOrderingExamples =
    assert (upFromThenTo LT EQ GT == [LT, EQ, GT])
    && assert (upFromThenTo LT GT GT == [LT, GT])
    && assert (upFromThenTo GT EQ LT == [GT, EQ, LT])
    && assert (take 3 (upFromThenTo GT GT GT) == [GT, GT, GT])
    && assert (upFromThenTo GT GT EQ == [])       
    ;                



instance Enum Double where
    upFrom = upFromDouble;
    upFromThen = upFromThenDouble;
    upFromTo = upFromToDouble;
    upFromThenTo = upFromThenToDouble;
    ;
    
/* @test */
testEnumDoubleInstance :: Boolean;
testEnumDoubleInstance =
    assert upFromDoubleExamples
    && assert upFromThenDoubleExamples
    && assert upFromToDoubleExamples
    && assert upFromThenToDoubleExamples
    ;  

upFromDouble :: Double -> [Double];
private upFromDouble !start = start : upFromDouble (start + 1);

/* @example */
upFromDoubleExamples :: Boolean;
upFromDoubleExamples = 
    assert (take 3 (upFromDouble 5.0) == [5.0, 6.0, 7.0])
    && assert (take 4 (upFromDouble (-2.0)) == [-2, -1, 0, 1])
    && assert (take 4 (upFromDouble 3.2) == [3.2, 4.2, 5.2, 6.2])
    ;

upFromThenDouble :: Double -> Double -> [Double];
private upFromThenDouble !start !next = iterate (add (next - start)) start;

/* @example */
upFromThenDoubleExamples :: Boolean;
upFromThenDoubleExamples =
    assert (take 4 (upFromThenDouble 10.0 12.0) == [10, 12, 14, 16])
    && assert (take 4 (upFromThenDouble 10.0 10.5) == [10, 10.5, 11, 11.5])
    && assert (take 4 (upFromThenDouble 10.0 8.0) == [10, 8, 6, 4])
    && assert (take 4 (upFromThenDouble 10.0 10) == [10, 10, 10, 10])
    && assert (take 3 (upFromThenDouble 10.0 (-10)) == [10, -10, -30])
    ;

upFromToDouble :: Double -> Double -> [Double];
private upFromToDouble !start !end = takeWhile (greaterThanEquals (end + 0.5)) (upFromDouble start);

/* @example */
upFromToDoubleExamples :: Boolean;
upFromToDoubleExamples = 
    assert (upFromToDouble 3.0 7.0 == [3, 4, 5, 6, 7])
   // && upFromToDouble 3.0 2.9 == [3] // end is rounded up
    && assert (upFromToDouble 3.0 3.0 == [3])
    && assert (upFromToDouble 3.0 (-7.0) == [])
    && assert (upFromToDouble (-30.0) (-28.0) == [-30, -29, -28])
    && assert (upFromToDouble 3.0 5.9 == [3, 4, 5, 6]) // end is rounded up
    && assert (upFromToDouble 3.0 5.3 == [3, 4, 5]) // end is rounded down
    && assert (upFromToDouble 3.3 6.3 == [3.3, 4.3, 5.3, 6.3])
    && assert (upFromToDouble 3.3 6.9 == [3.3, 4.3, 5.3, 6.3, 7.3])    
    ;

upFromThenToDouble :: Double -> Double -> Double -> [Double];
private upFromThenToDouble !start !next !end =
    takeWhile (if next >= start then greaterThanEquals (end + (next - start)/2) else lessThanEquals (end + (next - start)/2)) (upFromThenDouble start next);
    
/* @example */
upFromThenToDoubleExamples :: Boolean;
upFromThenToDoubleExamples =
    assert (upFromThenToDouble 10.0 12 18 == [10, 12, 14, 16, 18])
    && assert (upFromThenToDouble 10.0 12 (-18) == [])
    && assert (upFromThenToDouble 10.0 9 18 == [])
    && assert (upFromThenToDouble 2.0 1.5 (-1) == [2, 1.5, 1, 0.5, 0, -0.5, -1])
    && assert (upFromThenToDouble 2.0 2.5 3.9 == [2, 2.5, 3.0, 3.5, 4.0]) //end is rounded to the multiple of the sequence difference
    && assert (upFromThenToDouble 2.0 2.5 3.6 == [2, 2.5, 3.0, 3.5])
    && assert (upFromThenToDouble 2.0 1.5 3.9 == [])
    ;    

instance Enum Float where
    upFrom = upFromFloat;
    upFromThen = upFromThenFloat;
    upFromTo = upFromToFloat;
    upFromThenTo = upFromThenToFloat;
    ;
    
/* @test */
testEnumFloatInstance :: Boolean;
testEnumFloatInstance =
    assert upFromFloatExamples
    && assert upFromThenFloatExamples
    && assert upFromToFloatExamples
    && assert upFromThenToFloatExamples
    ;  

upFromFloat :: Float -> [Float];
private upFromFloat !start = start : upFromFloat (start + 1);

/* @example */
upFromFloatExamples :: Boolean;
upFromFloatExamples = 
    assert (take 3 (upFromFloat 5) == [5, 6, 7])
    && assert (take 4 (upFromFloat (-2)) == [-2, -1, 0, 1])
    && assert (take 4 (upFromFloat (doubleToFloat 3.2)) == [(doubleToFloat 3.2), (doubleToFloat 4.2), (doubleToFloat 5.2), (doubleToFloat 6.2)])
    ;

upFromThenFloat :: Float -> Float -> [Float];
private upFromThenFloat !start !next = iterate (add (next - start)) start;

/* @example */
upFromThenFloatExamples :: Boolean;
upFromThenFloatExamples =
    assert (take 4 (upFromThenFloat 10 12) == [10, 12, 14, 16])
    && assert (take 4 (upFromThenFloat 10 (doubleToFloat 10.5)) == [10, (doubleToFloat 10.5), 11, (doubleToFloat 11.5)])
    && assert (take 4 (upFromThenFloat 10 8) == [10, 8, 6, 4])
    && assert (take 4 (upFromThenFloat 10 10) == [10, 10, 10, 10])
    && assert (take 3 (upFromThenFloat 10 (-10)) == [10, -10, -30])
    ;

upFromToFloat :: Float -> Float -> [Float];
private upFromToFloat !start !end = takeWhile (greaterThanEquals (end + (doubleToFloat 0.5))) (upFromFloat start);

/* @example */
upFromToFloatExamples :: Boolean;
upFromToFloatExamples = 
    assert (upFromToFloat 3 7 == [3, 4, 5, 6, 7])
   // && upFromToFloat 3.0 2.9 == [3] // end is rounded up
    && assert (upFromToFloat 3 3 == [3])
    && assert (upFromToFloat 3 (-7) == [])
    && assert (upFromToFloat (-30) (-28) == [-30, -29, -28])
    && assert (upFromToFloat 3 (doubleToFloat 5.9) == [3, 4, 5, 6]) // end is rounded up
    && assert (upFromToFloat 3 (doubleToFloat 5.3) == [3, 4, 5]) // end is rounded down
    && assert (upFromToFloat (doubleToFloat 3.3) (doubleToFloat 6.3) == [(doubleToFloat 3.3), (doubleToFloat 4.3), (doubleToFloat 5.3), (doubleToFloat 6.3)])
    && assert (upFromToFloat (doubleToFloat 3.3) (doubleToFloat 6.9) == [(doubleToFloat 3.3), (doubleToFloat 4.3), (doubleToFloat 5.3), (doubleToFloat 6.3), (doubleToFloat 7.3)])    
    ;

upFromThenToFloat :: Float -> Float -> Float -> [Float];
private upFromThenToFloat !start !next !end =
    takeWhile (if next >= start then greaterThanEquals (end + (next - start)/2) else lessThanEquals (end + (next - start)/2)) (upFromThenFloat start next);
    
/* @example */
upFromThenToFloatExamples :: Boolean;
upFromThenToFloatExamples =
    assert (upFromThenToFloat 10 12 18 == [10, 12, 14, 16, 18])
    && assert (upFromThenToFloat 10 12 (-18) == [])
    && assert (upFromThenToFloat 10 9 18 == [])
    && assert (upFromThenToFloat 2 (doubleToFloat 1.5) (-1) == [2, (doubleToFloat 1.5), 1, (doubleToFloat 0.5), 0, -(doubleToFloat 0.5), -1])
    && assert (upFromThenToFloat 2 (doubleToFloat 2.5) (doubleToFloat 3.9) == [2, (doubleToFloat 2.5), 3, (doubleToFloat 3.5), 4]) //end is rounded to the multiple of the sequence difference
    && assert (upFromThenToFloat 2 (doubleToFloat 2.5) (doubleToFloat 3.6) == [2, (doubleToFloat 2.5), 3, (doubleToFloat 3.5)])
    && assert (upFromThenToFloat 2 (doubleToFloat 1.5) (doubleToFloat 3.9) == [])
    ;


// The Boolean instance needs to be hand-written rather than derived because its
// unboxed representation is a boolean rather than an int.

instance Enum Boolean where
    upFrom = upFromBoolean;
    upFromThen = upFromThenBoolean;
    upFromTo = upFromToBoolean;
    upFromThenTo = upFromThenToBoolean;
    ;
    
/* @test */
testEnumBooleanInstance :: Boolean;
testEnumBooleanInstance =
    assert upFromBooleanExamples &&
    assert upFromToBooleanExamples &&
    assert upFromThenBooleanExamples &&
    assert upFromThenToBooleanExamples
    ;

upFromBoolean :: Boolean -> [Boolean];
private upFromBoolean !x =
    case x of
    False -> [False, True];
    True -> [True];
    ;

/* @example */
upFromBooleanExamples :: Boolean;
upFromBooleanExamples =    
    assert (upFromBoolean False == [False, True]) &&
    assert (upFromBoolean True == [True])
    ;
    
upFromToBoolean :: Boolean -> Boolean -> [Boolean];
private upFromToBoolean !start !end =
    case start of
    False ->
        case end of
        False -> [False];
        True -> [False, True];
        ;
    True ->
        case end of
        False -> [];
        True -> [True];
        ;
    ;
    
/* @example */
upFromToBooleanExamples :: Boolean;
upFromToBooleanExamples =
    assert (upFromToBoolean False False == [False]) &&
    assert (upFromToBoolean False True == [False, True]) &&
    assert (upFromToBoolean True False == []) &&
    assert (upFromToBoolean True True == [True])
    ;
    
upFromThenBoolean :: Boolean -> Boolean -> [Boolean];
private upFromThenBoolean !start !next =    
    case start of
    False ->
        case next of
        False -> repeat False;
        True -> [False, True];
        ;
    True ->
        case next of
        False -> [True, False];
        True -> repeat True;
        ;
    ;

/* @example */
upFromThenBooleanExamples :: Boolean;
upFromThenBooleanExamples =
    assert (take 5 (upFromThenBoolean False False) == [False, False, False, False, False]) &&
    assert (upFromThenBoolean False True == [False, True]) &&
    assert (upFromThenBoolean True False == [True, False]) &&
    assert (take 5 (upFromThenBoolean True True) == [True, True, True, True, True])
    ;
    
upFromThenToBoolean :: Boolean -> Boolean -> Boolean -> [Boolean];
private upFromThenToBoolean !start !next !end =
    case start of
    False ->
        case next of
        False -> repeat False;
        True ->
            case end of
            False -> [False];
            True -> [False, True];
            ;
        ;
    True ->
        case next of
        False ->
            case end of
            False -> [True, False];
            True -> [True];
            ;
        True ->
            case end of
            False -> [];
            True -> repeat True;
            ;
        ;
   ;

/* @example */
upFromThenToBooleanExamples :: Boolean;
upFromThenToBooleanExamples =
    assert (take 5 (upFromThenToBoolean False False False) == [False, False, False, False, False]) &&
    assert (take 5 (upFromThenToBoolean False False True)  == [False, False, False, False, False]) &&
    assert (upFromThenToBoolean False True False == [False]) &&
    assert (upFromThenToBoolean False True True == [False, True]) &&
    assert (upFromThenToBoolean True False False == [True, False]) &&
    assert (upFromThenToBoolean True False True == [True]) &&
    assert (upFromThenToBoolean True True False == []) &&
    assert (take 5 (upFromThenToBoolean True True True) == [True, True, True, True, True])
    ;

//////////////////////////////////////////////////////////////////////////////////////////////////////////
// The IntEnum type class and its instances

/**
 * Instances of {@link IntEnum@} are types where there is a one-to-one mapping between values of the type and
 * (possibly a subset) of the {@link Int@} type. 
 * 
 * Instances must satisfy the condition that
 * {@code {@link intToEnum@} ({@link enumToInt@} x) == x@}, for all values {@code x@}.
 * 
 * On the other hand, we allow multiple {@link Int@} values to map to a single value in the type {@code x@}. Thus for example,
 * for the {@link Ordering@} type, {@code {@link intToEnum@} x == {@link LT@}@} whenever {@code x < 0@}.
 * 
 * The {@link IntEnum@} type class can be used in {@em deriving@} clauses for {@em enumeration@} types. An enumeration type
 * is an algebraic type having no type arguments, and such that each data constructor has no fields. The mapping
 * to Int values for the derived class methods is via the data constructor ordinal. This is the 0-based declaration order of 
 * the data constructor within the type definition. Generally if you derive the {@link IntEnum@} instance, you will also want
 * to derive the {@link Enum@} class instance. 
 */
public class Enum a => IntEnum a where
    /**
     * Converts an {@link Int@} value to its corresponding value of type {@code {@link IntEnum@} a => a@}.
     * Terminates in an error if the {@link Int@} does not correspond to a value of the type {@code IntEnum a => a@}. 
     * @arg intValue int value to convert to an enum.
     * @return the corresponding value of type {@code {@link IntEnum@} a => a@}.
     */
    public intToEnum :: Int -> a
        default intToEnumDefault;
    
    /**    
     * Converts an {@link Int@} value to its corresponding value of type {@code {@link IntEnum@} a => a@}, if such a value exists,
     * or returns {@link Nothing@} if such a value does not exist.
     * @arg intValue int value to convert to an enum.
     * @return the corresponding value of type {@code {@link IntEnum@} a => a@}, wrapped in a {@link Just@}, if such a value exists,
     *         or {@link Nothing@} if such a value does not exist.
     */    
    public intToEnumChecked :: Int -> Maybe a;    
    
    /**
     * Converts a value of type {@code {@link IntEnum@} a => a@} to its canonical underlying representation as an {@link Int@}.
     * @arg enumValue enum value whose cannonical representation as an {@link Int@} is needed.
     * @return the canonical underlying representation of enumValue as an {@link Int@}.
     */
    public enumToInt :: a -> Int;
    ;

intToEnumDefault :: IntEnum a => Int -> a;
private intToEnumDefault !intValue =
    case intToEnumChecked intValue of
    Just {value = enumValue} -> enumValue;
    Nothing -> error (concat ["argument (", intToString intValue, ") does not correspond to an enumeration value"]);
    ;

instance IntEnum Ordering where
    intToEnum = intToOrdering;
    intToEnumChecked = intToEnumCheckedOrdering;
    enumToInt = orderingToInt;
    ;

/**
 * The {@link intToEnumChecked@} instance function for the {@link Ordering@} type.
 * 
 * All {@link Int@} values are valid (since all {@link Int@} values are either negative, 0, or positive), 
 * so we never return {@link Nothing@}.
 * 
 * @arg intValue The {@link Int@} value to be converted
 * @return {@code {@link Just@} orderingValue@}, where {@code orderingValue@} is {@link LT@} for negative values
 *          of {@code intValue@}, {@link EQ@} when {@code intValue@} is 0, and {@link GT@} for positive values of {@code intValue@}.
 */
intToEnumCheckedOrdering :: Int -> Maybe Ordering;
private intToEnumCheckedOrdering !intValue =
    Just (intToOrdering intValue);

/* @example */
orderingIntEnumExamples :: Boolean;
orderingIntEnumExamples =
    assert (intToEnum (-1) == LT) &&
    assert (intToEnum (-90000) == LT) &&
    assert (intToEnum 0 == EQ) &&
    assert (intToEnum 1 == GT) &&
    assert (intToEnum 50000 == GT) &&
    assert (intToEnumChecked (-123) == Just LT) &&
    assert (intToEnumChecked 0 == Just EQ) &&
    assert (intToEnumChecked 155 == Just GT) &&
    assert (enumToInt LT == (-1)) &&
    assert (enumToInt EQ == 0) &&
    assert (enumToInt GT == 1)
    ;
    
instance IntEnum Int where
    intToEnum = intToInt;
    intToEnumChecked = intToEnumCheckedInt;
    enumToInt = intToInt;
    ;

/**
 * The {@link intToEnum@} instance function for the {@link Int@} type.
 * @arg intValue The value to "convert" to an {@link Int@}
 * @return {@code {@link Just@} intValue@} (since every {@link Int@} maps to an {@link Int@} value, we never return {@link Nothing@}). 
 */
intToEnumCheckedInt :: a -> Maybe a;
private intToEnumCheckedInt !intValue =
    Just intValue;

/* @example */
intIntEnumExamples :: Boolean;
intIntEnumExamples =
    assert (intToEnum 23000 == (23000 :: Int))
    && assert (intToEnum minBoundInt == minBoundInt)
    && assert (intToEnum maxBoundInt == maxBoundInt)
    && assert (intToEnumChecked 23000 == Just (23000 :: Int))
    && assert (intToEnumChecked minBoundInt == Just minBoundInt) 
    && assert (intToEnumChecked maxBoundInt == Just maxBoundInt)
    && assert (enumToInt minBoundInt == minBoundInt)
    && assert (enumToInt maxBoundInt == maxBoundInt)
    && assert (enumToInt (23000 :: Int) == 23000)
    ;

instance IntEnum Short where
    intToEnum = intToEnumShort;
    intToEnumChecked = intToEnumCheckedShort;
    enumToInt = shortToInt;
    ;
    
/**
 * The {@link intToEnum@} instance function for the {@link Short@} type.
 * @arg intValue The value to convert to a {@link Short@}.  If {@code intValue@} is out of {@link Short@}'s range, an error will
 *               be raised.
 * @return a {@link Short@} representing the same value as {@code intValue@}. 
 */
intToEnumShort :: Int -> Short;
private intToEnumShort !intValue =
    if intValue < minBoundShortAsInt || intValue > maxBoundShortAsInt then
        error (concat ["argument (", intToString intValue, ") does not correspond to a value of type Prelude.Short"])
    else
        intToShort intValue;

/**
 * The {@link intToEnumChecked@} instance function for the {@link Short@} type.
 * @arg intValue The value to convert to a {@link Short@}.
 * @return {@code {@link Just@} val@} where {@code val@} is a {@link Short@} representing the same value as {@code intValue@} if
 *         {@code intValue@} is within {@link Short@}'s range, or {@link Nothing@} otherwise.  
 */
intToEnumCheckedShort :: Int -> Maybe Short;
private intToEnumCheckedShort !intValue =
    if intValue < minBoundShortAsInt || intValue > maxBoundShortAsInt then
        Nothing
    else
        Just (intToShort intValue);
    
/* @example */
shortIntEnumExamples :: Boolean;
shortIntEnumExamples =
    assert (intToEnum 23000 == (23000 :: Short))
    && assert (intToEnum minBoundShortAsInt == minBoundShort)
    && assert (intToEnum maxBoundShortAsInt == maxBoundShort)
    && assert (intToEnumChecked 23000 == Just (23000 :: Short))
    && assert (intToEnumChecked minBoundShortAsInt == Just minBoundShort) 
    && assert (intToEnumChecked maxBoundShortAsInt == Just maxBoundShort)
    && assert (enumToInt minBoundShort == minBoundShortAsInt)
    && assert (enumToInt maxBoundShort == maxBoundShortAsInt)
    && assert (enumToInt (23000 :: Short) == 23000)
    ;

instance IntEnum Byte where
    intToEnum = intToEnumByte;
    intToEnumChecked = intToEnumCheckedByte;
    enumToInt = byteToInt;
    ;
    
/**
 * The {@link intToEnum@} instance function for the {@link Byte@} type.
 * @arg intValue The value to convert to a {@link Byte@}.  If {@code intValue@} is out of {@link Byte@}'s range, an error will
 *               be raised.
 * @return a {@link Byte@} representing the same value as {@code intValue@}. 
 */
intToEnumByte :: Int -> Byte;
private intToEnumByte !intValue =
    if intValue < minBoundByteAsInt || intValue > maxBoundByteAsInt then
        error (concat ["argument (", intToString intValue, ") does not correspond to a value of type Prelude.Byte"])
    else
        intToByte intValue;

/**
 * The {@link intToEnumChecked@} instance function for the {@link Byte@} type.
 * @arg intValue The value to convert to a {@link Byte@}.
 * @return {@code {@link Just@} val@} where {@code val@} is a {@link Byte@} representing the same value as {@code intValue@} if
 *         {@code intValue@} is within {@link Byte@}'s range, or {@link Nothing@} otherwise.  
 */
intToEnumCheckedByte :: Int -> Maybe Byte;
private intToEnumCheckedByte !intValue =
    if intValue < minBoundByteAsInt || intValue > maxBoundByteAsInt then
        Nothing
    else
        Just (intToByte intValue);
                       
/* @example */
byteIntEnumExamples :: Boolean;
byteIntEnumExamples =
    assert (intToEnum 50 == (50 :: Byte))
    && assert (intToEnum minBoundByteAsInt == minBoundByte)
    && assert (intToEnum maxBoundByteAsInt == maxBoundByte)
    && assert (intToEnumChecked 50 == Just (50 :: Byte))
    && assert (intToEnumChecked minBoundByteAsInt == Just minBoundByte) 
    && assert (intToEnumChecked maxBoundByteAsInt == Just maxBoundByte)
    && assert (enumToInt minBoundByte == minBoundByteAsInt)
    && assert (enumToInt maxBoundByte == maxBoundByteAsInt)
    && assert (enumToInt (50 :: Byte) == 50)
    ;

instance IntEnum Char where
    intToEnum = intToEnumChar;
    intToEnumChecked = intToEnumCheckedChar;
    enumToInt = charToInt;
    ;
    
/**
 * The {@link intToEnum@} instance function for the {@link Char@} type.
 * @arg intValue The value to convert to a {@link Char@}.  If {@code intValue@} is out of {@link Char@}'s range, an error will
 *               be raised.
 * @return a {@link Char@} representing the same value as {@code intValue@}. 
 */
intToEnumChar :: Int -> Char;
private intToEnumChar !intValue =
    if intValue < minBoundCharAsInt || intValue > maxBoundCharAsInt then
        error (concat ["argument (", intToString intValue, ") does not correspond to a value of type Prelude.Char"])
    else
        intToChar intValue;

/**
 * The {@link intToEnumChecked@} instance function for the {@link Char@} type.
 * @arg intValue The value to convert to a {@link Char@}.
 * @return {@code {@link Just@} val@} where {@code val@} is a {@link Char@} representing the same value as {@code intValue@} if
 *         {@code intValue@} is within {@link Char@}'s range, or {@link Nothing@} otherwise.  
 */
intToEnumCheckedChar :: Int -> Maybe Char;
private intToEnumCheckedChar !intValue =
    if intValue < minBoundCharAsInt || intValue > maxBoundCharAsInt then
        Nothing
    else
        Just (intToChar intValue);
    
/* @example */
charIntEnumExamples :: Boolean;
charIntEnumExamples =
    assert (intToEnum 83 == 'S')
    && assert (intToEnum minBoundCharAsInt == minBoundChar)
    && assert (intToEnum maxBoundCharAsInt == maxBoundChar)
    && assert (intToEnumChecked 83 == Just 'S')
    && assert (intToEnumChecked minBoundCharAsInt == Just minBoundChar) 
    && assert (intToEnumChecked maxBoundCharAsInt == Just maxBoundChar)
    && assert (enumToInt minBoundChar == minBoundCharAsInt)
    && assert (enumToInt maxBoundChar == maxBoundCharAsInt)
    && assert (enumToInt 'S' == 83)
    ;

/* @test */
testIntEnumInstances :: Boolean;
testIntEnumInstances =
    assert orderingIntEnumExamples
    && assert intIntEnumExamples
    && assert shortIntEnumExamples
    && assert byteIntEnumExamples
    && assert charIntEnumExamples
    ;

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//Support for with intertwining Java and CAL types.
//For example, in List.sortByExternal a Java container class (java.util.List) holding values that are internal CAL runtime values.

/** 
 * An opaque representation of an arbitrary CAL value. 
 * 
 * Values in CAL have the Java {@code org.openquark.cal.runtime.CalValue@} abstract base class as their root.
 * They are treated specially when input or output from Java using the {@code {@link Inputable@} {@link CalValue@}@} and
 * {@code {@link Outputable@} {@link CalValue@}@} instance definitions.
 */
data foreign unsafe import jvm public "org.openquark.cal.runtime.CalValue"
    public CalValue; 

/** 
 * @arg calValue
 * @return converts the {@code calValue@} argument into a Java object that is suitable for external Java clients to use as a handle to the
 *         {@code calValue@}. The {@code calValue@} argument itself is not evaluated to weak-head normal form. 
 * @see objectToCalValue
 */
primitive private calValueToObject :: CalValue -> JObject;

/**
 * @arg object
 * @return checks that {@code object@} is indeed a handle to a {@link CalValue@} and then returns the underlying CAL value
 *         evaluating it to weak-head normal form. 
 * @see calValueToObject
 */
primitive private objectToCalValue :: JObject -> CalValue;


/**
 * Converts any value in CAL to a value of type {@link CalValue@}. This function will always succeed, and is perfectly safe,
 * since any value in CAL can also be viewed as a {@link CalValue@}. In effect, this is a way of performing type erasure on CAL types;
 * the underlying value is not modified.
 * 
 * @arg x a value
 * @return the value {@code x@}, viewed as having type {@link CalValue@}. The underlying value is not modified.
 * @see unsafeFromCalValue
 */
toCalValue :: a -> CalValue;
public toCalValue = unsafeCoerce;

/**
 * Converts a {@link CalValue@} to a CAL value of type {@code a@}. The underlying CAL value is not modified in any way. This function
 * in effect tells the CAL compiler what the type of an untyped {@link CalValue@} is. The CAL compiler can not check that this assertion
 * is correct, and the behaviour of CAL is undefined in the event that the type is incorrectly specified. 
 * 
 * @arg x a value
 * @return the value {@code x@}, viewed as having the specified return type. The underlying value is not modified.
 * @see toCalValue
 */
unsafeFromCalValue :: CalValue -> a;
public unsafeFromCalValue = unsafeCoerce;


/**
 * When {@code {@link input@} object :: {@link CalValue@}@} is evaluated, it first checks that the {@code object@} argument is really
 * a handle to a {@link CalValue@} and then returns the underlying {@link CalValue@}, evaluating it to weak-head normal form.
 */
instance Inputable CalValue where
    input = objectToCalValue;
    ;
    
/**
 * When {@code {@link output@} calValue@} is evaluated, the argument {@code calValue@} is converted to a Java object that is suitable 
 * for external Java clients to use as a handle to the calValue. The {@code calValue@} argument itself is not evaluated to weak-head normal
 * form.
 *
 * If you do want to evaluate the {@code calValue@} argument to weak-head normal form, use the {@link outputCalValueStrict@} function instead.
 */
instance Outputable CalValue where
    output = calValueToObject;
    ;

/**
 * When {@code {@link outputCalValueStrict@} calValue@} is evaluated, the argument {@code calValue@} is first evaluated to weak-head normal form itself,
 * and then converted to a Java object that is suitable for external Java clients to use as a handle to the {@code calValue@}. 
 * This function is sometimes needed when the external Java client wants to control the order of side effects in a series of CAL computations.
 * 
 * If you do not want to evaluate the {@code calValue@} argument to weak-head normal form, use the {@link output@} function instead.
 *   
 * @arg calValue
 * @return a Java object that is suitable for external clients to use as a handle to the {@code calValue@}. 
 */
outputCalValueStrict :: CalValue -> JObject;
public outputCalValueStrict !calValue = calValueToObject calValue;

      
data foreign unsafe import jvm protected "java.util.Comparator" 
    protected JComparator;     

/**
 * Makes a comparator that uses the ordering function argument to implement the Java comparator's compare method.
 */
primitive protected makeComparator :: (a -> a -> Ordering) -> JComparator;

                       
data foreign unsafe import jvm protected "org.openquark.cal.util.EquivalenceRelation"
    protected JEquivalenceRelation; 
  
primitive protected makeEquivalenceRelation :: (a -> a -> Boolean) -> JEquivalenceRelation;


//////////////////////////////////////////////////////////////////////

/**
 * The {@link CalFunction@} type is a foreign type used to hold a CAL function of type {@code {@link JObject@} -> {@link JObject@}@}.
 * 
 * This type is mainly intended to support the following use case:
 * {@orderedList
 *      {@item a CAL function is being evaluated, producing a partial application, which however requires a currently
 *             unavailable foreign value to be bound in to finish the transformation. @}
 *      {@item the partial application is passed to a foreign function. @}
 *      {@item at some point, the logic in the foreign function can obtain the required foreign value, and is able to
 *             call back into CAL to finish the evaluation @}
 * @}
 * 
 * It can also be used to implement functions such as {@link "Cal.Collections.List.sortByExternal"@} in which a pre-existing algorithm
 * such as {@code java.util.Collections.sort@} can be used to sort a CAL list using call-backs to a CAL comparison function of type 
 * a -> a -> Ordering.
 * 
 * @see makeCalFunction, evaluateCalFunction
 */
data foreign unsafe import jvm public "org.openquark.cal.runtime.CalFunction"
    public CalFunction deriving Inputable, Outputable;

/**
 * Creates a {@link CalFunction@} value from a CAL function of type {@code {@link JObject@} -> {@link JObject@}@}.
 * 
 * By combining arguments into a tuple, it is possible to create a {@link CalFunction@} that effectively represents
 * a multi-argument CAL function. By converting arguments to the {@link CalValue@} type, it is possible to create
 * a {@link CalFunction@} that works with CAL values that can not be converted to Java values by typical means
 * (such as using the {@link output@} class method).
 * 
 * @arg func the function to represent using the {@link CalFunction@} type
 * @return a foreign representation of the CAL function f
 */
primitive public makeCalFunction :: (JObject -> JObject) -> CalFunction;

/**
 * {@code evaluateCalFunction func arg@} evaluates the CAL function represented by {@code func@} at the value {@code arg@}.
 * 
 * Typically Java code will invoke the org.openquark.cal.runtime.CalFunction.evaluate method
 * rather than CAL code calling the {@link evaluateCalFunction@} foreign function.
 * 
 * @arg func the function
 * @arg arg the argument to apply {@code func@} to
 * @return the result of evaluating {@code func arg@}
 */
foreign unsafe import jvm "method evaluate"
    public evaluateCalFunction :: CalFunction -> JObject -> JObject;

//////////////////////////////////////////////////////////////////////

/**
 * This function should remain private. It is a helper intended for internal compiler use.
 * The reason for this is that ordinalValue breaks the encapsulation of the data type by exposing
 * implementation details about its data constructors.
 * 
 * The ordinal value is defined as follows:
 * {@orderedList
 * {@item for any data constructor defined in an algebraic data declaration, it is the zero-based ordinal
 *        within the declaration. For example, {@link Prelude.LT@} = 0, {@link Prelude.EQ@} = 1, and {@link Prelude.GT@} = 2.@}
 * {@item for an foreign type with Java implementation type int, byte, short or char,  the value is the underlying value,
 *        converted to an {@link Int@}. In particular, this is true of the {@link Int@}, {@link Byte@},
 *        {@link Short@} and {@link Char@} types.@}      
 * {@item For the built-in {@link Boolean@} type: {@link Prelude.False@} = 0, {@link Prelude.True@} = 1.@}
 * @}
 * 
 * For values of other types, such as {@link Long@}, {@link Double@}, foreign types etc. it throws an exception.      
 * 
 * @return the ordinal value.
 */
primitive private ordinalValue :: a -> Int;

/* @example */
ordinalValueExamples :: Boolean;
private ordinalValueExamples =
    assert (ordinalValue LT == 0)
    && assert (ordinalValue GT == 2)
    && assert (ordinalValue EQ == 1)
    && assert (ordinalValue False == 0)
    && assert (ordinalValue True == 1)
    && assert (ordinalValue () == 0)
    && assert (ordinalValue (Nothing :: Maybe Int) == 0)
    && assert (ordinalValue (Just 'a') == 1)
    && assert (ordinalValue ([] :: [Double]) == 0)
    && assert (ordinalValue [1.0, 2.0] == 1)
    && assert (ordinalValue (-100 :: Int) == -100)
    && assert (ordinalValue 'a' == charToInt 'a')
    && assert (ordinalValue (23 :: Byte) == 23)
    && assert (ordinalValue (200 :: Short) == 200)
    && assert (ordinalValue (-200 :: Short) == -200)
    ;

//////////////////////////////////////////////////////////////////////
//ExecutionContext

/**
 * This foreign type represents a CAL execution context.
 * 
 * The execution context provides an environment in which the execution of a CAL function occurs.
 * One of the most important tasks of an execution context is to provide a key to the
 * set of constant applicative form (CAF) values that are in use for the given execution.
 * 
 * Therefore, one must be careful that the execution context itself does not end up cached inside
 * a CAF, for it may hinder with the timely cleanup of the cached CAFs for the execution context.
 * 
 * The execution context holds onto an immutable set of properties which is specified by client code
 * on construction of the execution context, and can be accessed from within CAL. Some well-known properties
 * are defined by the platform (e.g. the current locale).
 */
data foreign unsafe import jvm protected "org.openquark.cal.internal.runtime.ExecutionContextImpl"
    protected ExecutionContext deriving Eq, Inputable, Outputable;

/**
 * @return the ExecutionContext that executed this call. Not a pure function. 
 */
primitive protected executionContext :: ExecutionContext;

//////////////////////////////////////////////////////////////////////
// Support for standalone JARs

/**
 * A type-specialized version of {@link input@} for use as a marshalling function in a standalone JAR.
 * 
 * @arg object a list of Strings as represented by a Java object of type {@code java.util.Collection@},
 *        {@code java.util.Iterator@}, {@code java.util.Enumeration@} or a Java {@code java.lang.String@} array.
 * @return the specified list as a CAL list of {@link String@}s.
 */
/*
 * @implementation we do not make this a CAF to avoid loading CAF related classes on startup of standalone JARs 
 * if CAFs are not being used.
 */
inputStringList :: JObject -> [String];
private inputStringList !object = input object;

//////////////////////////////////////////////////////////////////////
// Prelude test suite

//To each function we can associate an examples function that computes a series of identities, and if all goes
//well, results in the Boolean value True. For example, the inStr function has the inStrExamples examples function. This serves
//to document the functionality of functions in the Prelude module, and to ensure the continued correctness under changes
//in the function's or compiler's implementation.
/**
 * Tests all the examples in the Prelude module.
 */
/* @test */
testPreludeModule :: Boolean;
public testPreludeModule =
    
    //examples functions
    assert castExamples
    && assert equalsListExamples
    && assert greaterThanListExamples             
    && assert equalsRecordExamples
    && assert greaterThanRecordExamples                           
    && assert typeRepToStringExamples
    && assert typeOfExamples       
    && assert ordinalValueExamples
    && assert composeExamples
    && assert isForeignReferenceTypeExamples
    && assert isListTypeExamples
    && assert isRecordTypeExamples
    && assert isFunctionTypeExamples    
    && assert isPreludeNumTypeExamples
    && assert isMaybeTypeExamples
    && assert sameRootTypeExamples
    && assert typeArgumentsExamples            
    && assert appendStringExamples         
    
    //other tests, typically of Prelude primitives
    //todoBI some of these should not be in the Prelude but in a regression testing module such as M2
    && assert testEnumInstances     
    && assert testIntEnumInstances
    && assert testMaybeInstances
    ;
