/*
 * Copyright (c) 2007 BUSINESS OBJECTS SOFTWARE LIMITED
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *  
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *  
 *     * Neither the name of Business Objects nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *  
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


/*
 * Array.cal
 * Created: Sept 28, 2005
 * By: Bo Ilic
 */

/**
 * Defines the abstract data type {@link typeConstructor = Array@} along with a variety of functions and instances for the type.
 * 
 * {@link typeConstructor = Array@} is a polymorphic, immutable (i.e. purely functional) array type.
 * It is strict in its element values i.e. when an {@code {@link typeConstructor = Array@} a@} value is
 * created, all elements of the array are evaluated to weak-head normal form.
 * 
 * {@link typeConstructor = Array@} offers constant time access to its elements. In addition,
 * {@link typeConstructor = Array@} uses an unboxed representation of elements whenever possible. So for example, for
 * {@code {@link typeConstructor = Array@} {@link Int@}@}, the underlying representation is the Java primitive array
 * {@code [int]@}. Also, for an array of Java foreign objects, such as
 * {@code {@link typeConstructor = Array@} {@link Prelude.String@}@}, the underlying representation is a Java array
 * {@code [java.lang.String]@}, rather than an array of CAL internal values holding onto java.lang.Strings
 * i.e. it is more space efficient.
 * 
 * @author Bo Ilic
 */
/*
 * @implementation the Array module is a friend module of the Prelude. This is because to efficiently
 * implement Array's support for unboxed primitives requires direct access to the TypeRep type.
 */
module Cal.Collections.Array;
import Cal.Core.Prelude using
    typeConstructor = 
        Boolean, Byte, Char, Double, Float, Int, Integer, CalValue, JList, JObject, Long, Maybe, Ordering, Short, 
        String, TypeRep;
    typeClass = Appendable, Eq, Inputable, Num, Ord, Outputable, Typeable;
    dataConstructor = False, True, Nothing, Just, LT, EQ, GT;
    function = 
        add, append, asTypeOf, assert, compare, compose, eager, empty, equals, error, flip, fst, input, isEmpty, 
        isEven, max, min, multiply, not, notEquals, output, seq, typeOf, undefined, unsafeCoerce, upFromTo,
        isForeignReferenceType;
    dataConstructor = 
        ForeignTypeRep, BooleanTypeRep, IntTypeRep, ByteTypeRep, ShortTypeRep, LongTypeRep, FloatTypeRep, 
        DoubleTypeRep, CharTypeRep, StringTypeRep;
    ;
import Cal.Collections.List using
    function = inputList, inputListWith, outputList, outputListWith;
    ;
import Cal.Core.Char;    
import Cal.Core.String;

import Cal.Utilities.QuickCheck using
    typeClass = Arbitrary;
    typeConstructor = Gen;
    function = arbitrary, coarbitrary;
    ; 

import Cal.Core.Debug using
    typeClass = Show;
    function = show;
    ;
import Cal.Collections.ArrayPrimitives using
    typeConstructor = 
        JBooleanArray, JByteArray, JCharArray, JDoubleArray, JFloatArray, JIntArray, JCalValueArray, JLongArray, 
        JObjectArray, JShortArray;
    function = 
        array_arrayToList, array_cloneReplacingNullArray, array_concatList, array_fromCalValueArray, array_length, 
        array_listToArray, array_makeDefault, array_removeRange, array_reverse, array_subArray, 
        array_toCalValueArray;
    function = booleanArray_indexOf, byteArray_compress, byteArray_decompress, charArray_fromString, charArray_toString;
    function = 
        booleanArray_subscript, byteArray_subscript, charArray_subscript, doubleArray_subscript, floatArray_subscript, 
        intArray_subscript, calValueArray_subscript, longArray_subscript, objectArray_subscript, 
        shortArray_subscript;
    function = 
        byteArray_binarySearch, charArray_binarySearch, doubleArray_binarySearch, floatArray_binarySearch, 
        intArray_binarySearch, longArray_binarySearch, shortArray_binarySearch;
    function = 
        booleanArray_sort, byteArray_sort, charArray_sort, doubleArray_sort, floatArray_sort, intArray_sort, 
        longArray_sort, objectArray_sort, shortArray_sort;
    function = 
        booleanArray_update, byteArray_update, charArray_update, doubleArray_update, floatArray_update, 
        intArray_update, calValueArray_update, longArray_update, objectArray_update, shortArray_update;
    function = 
        booleanArray_array1, byteArray_array1, charArray_array1, doubleArray_array1, floatArray_array1, 
        intArray_array1, calValueArray_array1, longArray_array1, objectArray_array1, shortArray_array1;
    function = 
        booleanArray_array2, byteArray_array2, charArray_array2, doubleArray_array2, floatArray_array2, 
        intArray_array2, calValueArray_array2, longArray_array2, objectArray_array2, shortArray_array2;
    function = 
        booleanArray_array3, byteArray_array3, charArray_array3, doubleArray_array3, floatArray_array3, 
        intArray_array3, calValueArray_array3, longArray_array3, objectArray_array3, shortArray_array3;
    function = 
        booleanArray_array4, byteArray_array4, charArray_array4, doubleArray_array4, floatArray_array4, 
        intArray_array4, calValueArray_array4, longArray_array4, objectArray_array4, shortArray_array4;
    function = 
        booleanArray_array5, byteArray_array5, charArray_array5, doubleArray_array5, floatArray_array5, 
        intArray_array5, calValueArray_array5, longArray_array5, objectArray_array5, shortArray_array5;
    function = 
        booleanArray_array6, byteArray_array6, charArray_array6, doubleArray_array6, floatArray_array6, 
        intArray_array6, calValueArray_array6, longArray_array6, objectArray_array6, shortArray_array6;
    function = 
        booleanArray_array7, byteArray_array7, charArray_array7, doubleArray_array7, floatArray_array7, 
        intArray_array7, calValueArray_array7, longArray_array7, objectArray_array7, shortArray_array7;
    function = 
        booleanArray_replicate, byteArray_replicate, charArray_replicate, doubleArray_replicate, floatArray_replicate, 
        intArray_replicate, calValueArray_replicate, longArray_replicate, objectArray_replicate, 
        shortArray_replicate;
    function = 
        booleanArray_listToArrayWithFirstElement, byteArray_listToArrayWithFirstElement, 
        charArray_listToArrayWithFirstElement, doubleArray_listToArrayWithFirstElement, 
        floatArray_listToArrayWithFirstElement, intArray_listToArrayWithFirstElement, 
        calValueArray_listToArrayWithFirstElement, longArray_listToArrayWithFirstElement, 
        objectArray_listToArrayWithFirstElement, shortArray_listToArrayWithFirstElement;
    function = emptyArray_isRemoveRangeOK, emptyArray_isSubArrayOK, emptyArray_subscript, emptyArray_update;
    ;          
//we want to maintain the generality and functional independence of the Array module.
//Please do not add more imports.    

friend Cal.Test.Core.Array_Tests;    
    
/** 
 * {@code Array@} is a polymorphic, immutable (i.e. purely functional) array type. It is strict in its element
 * values i.e. when an {@code Array a@} value is created, all elements of the array are evaluated to weak-head
 * normal form.
 * 
 * {@code Array@} offers constant time access to its elements. In addition, {@code Array@} uses an unboxed representation
 * of elements whenever possible. So for example, for {@code Array {@link Int@}@}, the underlying representation is the
 * Java primitive array {@code [int]@}.
 */
/*
 * implementation note: the values array field must always be non-null.
 */    
data public Array a = 
    /**
     * Used for arrays of values of CAL foreign types having Java implementation type "char"   
     * such as the {@link Prelude.Char@} type. Cannot be an empty array.
     */
    protected CharArray 
        values :: !JCharArray |
        
    /**
     * Used for arrays of values of CAL foreign types having Java implementation type "boolean".
     * Also used for arrays of values of the {@link Prelude.Boolean@} type. Cannot be an empty array.
     */
    protected BooleanArray
        values :: !JBooleanArray |          
    
    /**
     * Used for arrays of values of CAL foreign types having Java implementation type "byte"   
     * such as the {@link Prelude.Byte@} type. Cannot be an empty array.
     */
    protected ByteArray 
        values :: !JByteArray |
    
    /**
     * Used for arrays of values of CAL foreign types having Java implementation type "short"   
     * such as the {@link Prelude.Short@} type. Cannot be an empty array.
     */
    protected ShortArray
        values :: !JShortArray |
                     
    /**
     * Used for arrays of values of CAL foreign types having Java implementation type "int"   
     * such as the {@link Prelude.Int@} type. Also used for arrays of values of CAL enumerated types
     * (these are non-parametric algebraic types all of whose data constructors have 0-arity with the
     * exception of the Prelude.Boolean type). Cannot be an empty array.
     */
    protected IntArray
        values :: !JIntArray |
        
    /**
     * Used for arrays of values of CAL foreign types having Java implementation type "short"   
     * such as the {@link Prelude.Short@} type. Cannot be an empty array.
     */
    protected LongArray
        values :: !JLongArray |
        
    /**
     * Used for arrays of values of CAL foreign types having Java implementation type "float"   
     * such as the {@link Prelude.Float@} type. Cannot be an empty array.
     */
    protected FloatArray
        values :: !JFloatArray |
        
    /**
     * Used for arrays of values of CAL foreign types having Java implementation type "double"   
     * such as the {@link Prelude.Double@} type. Cannot be an empty array.
     */
    protected DoubleArray
        values :: !JDoubleArray |
    
    /**
     * Used for arrays of values of CAL foreign reference types. Note that this does not include foreign primitive
     * types such as "int". Cannot be an empty array.
     */        
    protected ObjectArray
        values :: !JObjectArray |

    /**
     * Used for arrays of values of CAL types other than the ones above. These do not have a direct representation as
     * Java objects or values of a Java primitive type. Cannot be an empty array.
     */        
    protected CalValueArray
        values :: !JCalValueArray |
    
    /**
     * Used for an empty array.
     */
    protected EmptyArray
    ;

/**
 * An internal implementation type. This is useful for functions that construct new arrays that are the same
 * element type as another array, but without adding a Typeable constraint to the function. 
 */
data private ElementType =
    CharType |
    BooleanType |
    ByteType |
    ShortType |
    IntType |
    LongType |
    FloatType |
    DoubleType |
    ObjectType |
    CalValueType
    deriving Eq, Show;

/**
 * Returns the integer representation of the enumeration value (of type {@link Array.ElementType@})
 * for the underlying value type of an internal value.
 * @arg value the internal value.
 * @return the element type as an integer.
 */
foreign unsafe import jvm "static method org.openquark.cal.internal.foreignsupport.module.Array.ArraySupport.getElementType" 
    private jGetElementType :: CalValue -> Int;

/**
 * Returns the element type for the underlying value type of an internal value.
 * @arg value the internal value.
 * @return the element type.
 */
/* @implementation
 * It is important that the argument is strict, because we can only determine the element type when the value is in WHNF
 */ 
elementType_fromValue :: a -> ElementType;
private elementType_fromValue !value = (unsafeCoerce (jGetElementType (Prelude.toCalValue value))) :: ElementType;

/**
 * Returns the element type for the underlying value type of the first (internal) value in
 * a non-empty array.
 * @arg array the non-empty array.
 * @return the element type.
 */
elementType_fromNonEmptyArray :: Array a -> ElementType;
private elementType_fromNonEmptyArray !array = elementType_fromValue $ eager $ subscript array 0;

instance Show a => Show (Array a) where
    show = showArray;
    ;
    
/* @example */
showArrayInstanceExamples :: Boolean;
showArrayInstanceExamples =
    assert (show (fromList ([] :: [Int])) == "(Array.EmptyArray [])")  
    && assert (show (fromList ['a', 'b', 'c']) == "(Array.CharArray ['a', 'b', 'c'])")  
    && assert (show (fromList [3 :: Long, 1, 4]) == "(Array.LongArray [3, 1, 4])")
    && assert (show (fromList [3.0, 1, 4]) == "(Array.DoubleArray [3.0, 1.0, 4.0])")    
    && assert (show (fromList ["foo", "bar"]) == "(Array.ObjectArray [\"foo\", \"bar\"])")    
    && assert (show (fromList [1 :: Integer, 2, 3]) == "(Array.ObjectArray [1, 2, 3])")    
    && assert (show (fromList [LT, GT, LT, EQ]) == "(Array.IntArray [Cal.Core.Prelude.LT, Cal.Core.Prelude.GT, Cal.Core.Prelude.LT, Cal.Core.Prelude.EQ])")    
    && assert (show (fromList [(2.0, "abc"), (10.0, "pear")]) == "(Array.CalValueArray [(2.0, \"abc\"), (10.0, \"pear\")])")   
    && assert (show (fromList [Just LT, Just GT, Just EQ]) == "(Array.CalValueArray [Cal.Core.Prelude.Just Cal.Core.Prelude.LT, Cal.Core.Prelude.Just Cal.Core.Prelude.GT, Cal.Core.Prelude.Just Cal.Core.Prelude.EQ])")  
    ;      
    
showArray :: Show a => Array a -> String;
showArray !array =
    let
        showArrayType :: Array a -> String;
        showArrayType !array =
            case array of
            CharArray {} -> 
                "Array.CharArray";              
            BooleanArray {} ->
                "Array.BooleanArray";
            ByteArray {} ->
                "Array.ByteArray";
            ShortArray {} ->
                "Array.ShortArray";
            IntArray {} ->
                "Array.IntArray";
            LongArray {} ->
                "Array.LongArray";
            FloatArray {} ->
                "Array.FloatArray";
            DoubleArray {} ->
                "Array.DoubleArray";
            ObjectArray {} ->
                "Array.ObjectArray";
            CalValueArray {} ->
                "Array.CalValueArray";
            EmptyArray ->
                "Array.EmptyArray";
            ;
    in   
        Prelude.concat ["(", showArrayType array, " ", show (toList array), ")"];

/**
 * Exposes the primitive array values held by the array argument. Note: the exposed array is not a copy.
 * It is typed as a {@link JObject@} since that is the common super-type of primitive arrays and object arrays.
 */
nonEmptyArrayValues :: Array a -> JObject;
private nonEmptyArrayValues !array =
    case array of
    CharArray {values} ->
        output values;
        
    BooleanArray {values} ->
        output values;  
        
    ByteArray {values} ->
        output values;   
        
    ShortArray {values} ->
        output values;
                    
    IntArray {values} ->
        output values;
       
    LongArray {values} ->
        output values;
            
    FloatArray {values} ->
        output values;
        
    DoubleArray {values} ->
        output values;
       
    ObjectArray {values} ->
        output values;
                
    CalValueArray {values} ->
        output values;
    
    EmptyArray -> undefined;
    ;
    
foreign unsafe import jvm "static method java.lang.System.arraycopy" 
    protected system_arraycopy :: JObject -> Int -> JObject -> Int -> Int -> ();
    
/**
 * Performs the analogous functionality to {@code System.arraycopy@} in Java.
 * This function does destructive updates on the destination array argument and so must remain private.
 * 
 * @arg source the source array to copy elements from
 * @arg sourcePos index in the source array from which to start copying
 * @arg dest the destination array to copy elements to
 * @arg destPos index in the destination array at which to start copying
 * @arg nElemsToCopy the number of elements to copy from source to dest
 * @return the destination array {@code dest@}, which is destructively modified by this function.
 */    
nonEmptyArrayCopy :: Array a -> Int -> Array a -> Int -> Int -> Array a;     
private nonEmptyArrayCopy !source !sourcePos !dest !destPos !nElemsToCopy =
    system_arraycopy (nonEmptyArrayValues source) sourcePos (nonEmptyArrayValues dest) destPos nElemsToCopy
    `seq`
    dest;

/**
 * Exposes the values array held onto by each object as a Java array of CAL values. The returned Java array
 * is a copy in all cases (including {@link CalValueArray@}). 
 */
internalArrayValues :: Array a -> JCalValueArray;
private internalArrayValues !array =
    case array of
    CharArray {values} ->
        array_toCalValueArray values;
        
    BooleanArray {values} ->
        array_toCalValueArray values;  
        
    ByteArray {values} ->
        array_toCalValueArray values;   
        
    ShortArray {values} ->
        array_toCalValueArray values;
                    
    IntArray {values} ->
        array_toCalValueArray values;
       
    LongArray {values} ->
        array_toCalValueArray values;
            
    FloatArray {values} ->
        array_toCalValueArray values;
        
    DoubleArray {values} ->
        array_toCalValueArray values;
       
    ObjectArray {values} ->
        array_toCalValueArray values;
                
    CalValueArray {values} ->
        array_toCalValueArray values;
    
    EmptyArray -> empty;
    ; 

makeArrayFromCalValues :: ElementType -> JCalValueArray -> Array a;
private makeArrayFromCalValues !elementType !array =
    
    case elementType of
          
    CharType ->
        CharArray (array_fromCalValueArray array);        
        
    BooleanType ->
        BooleanArray (array_fromCalValueArray array);  
        
    ByteType ->
        ByteArray (array_fromCalValueArray array);  
        
    ShortType ->
        ShortArray (array_fromCalValueArray array); 
                    
    IntType ->
        IntArray (array_fromCalValueArray array); 
       
    LongType ->
        LongArray (array_fromCalValueArray array); 
            
    FloatType ->
        FloatArray (array_fromCalValueArray array); 
        
    DoubleType ->
        DoubleArray (array_fromCalValueArray array); 
      
    ObjectType ->
        ObjectArray (array_fromCalValueArray array);
        
    CalValueType ->
        CalValueArray (array_fromCalValueArray array); 
    ;    

/**
 * Converts a {@link typeConstructor = String@} to an {@code {@link typeConstructor = Array@} {@link typeConstructor = Char@}@}.
 */    
fromString :: String -> Array Char;    
public fromString !string =
    if isEmpty string then
        empty
    else
        CharArray (charArray_fromString string);

/* @example */
fromStringExamples :: Boolean;
fromStringExamples =
    assert (fromString "zaphod" == fromList ['z', 'a', 'p', 'h', 'o', 'd'])
    && assert (fromString "" == empty)
    ;

/**
 * Converts an {@code {@link typeConstructor = Array@} {@link typeConstructor = Char@}@} to a {@link typeConstructor = String@}.
 */
toString :: Array Char -> String;
public toString !array =
    case array of
    EmptyArray -> "";
    CharArray {values} -> charArray_toString values;
    ;

/* @example */
toStringExamples :: Boolean;
toStringExamples =
    assert (toString (fromList ['z', 'a', 'p', 'h', 'o', 'd']) == "zaphod")
    && assert (toString array0 == "")
    ;

/**
 * Builds an array from a list. Note that because of how the {@link typeConstructor = Array@} type is defined, every element of list
 * will be evaluated to weak head normal form. In particular, this function will hang on an infinite source list!
 * 
 * Note that another main way of constructing arrays is using {@link Prelude.input@} (and the
 * {@code {@link Inputable@} {@link typeConstructor = Array@}@} instance). 
 * Using {@link Prelude.input@} on a Java array will generally be more efficient that inputing a foreign object first as
 * a CAL list and then calling {@link fromList@}.
 * 
 * @arg list the list to convert to an array
 * @return the resulting array
 * @see fromListWith
 */    
fromList :: [a] -> Array a;
public fromList !list =
    case list of
    elem:_ -> fromNonEmptyListInternal (elementType_fromValue elem) list;
    [] -> empty;
    ;

fromNonEmptyListInternal :: ElementType -> [a] -> Array a;        
private fromNonEmptyListInternal !elementType !nonEmptyList =
    case elementType of
    CharType ->
        CharArray (array_listToArray (outputList ((unsafeCoerce nonEmptyList) :: [Char])));
        
    BooleanType ->
        BooleanArray (array_listToArray (outputList ((unsafeCoerce nonEmptyList) :: [Boolean])));
        
    ByteType ->
        ByteArray (array_listToArray (outputList ((unsafeCoerce nonEmptyList) :: [Byte])));
        
    ShortType ->
        ShortArray (array_listToArray (outputList ((unsafeCoerce nonEmptyList) :: [Short])));
        
    IntType ->
        IntArray (array_listToArray (outputList ((unsafeCoerce nonEmptyList) :: [Int])));
        
    LongType ->
        LongArray (array_listToArray (outputList ((unsafeCoerce nonEmptyList) :: [Long])));
        
    FloatType ->
        FloatArray (array_listToArray (outputList ((unsafeCoerce nonEmptyList) :: [Float])));
        
    DoubleType ->
        DoubleArray (array_listToArray (outputList ((unsafeCoerce nonEmptyList) :: [Double])));
        
    ObjectType ->   
        ObjectArray (array_listToArray (outputList ((unsafeCoerce nonEmptyList) :: [JObject])));
       
    CalValueType ->
        let
            strictOutput :: CalValue -> JObject;
            //strictOutput element = seq element (output element);            
            strictOutput !element = output element;
        in
            CalValueArray (array_listToArray (outputListWith (unsafeCoerce nonEmptyList :: [CalValue]) strictOutput));                                       
    ;

/**
 * Builds an array from a list with the help of an element conversion function {@code f@}.
 * Note that because of how the {@link typeConstructor = Array@} type is defined, every element of list
 * will be evaluated to weak head normal form. In particular, this function will hang on an infinite source list!
 * 
 * @arg f function to use to transform elements of the list to elements of the array
 * @arg list the list to convert to an array
 * @return the resulting array 
 * @see fromList
 */    
fromListWith :: (a -> b) -> [a] -> Array b;    
public fromListWith f !list =
    case list of
    elem:tail -> fromListWithInternal (f elem) f tail;
    [] -> empty;
    ;

fromListWithInternal :: b -> (a -> b) -> [a] -> Array b;        
private fromListWithInternal !firstElement f !tail =
    case elementType_fromValue firstElement of
    CharType ->
        CharArray (charArray_listToArrayWithFirstElement (unsafeCoerce firstElement) (outputListWith (unsafeCoerce tail) (output # (unsafeCoerce f :: a -> Char))));
        
    BooleanType ->
        BooleanArray (booleanArray_listToArrayWithFirstElement (unsafeCoerce firstElement) (outputListWith (unsafeCoerce tail) (output # (unsafeCoerce f :: a -> Boolean))));
        
    ByteType ->
        ByteArray (byteArray_listToArrayWithFirstElement (unsafeCoerce firstElement) (outputListWith (unsafeCoerce tail) (output # (unsafeCoerce f :: a -> Byte))));
        
    ShortType ->
        ShortArray (shortArray_listToArrayWithFirstElement (unsafeCoerce firstElement) (outputListWith (unsafeCoerce tail) (output # (unsafeCoerce f :: a -> Short))));
        
    IntType ->
        IntArray (intArray_listToArrayWithFirstElement (unsafeCoerce firstElement) (outputListWith (unsafeCoerce tail) (output # (unsafeCoerce f :: a -> Int))));
        
    LongType ->
        LongArray (longArray_listToArrayWithFirstElement (unsafeCoerce firstElement) (outputListWith (unsafeCoerce tail) (output # (unsafeCoerce f :: a -> Long))));
        
    FloatType ->
        FloatArray (floatArray_listToArrayWithFirstElement (unsafeCoerce firstElement) (outputListWith (unsafeCoerce tail) (output # (unsafeCoerce f :: a -> Float))));
        
    DoubleType ->
        DoubleArray (doubleArray_listToArrayWithFirstElement (unsafeCoerce firstElement) (outputListWith (unsafeCoerce tail) (output # (unsafeCoerce f :: a -> Double))));
        
    ObjectType ->   
        ObjectArray (objectArray_listToArrayWithFirstElement (unsafeCoerce firstElement) (outputListWith (unsafeCoerce tail) (unsafeCoerce f :: a -> JObject)));
       
    CalValueType ->
        let
            outputHelper :: a -> JObject;
            outputHelper element =
                let
                    outputCalValue :: CalValue -> JObject;
                    outputCalValue = output;
                in
                    //the use of eager is necessary to ensure that f element is in fact
                    //evaluated to weak head normal form.
                    outputCalValue (eager (unsafeCoerce (f (unsafeCoerce element))));                
        in
            CalValueArray (calValueArray_listToArrayWithFirstElement (eager (unsafeCoerce firstElement)) (outputListWith (unsafeCoerce tail) outputHelper));                                       
    ; 
    
/* @example */
fromListWithExamples :: Boolean;    
fromListWithExamples =    
    assert (fromListWith String.length [] == empty)
    && assert (fromListWith String.length ["apple", "pear", "banana", "orange"] == array4 5 4 6 6)
    && assert (fromListWith Prelude.toDouble [30 :: Int, 10, 40] == array3 30.0 10.0 40.0)
    && assert (fromListWith Prelude.Just ['a', 'b', 'c'] == array3 (Just 'a') (Just 'b') (Just 'c'))
    && assert (fromListWith Prelude.isJust [Just 'a', Nothing, Just 'b', Nothing] == array4 True False True False)
    && assert (fromListWith Prelude.fromJust [Just "abc", Just "def"] == array2 "abc" "def")
    ;

/**
 * Converts an array to a list. 
 * 
 * @arg array the array to convert to a list
 * @return the resulting list
 * @see toListWith
 */    
toList :: Array a -> [a];
public toList !array =
    case array of        
    CharArray {values} -> 
        unsafeCoerce (inputList (array_arrayToList values) :: [Char]);
        
    BooleanArray {values} ->
        unsafeCoerce (inputList (array_arrayToList values) :: [Boolean]); 
        
    ByteArray {values} ->
        unsafeCoerce (inputList (array_arrayToList values) :: [Byte]); 
        
    ShortArray {values} ->
        unsafeCoerce (inputList (array_arrayToList values) :: [Short]); 
                    
    IntArray {values} ->
        unsafeCoerce (inputList (array_arrayToList values) :: [Int]); 
       
    LongArray {values} ->
        unsafeCoerce (inputList (array_arrayToList values) :: [Long]);
            
    FloatArray {values} ->
        unsafeCoerce (inputList (array_arrayToList values) :: [Float]);
        
    DoubleArray {values} ->
        unsafeCoerce (inputList (array_arrayToList values) :: [Double]);
       
    ObjectArray {values} ->
        unsafeCoerce (inputList (array_arrayToList values) :: [JObject]);
                
    CalValueArray {values} ->
        unsafeCoerce (inputList (array_arrayToList values) :: [CalValue]);
    
    EmptyArray -> [];
    ;

/* @example */
toListExamples :: Boolean;
toListExamples =
    assert (toList (fromList ['a', 'b', 'c']) == ['a', 'b', 'c'])  
    && assert (toList (fromList (empty :: [Char])) == empty)
    && assert (toList (fromList [3 :: Long, 1]) == [3, 1])
    && assert (toList (fromList [3.0, 1, 4, 1]) == [3, 1, 4, 1])    
    && assert (toList (fromList ["foo", "bar"]) == ["foo", "bar"])    
    && assert (toList (fromList [1 :: Integer, 2, 3]) == [1, 2, 3])    
    && assert (toList (fromList [LT, GT, LT, EQ]) == [LT, GT, LT, EQ])    
    && assert (toList (fromList [(2.0, "abc"), (10.0, "pear")]) == [(2.0, "abc"), (10.0, "pear")]) 
    && assert (toList (fromList (empty :: [(Double, String)])) == empty)
    && assert (toList (fromList [Just LT, Just GT, Just EQ]) == [Just LT, Just GT, Just EQ])  
    ;  

/**
 * Converts an array to a list with the help of an element conversion function {@code f@} 
 * 
 * @arg f function to use to transform elements of the array to elements of the list
 * @arg array the array to convert to a list
 * @return the resulting list
 * @see toList
 */    
toListWith :: (a -> b) -> Array a -> [b];
public toListWith f !array =
    case array of        
    CharArray {values} -> 
        unsafeCoerce (inputListWith (array_arrayToList values) (unsafeCoerce ((unsafeCoerce f) # (input :: JObject -> Char))));
        
    BooleanArray {values} ->
        unsafeCoerce (inputListWith (array_arrayToList values) (unsafeCoerce ((unsafeCoerce f) # (input :: JObject -> Boolean)))); 
        
    ByteArray {values} ->
        unsafeCoerce (inputListWith (array_arrayToList values) (unsafeCoerce ((unsafeCoerce f) # (input :: JObject -> Byte)))); 
        
    ShortArray {values} ->
        unsafeCoerce (inputListWith (array_arrayToList values) (unsafeCoerce ((unsafeCoerce f) # (input :: JObject -> Short)))); 
                    
    IntArray {values} ->
        unsafeCoerce (inputListWith (array_arrayToList values) (unsafeCoerce ((unsafeCoerce f) # (input :: JObject -> Int)))); 
       
    LongArray {values} ->
        unsafeCoerce (inputListWith (array_arrayToList values) (unsafeCoerce ((unsafeCoerce f) # (input :: JObject -> Long))));
            
    FloatArray {values} ->
        unsafeCoerce (inputListWith (array_arrayToList values) (unsafeCoerce ((unsafeCoerce f) # (input :: JObject -> Float))));
        
    DoubleArray {values} ->
        unsafeCoerce (inputListWith (array_arrayToList values) (unsafeCoerce ((unsafeCoerce f) # (input :: JObject -> Double))));
       
    ObjectArray {values} ->
        unsafeCoerce (inputListWith (array_arrayToList values) (unsafeCoerce f));
                
    CalValueArray {values} ->
        unsafeCoerce (inputListWith (array_arrayToList values) (unsafeCoerce ((unsafeCoerce f) # (input :: JObject -> CalValue))));
    
    EmptyArray -> [];
    ;

/* @example */
toListWithExamples :: Boolean;    
toListWithExamples =
    assert (toListWith Prelude.fromJust (array0 :: Array (Maybe Char)) == [])
    && assert (toListWith Prelude.fromJust (array3 (Just "apple") (Just "pear") (Just "fig")) == ["apple", "pear", "fig"])
    && assert (toListWith Prelude.Just (array3 "apple" "pear" "fig") == [Just "apple", Just "pear", Just "fig"])
    && assert (toListWith Prelude.toDouble (array3 (3 :: Int) 200 2) == [3.0, 200.0, 2.0])
    && assert (toListWith String.length (array3 "abc" "de" "f") == [3, 2, 1])
    && assert (toListWith (List.replicate 2) (array3 "abc" "de" "f") == [["abc", "abc"], ["de", "de"], ["f", "f"]])
    && assert (toListWith (List.replicate 2) (array3 'a' 'b' 'c') == [['a', 'a'], ['b', 'b'], ['c', 'c']])
    && assert (toListWith (Char.toUpperCase) (array3 'a' 'b' 'c') == ['A', 'B', 'C'])
    ;

/**
 * {@code subscript array index@} returns the nth element of the array where n = {@code index@}. The indices start at 0.
 * If the index is negative or is greater than or equal to the length of the array, an error results.
 * 
 * {@code subscript@} is O(1) i.e. constant time unlike subscript for lists which is O(n).
 * 
 * @arg array the array to be accessed.
 * @arg index the index of the array element to be returned.
 * @return the element in the array at the position indicated by {@code index@}.
 */   
subscript :: Array a -> Int -> a;
public subscript !array !index =
    
    case array of
    CharArray {values} ->
        unsafeCoerce (charArray_subscript values index); 
        
    BooleanArray {values} ->
        unsafeCoerce (booleanArray_subscript values index);  
        
    ByteArray {values} ->
        unsafeCoerce (byteArray_subscript values index);   
        
    ShortArray {values} ->
        unsafeCoerce (shortArray_subscript values index);
                    
    IntArray {values} ->
        unsafeCoerce (intArray_subscript values index);
       
    LongArray {values} ->
        unsafeCoerce (longArray_subscript values index);
            
    FloatArray {values} ->
        unsafeCoerce (floatArray_subscript values index);
        
    DoubleArray {values} ->
        unsafeCoerce (doubleArray_subscript values index);
       
    ObjectArray {values} ->
        unsafeCoerce (objectArray_subscript values index);
                
    CalValueArray {values} ->
        unsafeCoerce (calValueArray_subscript values index);
    
    EmptyArray ->
        emptyArray_subscript index;
    ;

/* @example */
subscriptExamples :: Boolean;
subscriptExamples =
    assert (subscript (fromList ['a', 'b', 'c']) 2 == 'c')  
    && assert (subscript (fromList [3 :: Long, 1, 4]) 2 == 4)
    && assert (subscript (fromList [3.0, 1, 4]) 0 == 3)    
    && assert (subscript (fromList ["foo", "bar"]) 1 == "bar")    
    && assert (subscript (fromList [1 :: Integer, 2, 3]) 1 == 2)    
    && assert (subscript (fromList [LT, GT, LT, EQ]) 2 == LT)    
    && assert (subscript (fromList [(2.0, "abc"), (10.0, "pear")]) 1 == (10.0, "pear"))   
    && assert (subscript (fromList [Just LT, Just GT, Just EQ]) 0 == Just LT)  
    ;         

/**
 * Returns the length of the specified array. This function is O(1) in time (unlike length for lists which is O(n)
 * where n is the length of the list).
 * 
 * @arg array the array whose length is to be returned.
 * @return the length of the array.
 */
length :: Array a -> Int;
public length !array =
    case array of
    CharArray {values} ->
        array_length values;
        
    BooleanArray {values} ->
        array_length values;  
        
    ByteArray {values} ->
        array_length values;   
        
    ShortArray {values} ->
        array_length values;
                    
    IntArray {values} ->
        array_length values;
       
    LongArray {values} ->
        array_length values;
            
    FloatArray {values} ->
        array_length values;
        
    DoubleArray {values} ->
        array_length values;
       
    ObjectArray {values} ->
        array_length values;
                
    CalValueArray {values} ->
        array_length values;
    
    EmptyArray -> 0;
    ;

/* @example */
lengthExamples :: Boolean;
lengthExamples =
    assert (length (fromList ['a', 'b', 'c']) == 3)  
    && assert (length (fromList (empty :: [Char])) == 0)
    && assert (length (fromList [3 :: Long, 1]) == 2)
    && assert (length (fromList [3.0, 1, 4, 1]) == 4)    
    && assert (length (fromList ["foo", "bar"]) == 2)    
    && assert (length (fromList [1 :: Integer, 2, 3]) == 3)    
    && assert (length (fromList [LT, GT, LT, EQ]) == 4)    
    && assert (length (fromList [(2.0, "abc"), (10.0, "pear")]) == 2) 
    && assert (length (fromList (empty :: [(Double, String)])) == 0)
    && assert (length (fromList [Just LT, Just GT, Just EQ]) == 3)  
    ;    

/**
 * Returns the last element of the specified array. This function is O(1).
 * Terminates in an error on an empty array.
 * 
 * @arg array the array whose last element is to be returned.
 * @return the last element of the array.
 */
last :: Array a -> a;
public last !array =
    subscript array ((eager $ length array) - 1);

/* @example */
lastExamples :: Boolean;
lastExamples =
    assert (last (fromList ['B', 'c', 'a']) == 'a') &&
    assert (last (fromList [99, 100 :: Int, -78]) == -78);

instance Appendable (Array a) where
    empty = emptyArray;
    isEmpty = isEmptyArray;
    append = appendArray;
    concat = concatArray;
    ;

emptyArray :: Array a;
private emptyArray = EmptyArray;

isEmptyArray :: Array a -> Boolean;
private isEmptyArray !array =
    case array of
    EmptyArray -> True;
    _ -> False;
    ;

appendArray :: Array a -> Array a -> Array a;
appendArray !array1 !array2 = 
    if isEmpty array2 then
        array1
    else
        case array1 of
        CharArray {values} ->
            CharArray (values ++ array2.CharArray.values);        
        
        BooleanArray {values} ->
            BooleanArray (values ++ array2.BooleanArray.values);  
        
        ByteArray {values} ->
            ByteArray (values ++ array2.ByteArray.values);  
        
        ShortArray {values} ->
            ShortArray (values ++ array2.ShortArray.values); 
        
        IntArray {values} ->
            IntArray (values ++ array2.IntArray.values); 
        
        LongArray {values} ->
            LongArray (values ++ array2.LongArray.values); 
        
        FloatArray {values} ->
            FloatArray (values ++ array2.FloatArray.values); 
        
        DoubleArray {values} ->
            DoubleArray (values ++ array2.DoubleArray.values); 
        
        ObjectArray {values} ->
            ObjectArray (values ++ array2.ObjectArray.values); 
        
        CalValueArray {values} ->
            CalValueArray (values ++ array2.CalValueArray.values);
        
        EmptyArray -> array2;
    ;

/* @example */
appendExamples :: Boolean;
appendExamples =
    assert (array0 ++ array0 == (array0 :: Array Char))
    && assert (fromList ['a', 'b', 'c'] ++ empty == array3 'a' 'b' 'c')             
    && assert (fromList ['a', 'b'] ++ fromList ['a', 'b', 'c'] == array5 'a' 'b' 'a' 'b' 'c')  
    && assert (empty ++ fromList ['a', 'b', 'c'] == array3 'a' 'b' 'c')             
    && assert (fromList [3.0, 1, 4, 1] ++ fromList [1, 5, 9] == array7 3.0 1 4 1 1 5 9)    
    && assert (let a :: Array String;
                   a = fromList ["foo", "bar"]; in a ++ a == array4 "foo" "bar" "foo" "bar")
    && assert (fromList [LT, GT, EQ] ++ fromList [GT, GT, LT] == array6 LT GT EQ GT GT LT)
    && assert (fromList [Just LT, Just GT, Nothing, Just EQ] ++ fromList [Just GT, Nothing, Just GT, Just LT] == fromList [Just LT, Just GT, Nothing, Just EQ, Just GT, Nothing, Just GT, Just LT])
    ;
    
concatArray :: [Array a] -> Array a;
private concatArray !listOfArrays =
    let
        listOfNonEmptyArrays = List.filter (not # isEmpty) listOfArrays;
    in
        case listOfNonEmptyArrays of
        array:_ ->
            concatNonEmptyArrayInternal (elementType_fromNonEmptyArray array) listOfNonEmptyArrays;
        [] ->
            empty;
    ;
    
concatNonEmptyArrayInternal :: ElementType -> [Array a] -> Array a;
private concatNonEmptyArrayInternal !elementType !listOfNonEmptyArrays =
    let             
        listOfConcatenables :: JList;
        listOfConcatenables = outputListWith listOfNonEmptyArrays nonEmptyArrayValues;        
    in
        case elementType of
              
        CharType ->
            CharArray (array_concatList listOfConcatenables);        
            
        BooleanType ->
            BooleanArray (array_concatList listOfConcatenables);  
            
        ByteType ->
            ByteArray (array_concatList listOfConcatenables);  
            
        ShortType ->
            ShortArray (array_concatList listOfConcatenables); 
                        
        IntType ->
            IntArray (array_concatList listOfConcatenables); 
           
        LongType ->
            LongArray (array_concatList listOfConcatenables); 
                
        FloatType ->
            FloatArray (array_concatList listOfConcatenables); 
            
        DoubleType ->
            DoubleArray (array_concatList listOfConcatenables);
            
        ObjectType ->                                
            ObjectArray (array_concatList listOfConcatenables);
            
        CalValueType ->
            CalValueArray (array_concatList listOfConcatenables); 
        ;

/* @example */
concatArrayExamples :: Boolean;
concatArrayExamples =
    let
        noChars :: Array Char;
        noChars = array0;
        
        someChars :: Array Char;
        someChars = array3 'a' 'b' 'c';
    in
        assert (Prelude.concat [] == noChars)
        && assert (Prelude.concat [array0] == noChars)
        && assert (Prelude.concat [array0, array0] == noChars)
        && assert (Prelude.concat [array0, array0, someChars] == someChars)
        && assert (Prelude.concat [array0, array0, someChars, array0] == someChars)
        && assert (Prelude.concat [array0, array0, someChars, array0, someChars] == array6 'a' 'b' 'c' 'a' 'b' 'c')
    ;

/**
 * Reverses the elements of an array. {@code reverse@} is O(n) time where n is the length of the array.
 * 
 * @arg array the array to be reversed.
 * @return an array containing the elements in the specified array, in reverse order.
 */        
reverse :: Array a -> Array a;
public reverse !array = 
    case array of
    CharArray {values} ->
        CharArray (array_reverse values);        
        
    BooleanArray {values} ->
        BooleanArray (array_reverse values);  
        
    ByteArray {values} ->
        ByteArray (array_reverse values);  
        
    ShortArray {values} ->
        ShortArray (array_reverse values); 
                    
    IntArray {values} ->
        IntArray (array_reverse values); 
       
    LongArray {values} ->
        LongArray (array_reverse values); 
            
    FloatArray {values} ->
        FloatArray (array_reverse values); 
        
    DoubleArray {values} ->
        DoubleArray (array_reverse values); 
       
    ObjectArray {values} ->
        ObjectArray (array_reverse values); 
                
    CalValueArray {values} ->
        CalValueArray (array_reverse values);
    
    EmptyArray -> empty;
    ;    
    
/**
 * Extracts a portion of the argument array as a new array. 
 * 
 * If {@code fromIndex < 0@}, {@code fromIndex > toIndex@}, or {@code toIndex > length array@}, the function
 * terminates in an error. Use the {@link Array.length@} function to pre-check to avoid this
 * if necessary.
 * 
 * @arg array to extract a sub-array from
 * @arg fromIndex inclusive 0-based index. 
 * @arg toIndex exclusive 0-based index
 * @return copy of the array from {@code fromIndex@} (inclusive) to {@code toIndex@} (exclusive).
 */    
subArray :: Array a -> Int -> Int -> Array a;
public subArray !array !fromIndex !toIndex = 
    
    case array of
    CharArray {values} ->
        let
            newValues :: JCharArray;
            newValues = array_subArray values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                CharArray newValues;        
        
    BooleanArray {values} ->
        let
            newValues :: JBooleanArray;
            newValues = array_subArray values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                BooleanArray newValues;        
        
    ByteArray {values} ->
        let
            newValues :: JByteArray;
            newValues = array_subArray values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                ByteArray newValues;        
        
    ShortArray {values} ->
        let
            newValues :: JShortArray;
            newValues = array_subArray values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                ShortArray newValues;        
                    
    IntArray {values} ->
        let
            newValues :: JIntArray;
            newValues = array_subArray values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                IntArray newValues;        
       
    LongArray {values} ->
        let
            newValues :: JLongArray;
            newValues = array_subArray values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                LongArray newValues;        
            
    FloatArray {values} ->
        let
            newValues :: JFloatArray;
            newValues = array_subArray values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                FloatArray newValues;        
        
    DoubleArray {values} ->
        let
            newValues :: JDoubleArray;
            newValues = array_subArray values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                DoubleArray newValues;        
       
    ObjectArray {values} ->
        let
            newValues :: JObjectArray;
            newValues = array_subArray values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                ObjectArray newValues;        
                
    CalValueArray {values} ->
        let
            newValues :: JCalValueArray;
            newValues = array_subArray values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                CalValueArray newValues;        
    
    EmptyArray ->
        if emptyArray_isSubArrayOK fromIndex toIndex then
            empty
        else
            undefined;
    ;    
    
/**
 * {@code replicate nCopies valueToReplicate@} is an array of length {@code nCopies@}, with every element equal to
 * {@code valueToReplicate@}.
 * 
 * @arg nCopies the number of copies.
 * @arg valueToReplicate the value to be replicated.
 * @return an array of length {@code nCopies@}, with every element equal to {@code valueToReplicate@}.
 */    
replicate :: Int -> a -> Array a;
public replicate !nCopies !valueToReplicate =   
    
    if nCopies == 0 then
        empty
    else
        case elementType_fromValue valueToReplicate of
        
        CharType ->
            CharArray (charArray_replicate nCopies (unsafeCoerce valueToReplicate));        
        
        BooleanType ->
            BooleanArray (booleanArray_replicate nCopies (unsafeCoerce valueToReplicate));  
        
        ByteType ->
            ByteArray (byteArray_replicate nCopies (unsafeCoerce valueToReplicate));  
        
        ShortType ->
            ShortArray (shortArray_replicate nCopies (unsafeCoerce valueToReplicate)); 
        
        IntType ->
            IntArray (intArray_replicate nCopies (unsafeCoerce valueToReplicate)); 
        
        LongType ->
            LongArray (longArray_replicate nCopies (unsafeCoerce valueToReplicate)); 
        
        FloatType ->
            FloatArray (floatArray_replicate nCopies (unsafeCoerce valueToReplicate)); 
        
        DoubleType ->
            DoubleArray (doubleArray_replicate nCopies (unsafeCoerce valueToReplicate)); 
        
        ObjectType ->
            ObjectArray (objectArray_replicate nCopies (unsafeCoerce valueToReplicate));
        
        CalValueType ->
            CalValueArray (calValueArray_replicate nCopies (unsafeCoerce valueToReplicate)); 
    ;          

/**
 * {@code {@link typeConstructor = Array@} a@} will be output to a java.util.List.
 * 
 * In all cases the returned Java List will have elements that are the Java objects determined by applying
 * {@link Prelude.output@} to each of the elements of the CAL array. 
 * 
 * In particular, in the case that {@code a@} is one of the {@link Prelude@} types {@link Boolean@}, {@link Byte@}, {@link Short@},
 * {@link Int@}, {@link Long@}, {@link Float@} or {@link Double@}, the objects in the array will be the boxed representations of
 * the primitive values.
 */
instance Outputable a => Outputable (Array a) where
    output = outputArray;
    ;

outputArray :: Outputable a => Array a -> JObject;
outputArray !array =
    output (array_arrayToList (outputArrayToJObjectArray array));

outputArrayToJObjectArray :: Outputable a => Array a -> JObjectArray;
outputArrayToJObjectArray !array =
    let
        //obtain the specialization of Prelude.output to be used on the array elements
        //outputValueFunc :: Outputable a => a -> JObject;, where a is the 'a' in the outputArrayToJObjectArray type signature.
        outputValueFunc = 
            let
                outputValueFuncHelper :: (Array a -> JObjectArray) -> (a -> JObject);
                outputValueFuncHelper = undefined;
            in                  
                asTypeOf output (outputValueFuncHelper outputArrayToJObjectArray);             
    in
        case array of
        CharArray {values} ->
            let            
                //size is computed eagerly because
                //a) it is safe to compute it out of order to weak-head normal form     
                //b) we know that it will eventually be used in outputArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk only to certainly evaluate that thunk later.
                //c) so that it can be lifted as a plinged argument of the local function outputArrayHelper  
                size :: Int;
                size = eager (array_length values);
                
                outputArrayHelper :: Int -> JObjectArray -> JObjectArray;
                outputArrayHelper !index !outputArray  =
                    if index < size then                   
                        objectArray_update outputArray index ((unsafeCoerce outputValueFunc) (eager (charArray_subscript values index)))
                        `seq`
                        outputArrayHelper (index + 1) outputArray
                    else
                        outputArray;                   
            in
                outputArrayHelper 0 (array_makeDefault size);  
        
        BooleanArray {values} ->
            let            
                //size is computed eagerly because
                //a) it is safe to compute it out of order to weak-head normal form     
                //b) we know that it will eventually be used in outputArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk only to certainly evaluate that thunk later.
                //c) so that it can be lifted as a plinged argument of the local function outputArrayHelper  
                size :: Int;
                size = eager (array_length values);
                
                outputArrayHelper :: Int -> JObjectArray -> JObjectArray;
                outputArrayHelper !index !outputArray  =
                    if index < size then                   
                        objectArray_update outputArray index ((unsafeCoerce outputValueFunc) (eager (booleanArray_subscript values index)))
                        `seq`
                        outputArrayHelper (index + 1) outputArray
                    else
                        outputArray;                   
            in
                outputArrayHelper 0 (array_makeDefault size);  
        
        ByteArray {values} ->
            let            
                //size is computed eagerly because
                //a) it is safe to compute it out of order to weak-head normal form     
                //b) we know that it will eventually be used in outputArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk only to certainly evaluate that thunk later.
                //c) so that it can be lifted as a plinged argument of the local function outputArrayHelper  
                size :: Int;
                size = eager (array_length values);
                
                outputArrayHelper :: Int -> JObjectArray -> JObjectArray;
                outputArrayHelper !index !outputArray  =
                    if index < size then                   
                        objectArray_update outputArray index ((unsafeCoerce outputValueFunc) (eager (byteArray_subscript values index)))
                        `seq`
                        outputArrayHelper (index + 1) outputArray
                    else
                        outputArray;                   
            in
                outputArrayHelper 0 (array_makeDefault size);  
        
        ShortArray {values} ->
            let            
                //size is computed eagerly because
                //a) it is safe to compute it out of order to weak-head normal form     
                //b) we know that it will eventually be used in outputArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk only to certainly evaluate that thunk later.
                //c) so that it can be lifted as a plinged argument of the local function outputArrayHelper  
                size :: Int;
                size = eager (array_length values);
                
                outputArrayHelper :: Int -> JObjectArray -> JObjectArray;
                outputArrayHelper !index !outputArray  =
                    if index < size then                   
                        objectArray_update outputArray index ((unsafeCoerce outputValueFunc) (eager (shortArray_subscript values index)))
                        `seq`
                        outputArrayHelper (index + 1) outputArray
                    else
                        outputArray;                   
            in
                outputArrayHelper 0 (array_makeDefault size);  
        
        IntArray {values} ->
            let            
                //size is computed eagerly because
                //a) it is safe to compute it out of order to weak-head normal form     
                //b) we know that it will eventually be used in outputArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk only to certainly evaluate that thunk later.
                //c) so that it can be lifted as a plinged argument of the local function outputArrayHelper  
                size :: Int;
                size = eager (array_length values);
                
                outputArrayHelper :: Int -> JObjectArray -> JObjectArray;
                outputArrayHelper !index !outputArray  =
                    if index < size then                   
                        objectArray_update outputArray index ((unsafeCoerce outputValueFunc) (eager (intArray_subscript values index)))
                        `seq`
                        outputArrayHelper (index + 1) outputArray
                    else
                        outputArray;                   
            in
                outputArrayHelper 0 (array_makeDefault size);  
        
        LongArray {values} ->
            let            
                //size is computed eagerly because
                //a) it is safe to compute it out of order to weak-head normal form     
                //b) we know that it will eventually be used in outputArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk only to certainly evaluate that thunk later.
                //c) so that it can be lifted as a plinged argument of the local function outputArrayHelper  
                size :: Int;
                size = eager (array_length values);
                
                outputArrayHelper :: Int -> JObjectArray -> JObjectArray;
                outputArrayHelper !index !outputArray  =
                    if index < size then                   
                        objectArray_update outputArray index ((unsafeCoerce outputValueFunc) (eager (longArray_subscript values index)))
                        `seq`
                        outputArrayHelper (index + 1) outputArray
                    else
                        outputArray;                   
            in
                outputArrayHelper 0 (array_makeDefault size);  
        
        FloatArray {values} ->
            let            
                //size is computed eagerly because
                //a) it is safe to compute it out of order to weak-head normal form     
                //b) we know that it will eventually be used in outputArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk only to certainly evaluate that thunk later.
                //c) so that it can be lifted as a plinged argument of the local function outputArrayHelper  
                size :: Int;
                size = eager (array_length values);
                
                outputArrayHelper :: Int -> JObjectArray -> JObjectArray;
                outputArrayHelper !index !outputArray  =
                    if index < size then                   
                        objectArray_update outputArray index ((unsafeCoerce outputValueFunc) (eager (floatArray_subscript values index)))
                        `seq`
                        outputArrayHelper (index + 1) outputArray
                    else
                        outputArray;                   
            in
                outputArrayHelper 0 (array_makeDefault size);  
        
        DoubleArray {values} ->
            let            
                //size is computed eagerly because
                //a) it is safe to compute it out of order to weak-head normal form     
                //b) we know that it will eventually be used in outputArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk only to certainly evaluate that thunk later.
                //c) so that it can be lifted as a plinged argument of the local function outputArrayHelper  
                size :: Int;
                size = eager (array_length values);
                
                outputArrayHelper :: Int -> JObjectArray -> JObjectArray;
                outputArrayHelper !index !outputArray  =
                    if index < size then                   
                        objectArray_update outputArray index ((unsafeCoerce outputValueFunc) (eager (doubleArray_subscript values index)))
                        `seq`
                        outputArrayHelper (index + 1) outputArray
                    else
                        outputArray;                   
            in
                outputArrayHelper 0 (array_makeDefault size);  
        
        ObjectArray {values} ->
            let            
                //size is computed eagerly because
                //a) it is safe to compute it out of order to weak-head normal form     
                //b) we know that it will eventually be used in outputArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk only to certainly evaluate that thunk later.
                //c) so that it can be lifted as a plinged argument of the local function outputArrayHelper  
                size :: Int;
                size = eager (array_length values);
                
                outputArrayHelper :: Int -> JObjectArray -> JObjectArray;
                outputArrayHelper !index !outputArray  =
                    if index < size then                   
                        objectArray_update outputArray index ((unsafeCoerce outputValueFunc) (eager (objectArray_subscript values index)))
                        `seq`
                        outputArrayHelper (index + 1) outputArray
                    else
                        outputArray;                   
            in
                outputArrayHelper 0 (array_makeDefault size);  
        
        CalValueArray {values} ->
            let            
                //size is computed eagerly because
                //a) it is safe to compute it out of order to weak-head normal form     
                //b) we know that it will eventually be used in outputArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk only to certainly evaluate that thunk later.
                //c) so that it can be lifted as a plinged argument of the local function outputArrayHelper 
                size :: Int;
                size = eager (array_length values);
                
                outputArrayHelper :: Int -> JObjectArray -> JObjectArray;
                outputArrayHelper !index !outputArray =
                    if index < size then                   
                        objectArray_update outputArray index ((unsafeCoerce outputValueFunc) (eager (calValueArray_subscript values index)))
                        `seq`
                        outputArrayHelper (index + 1) outputArray 
                    else
                        outputArray;                   
            in
                outputArrayHelper 0 (array_makeDefault size);
        
        EmptyArray ->
            empty;
    ;

/**
 * It is important that this function does not touch the value argument.
 */  
typeableElementType_fromValue :: Typeable a => a -> ElementType;  
typeableElementType_fromValue value = typeableElementType_fromTypeRep (typeOf value);  
        
typeableElementType_fromTypeRep :: TypeRep -> ElementType;
typeableElementType_fromTypeRep !elemType =
    
    case elemType of
    CharTypeRep {} ->
        CharType;
                 
    BooleanTypeRep {} ->
        BooleanType;  
        
    ByteTypeRep {} ->
        ByteType;  
        
    ShortTypeRep {} ->
        ShortType;
                    
    IntTypeRep {} ->
        IntType; 
       
    LongTypeRep {} ->
        LongType;
        
    FloatTypeRep {} ->
        FloatType;       
        
    DoubleTypeRep {} ->
        DoubleType;
           
    _ -> 
        if isForeignReferenceType elemType then 
            ObjectType 
        else
            CalValueType;
    ;

/**
 * Outputs the given array to a Java array.
 * 
 * In the case that a is one of the {@link Prelude@} types {@link Boolean@}, {@link Byte@}, {@link Short@}, {@link Int@},
 * {@link Long@}, {@link Float@} or {@link Double@}, the array will be a Java primitive array. For example,
 * {@code {@link typeConstructor = Array@} {@link Int@}@} will be output to a Java object of Java type {@code [int]@}
 * (and not {@code [java.util.Integer]@}).
 * 
 * In the case where {@code a@} is some other type, then the result will be a Java array whose elements are
 * Java objects determined by applying {@link Prelude.output@} to each of the elements of the CAL array. 
 */
outputPrimitive :: (Typeable a, Outputable a) => Array a -> JObject;
public outputPrimitive !array =
    let       
        typeableElementType :: ElementType;
        typeableElementType =
            let
                elementTypeHelper :: Array a -> a;
                elementTypeHelper = undefined;
            in            
                typeableElementType_fromValue (elementTypeHelper array);
    in
        if isEmpty array then
            case typeableElementType of
            CharType ->
                output (empty :: JCharArray);
            
            BooleanType ->
                output (empty :: JBooleanArray);            
            
            ByteType ->
                output (empty :: JByteArray);            
            
            ShortType ->
                output (empty :: JShortArray);
            
            IntType ->
                output (empty :: JIntArray);
            
            LongType ->
                output (empty :: JLongArray);
            
            FloatType ->
                output (empty :: JFloatArray);
            
            DoubleType ->
                output (empty :: JDoubleArray);
            
            (ObjectType|CalValueType) ->    
                output (empty :: JObjectArray);
            
        else
            case typeableElementType of
            CharType ->
                output (array_cloneReplacingNullArray array.CharArray.values);
            
            BooleanType ->
                output (array_cloneReplacingNullArray array.BooleanArray.values);            
            
            ByteType ->
                output (array_cloneReplacingNullArray array.ByteArray.values);            
            
            ShortType ->
                output (array_cloneReplacingNullArray array.ShortArray.values);
            
            IntType ->
                output (array_cloneReplacingNullArray array.IntArray.values);
            
            LongType ->
                output (array_cloneReplacingNullArray array.LongArray.values);
            
            FloatType ->
                output (array_cloneReplacingNullArray array.FloatArray.values);
            
            DoubleType ->
                output (array_cloneReplacingNullArray array.DoubleArray.values);
            
            (ObjectType|CalValueType) ->    
                output (outputArrayToJObjectArray array);
    ;

/**
 * {@code {@link typeConstructor = Array@} a@} will be input from a java.util.List or from a Java reference array (i.e. a
 * subtype of java.lang.Object[]).
 * 
 * The input format for the java.util.List or Java array is one whose elements are the Java objects required to input via {@link Prelude.input@}
 * for the element values. 
 * 
 * In the case that {@code a@} is one of the {@link Prelude@} types {@link Boolean@}, {@link Byte@}, {@link Short@}, {@link Int@},
 * {@link Long@}, {@link Float@} or {@link Double@}, the objects in the java.util.List or Java array should be the boxed representations of
 * the primitive values.
 */ 
 //todoBI this can be enhanced so that input works with Java iterators as well
instance Inputable a => Inputable (Array a) where
    input = inputArray;
    ;

foreign unsafe import jvm "instanceof java.util.List" isJList :: JObject -> Boolean;
foreign unsafe import jvm "method toArray" jListToJObjectArray:: JList -> JObject;

inputArray :: Inputable a => JObject -> Array a;
inputArray !object =
    if isJList object then
        inputArrayFromJObjectArray (input (jListToJObjectArray (input object)))
    else
        inputArrayFromJObjectArray (input object);
        
    
inputArrayFromJObjectArray :: Inputable a => JObjectArray -> Array a;
inputArrayFromJObjectArray !objectArray =
    let              
        //size and resultArray are computed eagerly because
        //a) it is safe to compute them out of order to weak-head normal form     
        //b) we know they will eventually be used in inputArrayHelper, so it is an efficiency gain to dispense with
        //   creating a thunk for them only to certainly evaluate that thunk later.
        //c) so they can be lifted as plinged arguments of the local function inputArrayHelper                                    
        size :: Int;
        size = eager (array_length objectArray);
    in
        if size == 0 then
            empty
        else
            let
                firstElementAsObject :: JObject;
                firstElementAsObject = objectArray_subscript objectArray 0;
                
                //obtain the specialization of Prelude.input to be used on the array elements
                //inputValueFunc :: Inputable a => JObject -> a;, where a is the 'a' in the inputArray type signature.
                inputValueFunc = 
                    let
                        inputValueFuncHelper :: (JObject -> Array a) -> (JObject -> a);
                        inputValueFuncHelper = undefined;
                    in                  
                        asTypeOf input (inputValueFuncHelper inputArray);                    
                
                firstElement = inputValueFunc firstElementAsObject;
            in
                case elementType_fromValue firstElement of
                
                CharType ->
                    let
                        //resultArray will be initialized by applying Prelude.input to each element of objectArray.                
                        resultArray :: JCharArray;
                        resultArray = eager (array_makeDefault size);
                        
                        inputArrayHelper :: Int -> JCharArray;                    
                        inputArrayHelper !index =
                            if index < size then                   
                                charArray_update resultArray index ((unsafeCoerce inputValueFunc) (eager (objectArray_subscript objectArray index)))
                                `seq`
                                inputArrayHelper (index + 1)
                            else
                                resultArray;    
                    in                  
                        CharArray (inputArrayHelper 0);         
                
                BooleanType ->
                    let
                        //resultArray will be initialized by applying Prelude.input to each element of objectArray.                
                        resultArray :: JBooleanArray;
                        resultArray = eager (array_makeDefault size);
                        
                        inputArrayHelper :: Int -> JBooleanArray;                    
                        inputArrayHelper !index =
                            if index < size then                   
                                booleanArray_update resultArray index ((unsafeCoerce inputValueFunc) (eager (objectArray_subscript objectArray index)))
                                `seq`
                                inputArrayHelper (index + 1)
                            else
                                resultArray;    
                    in                  
                        BooleanArray (inputArrayHelper 0);         
                
                ByteType ->
                    let
                        //resultArray will be initialized by applying Prelude.input to each element of objectArray.                
                        resultArray :: JByteArray;
                        resultArray = eager (array_makeDefault size);
                        
                        inputArrayHelper :: Int -> JByteArray;                    
                        inputArrayHelper !index =
                            if index < size then                   
                                byteArray_update resultArray index ((unsafeCoerce inputValueFunc) (eager (objectArray_subscript objectArray index)))
                                `seq`
                                inputArrayHelper (index + 1)
                            else
                                resultArray;    
                    in                  
                        ByteArray (inputArrayHelper 0);         
                
                ShortType ->
                    let
                        //resultArray will be initialized by applying Prelude.input to each element of objectArray.                
                        resultArray :: JShortArray;
                        resultArray = eager (array_makeDefault size);
                        
                        inputArrayHelper :: Int -> JShortArray;                    
                        inputArrayHelper !index =
                            if index < size then                   
                                shortArray_update resultArray index ((unsafeCoerce inputValueFunc) (eager (objectArray_subscript objectArray index)))
                                `seq`
                                inputArrayHelper (index + 1)
                            else
                                resultArray;    
                    in                  
                        ShortArray (inputArrayHelper 0);         
                
                IntType ->
                    let
                        //resultArray will be initialized by applying Prelude.input to each element of objectArray.                
                        resultArray :: JIntArray;
                        resultArray = eager (array_makeDefault size);
                        
                        inputArrayHelper :: Int -> JIntArray;                    
                        inputArrayHelper !index =
                            if index < size then                   
                                intArray_update resultArray index ((unsafeCoerce inputValueFunc) (eager (objectArray_subscript objectArray index)))
                                `seq`
                                inputArrayHelper (index + 1)
                            else
                                resultArray;    
                    in                  
                        IntArray (inputArrayHelper 0);         
                
                LongType ->
                    let
                        //resultArray will be initialized by applying Prelude.input to each element of objectArray.                
                        resultArray :: JLongArray;
                        resultArray = eager (array_makeDefault size);
                        
                        inputArrayHelper :: Int -> JLongArray;                    
                        inputArrayHelper !index =
                            if index < size then                   
                                longArray_update resultArray index ((unsafeCoerce inputValueFunc) (eager (objectArray_subscript objectArray index)))
                                `seq`
                                inputArrayHelper (index + 1)
                            else
                                resultArray;    
                    in                  
                        LongArray (inputArrayHelper 0);         
                
                FloatType ->
                    let
                        //resultArray will be initialized by applying Prelude.input to each element of objectArray.                
                        resultArray :: JFloatArray;
                        resultArray = eager (array_makeDefault size);
                        
                        inputArrayHelper :: Int -> JFloatArray;                    
                        inputArrayHelper !index =
                            if index < size then                   
                                floatArray_update resultArray index ((unsafeCoerce inputValueFunc) (eager (objectArray_subscript objectArray index)))
                                `seq`
                                inputArrayHelper (index + 1)
                            else
                                resultArray;    
                    in                  
                        FloatArray (inputArrayHelper 0);         
                
                DoubleType ->
                    let
                        //resultArray will be initialized by applying Prelude.input to each element of objectArray.                
                        resultArray :: JDoubleArray;
                        resultArray = eager (array_makeDefault size);
                        
                        inputArrayHelper :: Int -> JDoubleArray;                    
                        inputArrayHelper !index =
                            if index < size then                   
                                doubleArray_update resultArray index ((unsafeCoerce inputValueFunc) (eager (objectArray_subscript objectArray index)))
                                `seq`
                                inputArrayHelper (index + 1)
                            else
                                resultArray;    
                    in                  
                        DoubleArray (inputArrayHelper 0);         
                
                ObjectType ->
                    let
                        //resultArray will be initialized by applying Prelude.input to each element of objectArray.                
                        resultArray :: JObjectArray;
                        resultArray = eager (array_makeDefault size);
                        
                        inputArrayHelper :: Int -> JObjectArray;                    
                        inputArrayHelper !index =
                            if index < size then                   
                                objectArray_update resultArray index ((unsafeCoerce inputValueFunc) (eager (objectArray_subscript objectArray index)))
                                `seq`
                                inputArrayHelper (index + 1)
                            else
                                resultArray;    
                    in                  
                        ObjectArray (inputArrayHelper 0);         
                
                CalValueType ->             
                    let
                        //resultArray will be initialized by applying Prelude.input to each element of objectArray.                
                        resultArray :: JCalValueArray;
                        resultArray = eager (array_makeDefault size);                
                        
                        inputArrayHelper :: Int -> JCalValueArray;                    
                        inputArrayHelper !index =
                            if index < size then                   
                                calValueArray_update resultArray index ((unsafeCoerce inputValueFunc) (eager (objectArray_subscript objectArray index)))
                                `seq`
                                inputArrayHelper (index + 1)
                            else
                                resultArray;    
                    in                  
                        CalValueArray (inputArrayHelper 0); 
    ;

/**
 * Inputs an array from a Java array.
 * 
 * In the case that a is one of the {@link Prelude@} types {@link Boolean@}, {@link Byte@}, {@link Short@}, {@link Int@},
 * {@link Long@}, {@link Float@} or {@link Double@}, the array must be a Java primitive array. For example,
 * {@code {@link typeConstructor = Array@} {@link Int@}@} will be input from a Java object of Java type {@code [int]@}
 * (and not {@code [java.util.Integer]@}).
 * 
 * In the case where {@code a@} is some other type, then the input format is a Java array whose elements
 * are the Java objects required to input via {@link Prelude.input@} for the element values. 
 */ 
inputPrimitive :: (Typeable a, Inputable a) => JObject -> Array a;
public inputPrimitive !arrayAsObject =
    let       
        typeableElementType :: ElementType;
        typeableElementType =
            let
                elementTypeHelper :: (JObject -> Array a) -> a;
                elementTypeHelper = undefined;
            in                
                typeableElementType_fromValue (elementTypeHelper inputPrimitive); 
    in
        case typeableElementType of
        
        CharType ->
            let
                array :: JCharArray;
                array = eager $ input arrayAsObject;
            in
                if isEmpty array then
                    empty
                else
                    CharArray $ array_cloneReplacingNullArray array;
        
        BooleanType ->
            let
                array :: JBooleanArray;
                array = eager $ input arrayAsObject;
            in
                if isEmpty array then
                    empty
                else
                    BooleanArray $ array_cloneReplacingNullArray array;
        
        ByteType ->
            let
                array :: JByteArray;
                array = eager $ input arrayAsObject;
            in
                if isEmpty array then
                    empty
                else
                    ByteArray $ array_cloneReplacingNullArray array;
        
        ShortType ->
            let
                array :: JShortArray;
                array = eager $ input arrayAsObject;
            in
                if isEmpty array then
                    empty
                else
                    ShortArray $ array_cloneReplacingNullArray array;
        
        IntType ->
            let
                array :: JIntArray;
                array = eager $ input arrayAsObject;
            in
                if isEmpty array then
                    empty
                else
                    IntArray $ array_cloneReplacingNullArray array;
        
        LongType ->
            let
                array :: JLongArray;
                array = eager $ input arrayAsObject;
            in
                if isEmpty array then
                    empty
                else
                    LongArray $ array_cloneReplacingNullArray array;
        
        FloatType ->
            let
                array :: JFloatArray;
                array = eager $ input arrayAsObject;
            in
                if isEmpty array then
                    empty
                else
                    FloatArray $ array_cloneReplacingNullArray array;
        
        DoubleType ->
            let
                array :: JDoubleArray;
                array = eager $ input arrayAsObject;
            in
                if isEmpty array then
                    empty
                else
                    DoubleArray $ array_cloneReplacingNullArray array;
        
        (ObjectType|CalValueType) ->
            inputArray arrayAsObject;  
    ;
        
/* @example */
inputArrayExamples :: Boolean;
inputArrayExamples =
    assert ((input # output) (fromList ([] :: [Integer])) == fromList ([] :: [Integer]))    
    && assert ((input # output) (fromList ([] :: [Int])) == fromList ([] :: [Int]))    
    && assert ((input # output) (fromList ([] :: [Ordering])) == fromList ([] :: [Ordering]))    
    && assert ((input # output) (fromList ['a', 'b', 'c']) == fromList ['a', 'b', 'c'])    
    && assert ((input # output) (fromList [3.0, 1, 4]) == fromList [3.0, 1, 4])
    && assert ((input # output) (fromList [3.0, 1, 4]) != fromList [3.0, 1.1, 4])    
    && assert ((input # output) (fromList ["foo", "bar"]) == fromList ["foo", "bar"])
    && assert ((input # output) (fromList ["foo", "bar"]) != fromList ["foo", "bart"])
    && assert ((input # output) (fromList ["foo", "bar"]) != fromList ["foo", "bar", "zaphod"])
    && assert ((input # output) (fromList [1 :: Integer, 2, 3]) == fromList [1 :: Integer, 2, 3])
    && assert ((input # output) (fromList ([] :: [Integer])) != fromList [1 :: Integer, 2, 3])
    && assert ((input # output) (fromList [LT, GT, LT, EQ]) == fromList [LT, GT, LT, EQ])
    && assert ((input # output) (fromList [LT, GT, LT, EQ]) != fromList [LT, GT, LT, GT]) 
    && assert ((input # output) (fromList ([] :: [Ordering])) != fromList [LT, GT, LT, GT])   
    && assert ((input # output) (fromList [(2.0, "abc"), (10.0, "pear")]) == fromList [(2.0, "abc"), (10.0, "pear")])
    && assert ((input # output) (fromList [(2.0, "abc"), (10.0, "pear")]) != fromList [(2.0, "abc"), (9.0, "pear")])
    && assert ((input # output) (fromList [Just LT, Just GT, Just LT, Just EQ]) == fromList [Just LT, Just GT, Just LT, Just EQ])
    && assert ((input # output) (fromList [Just LT, Just GT, Just LT, Just EQ]) != fromList [Just LT, Just GT, Just LT, Just LT]) 
    && assert ((input # output) (fromList ([] :: [Maybe Ordering])) != array4 (Just LT) (Just GT) (Just LT) Nothing)    
    ;

/* @example */
inputPrimitiveExamples :: Boolean;
inputPrimitiveExamples =
    assert ((inputPrimitive # outputPrimitive) (fromList ([] :: [Integer])) == fromList ([] :: [Integer]))    
    && assert ((inputPrimitive # outputPrimitive) (fromList ([] :: [Int])) == fromList ([] :: [Int]))    
    && assert ((inputPrimitive # outputPrimitive) (fromList ([] :: [Ordering])) == fromList ([] :: [Ordering]))    
    && assert ((inputPrimitive # outputPrimitive) (fromList ['a', 'b', 'c']) == fromList ['a', 'b', 'c'])    
    && assert ((inputPrimitive # outputPrimitive) (fromList [3.0, 1, 4]) == fromList [3.0, 1, 4])
    && assert ((inputPrimitive # outputPrimitive) (fromList [3.0, 1, 4]) != fromList [3.0, 1.1, 4])    
    && assert ((inputPrimitive # outputPrimitive) (fromList ["foo", "bar"]) == fromList ["foo", "bar"])
    && assert ((inputPrimitive # outputPrimitive) (fromList ["foo", "bar"]) != fromList ["foo", "bart"])
    && assert ((inputPrimitive # outputPrimitive) (fromList ["foo", "bar"]) != fromList ["foo", "bar", "zaphod"])
    && assert ((inputPrimitive # outputPrimitive) (fromList [1 :: Integer, 2, 3]) == fromList [1 :: Integer, 2, 3])
    && assert ((inputPrimitive # outputPrimitive) (fromList ([] :: [Integer])) != fromList [1 :: Integer, 2, 3])
    && assert ((inputPrimitive # outputPrimitive) (fromList [LT, GT, LT, EQ]) == fromList [LT, GT, LT, EQ])
    && assert ((inputPrimitive # outputPrimitive) (fromList [LT, GT, LT, EQ]) != fromList [LT, GT, LT, GT]) 
    && assert ((inputPrimitive # outputPrimitive) (fromList ([] :: [Ordering])) != fromList [LT, GT, LT, GT])   
    && assert ((inputPrimitive # outputPrimitive) (fromList [(2.0, "abc"), (10.0, "pear")]) == fromList [(2.0, "abc"), (10.0, "pear")])
    && assert ((inputPrimitive # outputPrimitive) (fromList [(2.0, "abc"), (10.0, "pear")]) != fromList [(2.0, "abc"), (9.0, "pear")])
    && assert ((inputPrimitive # outputPrimitive) (fromList [Just LT, Just GT, Just LT, Just EQ]) == fromList [Just LT, Just GT, Just LT, Just EQ])
    && assert ((inputPrimitive # outputPrimitive) (fromList [Just LT, Just GT, Just LT, Just EQ]) != fromList [Just LT, Just GT, Just LT, Just LT]) 
    && assert ((inputPrimitive # outputPrimitive) (fromList ([] :: [Maybe Ordering])) != array4 (Just LT) (Just GT) (Just LT) Nothing)    
    ;

instance Eq a => Eq (Array a) where
    equals = equalsArray;
    notEquals = notEqualsArray;
    ;
    
/* @example */
eqArrayInstanceExamples :: Boolean;
eqArrayInstanceExamples =
    assert (fromList ([] :: [Integer]) == fromList ([] :: [Integer]))
    && assert (fromList ['a', 'b', 'c'] == fromList ['a', 'b', 'c'])
    && assert (fromList ['a', 'b', 'c'] != fromList [])
    && assert (fromList [3.0, 1, 4] == fromList [3, 1, 4])
    && assert (fromList [3.0, 1, 4] != fromList [3.0, 1.1, 4])    
    && assert (fromList ["foo", "bar"] == fromList ["foo", "bar"])
    && assert (fromList ["foo", "bar"] != fromList ["foo", "bart"])
    && assert (fromList ["foo", "bar"] != fromList ["foo", "bar", "zaphod"])
    && assert (fromList [1 :: Integer, 2, 3] == fromList [1, 2, 3])
    && assert (fromList [] != fromList [1 :: Integer, 2, 3])
    && assert (fromList [LT, GT, LT, EQ] == fromList [LT, GT, LT, EQ])
    && assert (fromList [LT, GT, LT, EQ] != fromList [LT, GT, LT, GT]) 
    && assert (fromList [] != fromList [LT, GT, LT, GT])   
    && assert (fromList [(2.0, "abc"), (10.0, "pear")] == fromList [(2.0, "abc"), (10.0, "pear")])
    && assert (fromList [(2.0, "abc"), (10.0, "pear")] != fromList [(2.0, "abc"), (9.0, "pear")])
    && assert (fromList [Just LT, Just GT, Just LT, Just EQ] == fromList [Just LT, Just GT, Just LT, Just EQ])
    && assert (fromList [Just LT, Just GT, Just LT, Just EQ] != fromList [Just LT, Just GT, Just LT, Just LT]) 
    && assert (fromList [] != fromList [Just LT, Just GT, Just LT, Nothing])  
    ;    
    
equalsArray :: Eq a => Array a -> Array a -> Boolean;    
equalsArray !array1 !array2 =
    if isEmpty array2 then
        isEmpty array1
    else
        let
            //obtain the specialization of Prelude.equals to be used on the array elements
            //equalsFunc :: Eq a => a -> a -> Boolean, where a is the 'a' in the equalsArray type signature.
            equalsFunc = 
                let
                    equalsFuncHelper :: Array a -> (a -> a -> Boolean);
                    equalsFuncHelper = undefined;
                in                  
                    asTypeOf equals (equalsFuncHelper array1);
        in
            case array1 of
            CharArray {values = values1} ->
                let
                    //size and values2 are computed eagerly because
                    //a) it is safe to compute them out of order to weak-head normal form     
                    //b) we know they will eventually be used in equalsArrayHelper, so it is an efficiency gain to dispense with
                    //   creating a thunk for them only to certainly evaluate that thunk later.
                    //c) so they can be lifted as plinged arguments of the local function equalsArrayHelper                     
                    size :: Int;
                    size = eager (array_length values1);
                    
                    values2 :: JCharArray;
                    values2 = eager (array2.CharArray.values);            
                in   
                    if size != array_length values2 then
                        False
                    else
                        let                
                            equalsArrayHelper :: Int -> Boolean;
                            equalsArrayHelper !index =
                                if index >= size then
                                    True
                                    //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                                    //at the specified indices and it is likely that any reasonable equalsFunc will examine both arguments.
                                else if (equalsFunc (unsafeCoerce (eager (charArray_subscript values1 index)))
                                         (unsafeCoerce (eager (charArray_subscript values2 index)))) then
                                             equalsArrayHelper (index + 1)
                                else
                                    False;
                        in
                            equalsArrayHelper 0;
            
            BooleanArray {values = values1} ->
                let
                    //size and values2 are computed eagerly because
                    //a) it is safe to compute them out of order to weak-head normal form     
                    //b) we know they will eventually be used in equalsArrayHelper, so it is an efficiency gain to dispense with
                    //   creating a thunk for them only to certainly evaluate that thunk later.
                    //c) so they can be lifted as plinged arguments of the local function equalsArrayHelper                     
                    size :: Int;
                    size = eager (array_length values1);
                    
                    values2 :: JBooleanArray;
                    values2 = eager (array2.BooleanArray.values);            
                in   
                    if size != array_length values2 then
                        False
                    else
                        let                
                            equalsArrayHelper :: Int -> Boolean;
                            equalsArrayHelper !index =
                                if index >= size then
                                    True
                                    //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                                    //at the specified indices and it is likely that any reasonable equalsFunc will examine both arguments.
                                else if (equalsFunc (unsafeCoerce (eager (booleanArray_subscript values1 index)))
                                         (unsafeCoerce (eager (booleanArray_subscript values2 index)))) then
                                             equalsArrayHelper (index + 1)
                                else
                                    False;
                        in
                            equalsArrayHelper 0; 
            
            ByteArray {values = values1} ->
                let
                    //size and values2 are computed eagerly because
                    //a) it is safe to compute them out of order to weak-head normal form     
                    //b) we know they will eventually be used in equalsArrayHelper, so it is an efficiency gain to dispense with
                    //   creating a thunk for them only to certainly evaluate that thunk later.
                    //c) so they can be lifted as plinged arguments of the local function equalsArrayHelper                     
                    size :: Int;
                    size = eager (array_length values1);
                    
                    values2 :: JByteArray;
                    values2 = eager (array2.ByteArray.values);            
                in   
                    if size != array_length values2 then
                        False
                    else
                        let                
                            equalsArrayHelper :: Int -> Boolean;
                            equalsArrayHelper !index =
                                if index >= size then
                                    True
                                    //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                                    //at the specified indices and it is likely that any reasonable equalsFunc will examine both arguments.
                                else if (equalsFunc (unsafeCoerce (eager (byteArray_subscript values1 index)))
                                         (unsafeCoerce (eager (byteArray_subscript values2 index)))) then
                                             equalsArrayHelper (index + 1)
                                else
                                    False;
                        in
                            equalsArrayHelper 0;
            
            ShortArray {values = values1} ->
                let
                    //size and values2 are computed eagerly because
                    //a) it is safe to compute them out of order to weak-head normal form     
                    //b) we know they will eventually be used in equalsArrayHelper, so it is an efficiency gain to dispense with
                    //   creating a thunk for them only to certainly evaluate that thunk later.
                    //c) so they can be lifted as plinged arguments of the local function equalsArrayHelper                     
                    size :: Int;
                    size = eager (array_length values1);
                    
                    values2 :: JShortArray;
                    values2 = eager (array2.ShortArray.values);            
                in   
                    if size != array_length values2 then
                        False
                    else
                        let                
                            equalsArrayHelper :: Int -> Boolean;
                            equalsArrayHelper !index =
                                if index >= size then
                                    True
                                    //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                                    //at the specified indices and it is likely that any reasonable equalsFunc will examine both arguments.
                                else if (equalsFunc (unsafeCoerce (eager (shortArray_subscript values1 index)))
                                         (unsafeCoerce (eager (shortArray_subscript values2 index)))) then
                                             equalsArrayHelper (index + 1)
                                else
                                    False;
                        in
                            equalsArrayHelper 0;
            
            IntArray {values = values1} ->
                let
                    //size and values2 are computed eagerly because
                    //a) it is safe to compute them out of order to weak-head normal form     
                    //b) we know they will eventually be used in equalsArrayHelper, so it is an efficiency gain to dispense with
                    //   creating a thunk for them only to certainly evaluate that thunk later.
                    //c) so they can be lifted as plinged arguments of the local function equalsArrayHelper                     
                    size :: Int;
                    size = eager (array_length values1);
                    
                    values2 :: JIntArray;
                    values2 = eager (array2.IntArray.values);            
                in   
                    if size != array_length values2 then
                        False
                    else
                        let                
                            equalsArrayHelper :: Int -> Boolean;
                            equalsArrayHelper !index =
                                if index >= size then
                                    True
                                    //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                                    //at the specified indices and it is likely that any reasonable equalsFunc will examine both arguments.
                                else if (equalsFunc (unsafeCoerce (eager (intArray_subscript values1 index)))
                                         (unsafeCoerce (eager (intArray_subscript values2 index)))) then
                                             equalsArrayHelper (index + 1)
                                else
                                    False;
                        in
                            equalsArrayHelper 0;
            
            LongArray {values = values1} ->
                let
                    //size and values2 are computed eagerly because
                    //a) it is safe to compute them out of order to weak-head normal form     
                    //b) we know they will eventually be used in equalsArrayHelper, so it is an efficiency gain to dispense with
                    //   creating a thunk for them only to certainly evaluate that thunk later.
                    //c) so they can be lifted as plinged arguments of the local function equalsArrayHelper                     
                    size :: Int;
                    size = eager (array_length values1);
                    
                    values2 :: JLongArray;
                    values2 = eager (array2.LongArray.values);            
                in   
                    if size != array_length values2 then
                        False
                    else
                        let                
                            equalsArrayHelper :: Int -> Boolean;
                            equalsArrayHelper !index =
                                if index >= size then
                                    True
                                    //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                                    //at the specified indices and it is likely that any reasonable equalsFunc will examine both arguments.
                                else if (equalsFunc (unsafeCoerce (eager (longArray_subscript values1 index)))
                                         (unsafeCoerce (eager (longArray_subscript values2 index)))) then
                                             equalsArrayHelper (index + 1)
                                else
                                    False;
                        in
                            equalsArrayHelper 0;
            
            FloatArray {values = values1} ->
                let
                    //size and values2 are computed eagerly because
                    //a) it is safe to compute them out of order to weak-head normal form     
                    //b) we know they will eventually be used in equalsArrayHelper, so it is an efficiency gain to dispense with
                    //   creating a thunk for them only to certainly evaluate that thunk later.
                    //c) so they can be lifted as plinged arguments of the local function equalsArrayHelper                     
                    size :: Int;
                    size = eager (array_length values1);
                    
                    values2 :: JFloatArray;
                    values2 = eager (array2.FloatArray.values);            
                in   
                    if size != array_length values2 then
                        False
                    else
                        let                
                            equalsArrayHelper :: Int -> Boolean;
                            equalsArrayHelper !index =
                                if index >= size then
                                    True
                                    //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                                    //at the specified indices and it is likely that any reasonable equalsFunc will examine both arguments.
                                else if (equalsFunc (unsafeCoerce (eager (floatArray_subscript values1 index)))
                                         (unsafeCoerce (eager (floatArray_subscript values2 index)))) then
                                             equalsArrayHelper (index + 1)
                                else
                                    False;
                        in
                            equalsArrayHelper 0;
            
            DoubleArray {values = values1} ->
                let
                    //size and values2 are computed eagerly because
                    //a) it is safe to compute them out of order to weak-head normal form     
                    //b) we know they will eventually be used in equalsArrayHelper, so it is an efficiency gain to dispense with
                    //   creating a thunk for them only to certainly evaluate that thunk later.
                    //c) so they can be lifted as plinged arguments of the local function equalsArrayHelper                     
                    size :: Int;
                    size = eager (array_length values1);
                    
                    values2 :: JDoubleArray;
                    values2 = eager (array2.DoubleArray.values);            
                in   
                    if size != array_length values2 then
                        False
                    else
                        let                
                            equalsArrayHelper :: Int -> Boolean;
                            equalsArrayHelper !index =
                                if index >= size then
                                    True
                                    //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                                    //at the specified indices and it is likely that any reasonable equalsFunc will examine both arguments.
                                else if (equalsFunc (unsafeCoerce (eager (doubleArray_subscript values1 index)))
                                         (unsafeCoerce (eager (doubleArray_subscript values2 index)))) then
                                             equalsArrayHelper (index + 1)
                                else
                                    False;
                        in
                            equalsArrayHelper 0;
            
            ObjectArray {values = values1} ->
                let
                    //size and values2 are computed eagerly because
                    //a) it is safe to compute them out of order to weak-head normal form     
                    //b) we know they will eventually be used in equalsArrayHelper, so it is an efficiency gain to dispense with
                    //   creating a thunk for them only to certainly evaluate that thunk later.
                    //c) so they can be lifted as plinged arguments of the local function equalsArrayHelper                     
                    size :: Int;
                    size = eager (array_length values1);
                    
                    values2 :: JObjectArray;
                    values2 = eager (array2.ObjectArray.values);            
                in   
                    if size != array_length values2 then
                        False
                    else
                        let                
                            equalsArrayHelper :: Int -> Boolean;
                            equalsArrayHelper !index =
                                if index >= size then
                                    True
                                    //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                                    //at the specified indices and it is likely that any reasonable equalsFunc will examine both arguments.
                                else if (equalsFunc (unsafeCoerce (eager (objectArray_subscript values1 index)))
                                         (unsafeCoerce (eager (objectArray_subscript values2 index)))) then
                                             equalsArrayHelper (index + 1)
                                else
                                    False;
                        in
                            equalsArrayHelper 0;
            
            CalValueArray {values = values1} ->
                let
                    //size and values2 are computed eagerly because
                    //a) it is safe to compute them out of order to weak-head normal form     
                    //b) we know they will eventually be used in equalsArrayHelper, so it is an efficiency gain to dispense with
                    //   creating a thunk for them only to certainly evaluate that thunk later.
                    //c) so they can be lifted as plinged arguments of the local function equalsArrayHelper                     
                    size :: Int;
                    size = eager (array_length values1);
                    
                    values2 :: JCalValueArray;
                    values2 = eager (array2.CalValueArray.values);            
                in   
                    if size != array_length values2 then
                        False
                    else
                        let                
                            equalsArrayHelper :: Int -> Boolean;
                            equalsArrayHelper !index =
                                if index >= size then
                                    True
                                    //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                                    //at the specified indices and it is likely that any reasonable equalsFunc will examine both arguments.                            
                                else if (equalsFunc (unsafeCoerce (eager (calValueArray_subscript values1 index)))
                                         (unsafeCoerce (eager (calValueArray_subscript values2 index)))) then
                                             equalsArrayHelper (index + 1)
                                else
                                    False;
                        in
                            equalsArrayHelper 0;
            
            EmptyArray ->
                False; // array2 is not empty, as established by the top if, so [] != [something]
    ;

notEqualsArray :: Eq a => Array a -> Array a -> Boolean;
notEqualsArray !array1 !array2 = not (equalsArray array1 array2);    

/**
 * Returns whether the two arrays are equal.
 * 
 * This should yield better performance for primitive arrays then the {@link equals@} class method for
 * {@link typeConstructor=Array@}.
 * 
 * @arg array1 the first argument to compare.
 * @arg array2 the second argument to compare.
 * @return {@link True@} if {@code array1@} and {@code array2@} are equal; {@link False@} otherwise.
 */
/*
 * @implementation
 * This function is currently protected in scope. We may want to revisit this later to consider how best to
 * expose this functionality in the API.
 * 
 * This higher performance alternative can be more naturally introduced via the use of overlapping instances,
 * when this feature becomes available in the language.
 */
equalsPrimitive :: (Typeable a, Eq a) => Array a -> Array a -> Boolean;    
protected equalsPrimitive !array1 !array2 =
    let
        isEmpty1 :: Boolean;
        isEmpty1 = eager $ isEmpty array1;
        
        isEmpty2 :: Boolean;
        isEmpty2 = eager $ isEmpty array2;
    in
        if isEmpty1 then
            isEmpty2
        else if isEmpty2 then
            isEmpty1
        else
            let       
                typeableElementType :: ElementType;
                typeableElementType =
                    let
                        elementTypeHelper :: Array a -> a;
                        elementTypeHelper = undefined;
                    in            
                        typeableElementType_fromValue (elementTypeHelper array1);
            in
                case typeableElementType of
                CharType ->
                    array1.CharArray.values == array2.CharArray.values;
                
                BooleanType ->
                    array1.BooleanArray.values == array2.BooleanArray.values;
                
                ByteType ->
                    array1.ByteArray.values == array2.ByteArray.values;
                
                ShortType ->
                    array1.ShortArray.values == array2.ShortArray.values;
                
                IntType ->
                    array1.IntArray.values == array2.IntArray.values;
                
                LongType ->
                    array1.LongArray.values == array2.LongArray.values;
                
                FloatType ->
                    array1.FloatArray.values == array2.FloatArray.values;
                
                DoubleType ->
                    array1.DoubleArray.values == array2.DoubleArray.values;
                
                _ ->
                    array1 == array2;
    ;

/* @example */
equalsPrimitiveExamples :: Boolean;
equalsPrimitiveExamples =
    let
        notEqualsPrimitive :: (Typeable a, Eq a) => Array a -> Array a -> Boolean;
        notEqualsPrimitive !array1 !array2 = not $ equalsPrimitive array1 array2;
    in
        assert (fromList ([] :: [Integer]) `equalsPrimitive` fromList ([] :: [Integer]))
        && assert (fromList ['a', 'b', 'c'] `equalsPrimitive` fromList ['a', 'b', 'c'])
        && assert (fromList ['a', 'b', 'c'] `notEqualsPrimitive` fromList [])
        && assert (fromList [3.0, 1, 4] `equalsPrimitive` fromList [3, 1, 4])
        && assert (fromList [3.0, 1, 4] `notEqualsPrimitive` fromList [3.0, 1.1, 4])    
        && assert (fromList ["foo", "bar"] `equalsPrimitive` fromList ["foo", "bar"])
        && assert (fromList ["foo", "bar"] `notEqualsPrimitive` fromList ["foo", "bart"])
        && assert (fromList ["foo", "bar"] `notEqualsPrimitive` fromList ["foo", "bar", "zaphod"])
        && assert (fromList [1 :: Integer, 2, 3] `equalsPrimitive` fromList [1, 2, 3])
        && assert (fromList [] `notEqualsPrimitive` fromList [1 :: Integer, 2, 3])
        && assert (fromList [LT, GT, LT, EQ] `equalsPrimitive` fromList [LT, GT, LT, EQ])
        && assert (fromList [LT, GT, LT, EQ] `notEqualsPrimitive` fromList [LT, GT, LT, GT]) 
        && assert (fromList [] `notEqualsPrimitive` fromList [LT, GT, LT, GT])   
        && assert (fromList [(2.0, "abc"), (10.0, "pear")] `equalsPrimitive` fromList [(2.0, "abc"), (10.0, "pear")])
        && assert (fromList [(2.0, "abc"), (10.0, "pear")] `notEqualsPrimitive` fromList [(2.0, "abc"), (9.0, "pear")])
        && assert (fromList [Just LT, Just GT, Just LT, Just EQ] `equalsPrimitive` fromList [Just LT, Just GT, Just LT, Just EQ])
        && assert (fromList [Just LT, Just GT, Just LT, Just EQ] `notEqualsPrimitive` fromList [Just LT, Just GT, Just LT, Just LT]) 
        && assert (fromList [] `notEqualsPrimitive` fromList [Just LT, Just GT, Just LT, Nothing])  
    ;    
    
instance Ord a => Ord (Array a) where
    lessThan = lessThanArray;
    lessThanEquals = lessThanEqualsArray;
    greaterThanEquals = greaterThanEqualsArray;
    greaterThan = greaterThanArray;
    compare = compareArray;
    max = maxArray;
    min = minArray;
    ;

compareArray :: Ord a => Array a -> Array a -> Ordering;    
compareArray !array1 !array2 =
    if isEmpty array2 then
        if isEmpty array1 then
            EQ // [] == []
        else
            GT // [something] > []
    else
        case array1 of
        CharArray {values = values1} ->
            let
                //nValues1, nValues2, values2 and minNValues are computed eagerly because
                //a) it is safe to compute them out of order to weak-head normal form     
                //b) we know they will eventually be used in compareArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk for them only to certainly evaluate that thunk later.
                //c) so they can be lifted as plinged arguments of the local function compareArrayHelper                      
                nValues1 :: Int;
                nValues1 = eager (array_length values1);
                
                values2 :: JCharArray;
                values2 = eager (array2.CharArray.values);
                
                nValues2 :: Int;
                nValues2 = eager (array_length values2);
                
                minNValues :: Int;
                minNValues = eager (min nValues1 nValues2);
            in              
                let                
                    //obtain the specialization of Prelude.compare to be used on the array elements
                    //compareFunc :: Ord a => a -> a -> Ordering, where a is the 'a' in the compareArray type signature.
                    compareFunc = 
                        let
                            compareFuncHelper :: Array a -> (a -> a -> Ordering);
                            compareFuncHelper = undefined;
                        in                  
                            asTypeOf compare (compareFuncHelper array1);
                    
                    compareArrayHelper :: Int -> Ordering;
                    compareArrayHelper !index =
                        if index >= minNValues then
                            compare nValues1 nValues2                        
                        else
                            //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                            //at the specified indices and it is likely that any reasonable compareFunc will examine both arguments.   
                            case (compareFunc (unsafeCoerce (eager (charArray_subscript values1 index)))
                                  (unsafeCoerce (eager (charArray_subscript values2 index)))) of
                                  LT -> LT;
                                  EQ -> compareArrayHelper (index + 1);
                                  GT -> GT;
                        ;                    
                in
                    compareArrayHelper 0;
        
        BooleanArray {values = values1} ->
            let
                //nValues1, nValues2, values2 and minNValues are computed eagerly because
                //a) it is safe to compute them out of order to weak-head normal form     
                //b) we know they will eventually be used in compareArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk for them only to certainly evaluate that thunk later.
                //c) so they can be lifted as plinged arguments of the local function compareArrayHelper                      
                nValues1 :: Int;
                nValues1 = eager (array_length values1);
                
                values2 :: JBooleanArray;
                values2 = eager (array2.BooleanArray.values);
                
                nValues2 :: Int;
                nValues2 = eager (array_length values2);
                
                minNValues :: Int;
                minNValues = eager (min nValues1 nValues2);
            in              
                let                
                    //obtain the specialization of Prelude.compare to be used on the array elements
                    //compareFunc :: Ord a => a -> a -> Ordering, where a is the 'a' in the compareArray type signature.
                    compareFunc = 
                        let
                            compareFuncHelper :: Array a -> (a -> a -> Ordering);
                            compareFuncHelper = undefined;
                        in                  
                            asTypeOf compare (compareFuncHelper array1);
                    
                    compareArrayHelper :: Int -> Ordering;
                    compareArrayHelper !index =
                        if index >= minNValues then
                            compare nValues1 nValues2                        
                        else
                            //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                            //at the specified indices and it is likely that any reasonable compareFunc will examine both arguments.   
                            case (compareFunc (unsafeCoerce (eager (booleanArray_subscript values1 index)))
                                  (unsafeCoerce (eager (booleanArray_subscript values2 index)))) of
                                  LT -> LT;
                                  EQ -> compareArrayHelper (index + 1);
                                  GT -> GT;
                        ;                    
                in
                    compareArrayHelper 0;
        
        ByteArray {values = values1} ->
            let
                //nValues1, nValues2, values2 and minNValues are computed eagerly because
                //a) it is safe to compute them out of order to weak-head normal form     
                //b) we know they will eventually be used in compareArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk for them only to certainly evaluate that thunk later.
                //c) so they can be lifted as plinged arguments of the local function compareArrayHelper                      
                nValues1 :: Int;
                nValues1 = eager (array_length values1);
                
                values2 :: JByteArray;
                values2 = eager (array2.ByteArray.values);
                
                nValues2 :: Int;
                nValues2 = eager (array_length values2);
                
                minNValues :: Int;
                minNValues = eager (min nValues1 nValues2);
            in              
                let                
                    //obtain the specialization of Prelude.compare to be used on the array elements
                    //compareFunc :: Ord a => a -> a -> Ordering, where a is the 'a' in the compareArray type signature.
                    compareFunc = 
                        let
                            compareFuncHelper :: Array a -> (a -> a -> Ordering);
                            compareFuncHelper = undefined;
                        in                  
                            asTypeOf compare (compareFuncHelper array1);
                    
                    compareArrayHelper :: Int -> Ordering;
                    compareArrayHelper !index =
                        if index >= minNValues then
                            compare nValues1 nValues2                        
                        else
                            //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                            //at the specified indices and it is likely that any reasonable compareFunc will examine both arguments.   
                            case (compareFunc (unsafeCoerce (eager (byteArray_subscript values1 index)))
                                  (unsafeCoerce (eager (byteArray_subscript values2 index)))) of
                                  LT -> LT;
                                  EQ -> compareArrayHelper (index + 1);
                                  GT -> GT;
                        ;                    
                in
                    compareArrayHelper 0;
        
        ShortArray {values = values1} ->
            let
                //nValues1, nValues2, values2 and minNValues are computed eagerly because
                //a) it is safe to compute them out of order to weak-head normal form     
                //b) we know they will eventually be used in compareArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk for them only to certainly evaluate that thunk later.
                //c) so they can be lifted as plinged arguments of the local function compareArrayHelper                      
                nValues1 :: Int;
                nValues1 = eager (array_length values1);
                
                values2 :: JShortArray;
                values2 = eager (array2.ShortArray.values);
                
                nValues2 :: Int;
                nValues2 = eager (array_length values2);
                
                minNValues :: Int;
                minNValues = eager (min nValues1 nValues2);
            in              
                let                
                    //obtain the specialization of Prelude.compare to be used on the array elements
                    //compareFunc :: Ord a => a -> a -> Ordering, where a is the 'a' in the compareArray type signature.
                    compareFunc = 
                        let
                            compareFuncHelper :: Array a -> (a -> a -> Ordering);
                            compareFuncHelper = undefined;
                        in                  
                            asTypeOf compare (compareFuncHelper array1);
                    
                    compareArrayHelper :: Int -> Ordering;
                    compareArrayHelper !index =
                        if index >= minNValues then
                            compare nValues1 nValues2                        
                        else
                            //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                            //at the specified indices and it is likely that any reasonable compareFunc will examine both arguments.   
                            case (compareFunc (unsafeCoerce (eager (shortArray_subscript values1 index)))
                                  (unsafeCoerce (eager (shortArray_subscript values2 index)))) of
                                  LT -> LT;
                                  EQ -> compareArrayHelper (index + 1);
                                  GT -> GT;
                        ;                    
                in
                    compareArrayHelper 0;
        
        IntArray {values = values1} ->
            let
                //nValues1, nValues2, values2 and minNValues are computed eagerly because
                //a) it is safe to compute them out of order to weak-head normal form     
                //b) we know they will eventually be used in compareArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk for them only to certainly evaluate that thunk later.
                //c) so they can be lifted as plinged arguments of the local function compareArrayHelper                      
                nValues1 :: Int;
                nValues1 = eager (array_length values1);
                
                values2 :: JIntArray;
                values2 = eager (array2.IntArray.values);
                
                nValues2 :: Int;
                nValues2 = eager (array_length values2);
                
                minNValues :: Int;
                minNValues = eager (min nValues1 nValues2);
            in              
                let                
                    //obtain the specialization of Prelude.compare to be used on the array elements
                    //compareFunc :: Ord a => a -> a -> Ordering, where a is the 'a' in the compareArray type signature.
                    compareFunc = 
                        let
                            compareFuncHelper :: Array a -> (a -> a -> Ordering);
                            compareFuncHelper = undefined;
                        in                  
                            asTypeOf compare (compareFuncHelper array1);
                    
                    compareArrayHelper :: Int -> Ordering;
                    compareArrayHelper !index =
                        if index >= minNValues then
                            compare nValues1 nValues2                        
                        else
                            //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                            //at the specified indices and it is likely that any reasonable compareFunc will examine both arguments.   
                            case (compareFunc (unsafeCoerce (eager (intArray_subscript values1 index)))
                                  (unsafeCoerce (eager (intArray_subscript values2 index)))) of
                                  LT -> LT;
                                  EQ -> compareArrayHelper (index + 1);
                                  GT -> GT;
                        ;                    
                in
                    compareArrayHelper 0;
        
        LongArray {values = values1} ->
            let
                //nValues1, nValues2, values2 and minNValues are computed eagerly because
                //a) it is safe to compute them out of order to weak-head normal form     
                //b) we know they will eventually be used in compareArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk for them only to certainly evaluate that thunk later.
                //c) so they can be lifted as plinged arguments of the local function compareArrayHelper                      
                nValues1 :: Int;
                nValues1 = eager (array_length values1);
                
                values2 :: JLongArray;
                values2 = eager (array2.LongArray.values);
                
                nValues2 :: Int;
                nValues2 = eager (array_length values2);
                
                minNValues :: Int;
                minNValues = eager (min nValues1 nValues2);
            in              
                let                
                    //obtain the specialization of Prelude.compare to be used on the array elements
                    //compareFunc :: Ord a => a -> a -> Ordering, where a is the 'a' in the compareArray type signature.
                    compareFunc = 
                        let
                            compareFuncHelper :: Array a -> (a -> a -> Ordering);
                            compareFuncHelper = undefined;
                        in                  
                            asTypeOf compare (compareFuncHelper array1);
                    
                    compareArrayHelper :: Int -> Ordering;
                    compareArrayHelper !index =
                        if index >= minNValues then
                            compare nValues1 nValues2                        
                        else
                            //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                            //at the specified indices and it is likely that any reasonable compareFunc will examine both arguments.   
                            case (compareFunc (unsafeCoerce (eager (longArray_subscript values1 index)))
                                  (unsafeCoerce (eager (longArray_subscript values2 index)))) of
                                  LT -> LT;
                                  EQ -> compareArrayHelper (index + 1);
                                  GT -> GT;
                        ;                    
                in
                    compareArrayHelper 0;
        
        FloatArray {values = values1} ->
            let
                //nValues1, nValues2, values2 and minNValues are computed eagerly because
                //a) it is safe to compute them out of order to weak-head normal form     
                //b) we know they will eventually be used in compareArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk for them only to certainly evaluate that thunk later.
                //c) so they can be lifted as plinged arguments of the local function compareArrayHelper                      
                nValues1 :: Int;
                nValues1 = eager (array_length values1);
                
                values2 :: JFloatArray;
                values2 = eager (array2.FloatArray.values);
                
                nValues2 :: Int;
                nValues2 = eager (array_length values2);
                
                minNValues :: Int;
                minNValues = eager (min nValues1 nValues2);
            in              
                let                
                    //obtain the specialization of Prelude.compare to be used on the array elements
                    //compareFunc :: Ord a => a -> a -> Ordering, where a is the 'a' in the compareArray type signature.
                    compareFunc = 
                        let
                            compareFuncHelper :: Array a -> (a -> a -> Ordering);
                            compareFuncHelper = undefined;
                        in                  
                            asTypeOf compare (compareFuncHelper array1);
                    
                    compareArrayHelper :: Int -> Ordering;
                    compareArrayHelper !index =
                        if index >= minNValues then
                            compare nValues1 nValues2                        
                        else
                            //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                            //at the specified indices and it is likely that any reasonable compareFunc will examine both arguments.   
                            case (compareFunc (unsafeCoerce (eager (floatArray_subscript values1 index)))
                                  (unsafeCoerce (eager (floatArray_subscript values2 index)))) of
                                  LT -> LT;
                                  EQ -> compareArrayHelper (index + 1);
                                  GT -> GT;
                        ;                    
                in
                    compareArrayHelper 0;
        
        DoubleArray {values = values1} ->
            let
                //nValues1, nValues2, values2 and minNValues are computed eagerly because
                //a) it is safe to compute them out of order to weak-head normal form     
                //b) we know they will eventually be used in compareArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk for them only to certainly evaluate that thunk later.
                //c) so they can be lifted as plinged arguments of the local function compareArrayHelper                      
                nValues1 :: Int;
                nValues1 = eager (array_length values1);
                
                values2 :: JDoubleArray;
                values2 = eager (array2.DoubleArray.values);
                
                nValues2 :: Int;
                nValues2 = eager (array_length values2);
                
                minNValues :: Int;
                minNValues = eager (min nValues1 nValues2);
            in              
                let                
                    //obtain the specialization of Prelude.compare to be used on the array elements
                    //compareFunc :: Ord a => a -> a -> Ordering, where a is the 'a' in the compareArray type signature.
                    compareFunc = 
                        let
                            compareFuncHelper :: Array a -> (a -> a -> Ordering);
                            compareFuncHelper = undefined;
                        in                  
                            asTypeOf compare (compareFuncHelper array1);
                    
                    compareArrayHelper :: Int -> Ordering;
                    compareArrayHelper !index =
                        if index >= minNValues then
                            compare nValues1 nValues2                        
                        else
                            //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                            //at the specified indices and it is likely that any reasonable compareFunc will examine both arguments.   
                            case (compareFunc (unsafeCoerce (eager (doubleArray_subscript values1 index)))
                                  (unsafeCoerce (eager (doubleArray_subscript values2 index)))) of
                                  LT -> LT;
                                  EQ -> compareArrayHelper (index + 1);
                                  GT -> GT;
                        ;                    
                in
                    compareArrayHelper 0;
        
        ObjectArray {values = values1} ->
            let
                //nValues1, nValues2, values2 and minNValues are computed eagerly because
                //a) it is safe to compute them out of order to weak-head normal form     
                //b) we know they will eventually be used in compareArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk for them only to certainly evaluate that thunk later.
                //c) so they can be lifted as plinged arguments of the local function compareArrayHelper                      
                nValues1 :: Int;
                nValues1 = eager (array_length values1);
                
                values2 :: JObjectArray;
                values2 = eager (array2.ObjectArray.values);
                
                nValues2 :: Int;
                nValues2 = eager (array_length values2);
                
                minNValues :: Int;
                minNValues = eager (min nValues1 nValues2);
            in              
                let                
                    //obtain the specialization of Prelude.compare to be used on the array elements
                    //compareFunc :: Ord a => a -> a -> Ordering, where a is the 'a' in the compareArray type signature.
                    compareFunc = 
                        let
                            compareFuncHelper :: Array a -> (a -> a -> Ordering);
                            compareFuncHelper = undefined;
                        in                  
                            asTypeOf compare (compareFuncHelper array1);
                    
                    compareArrayHelper :: Int -> Ordering;
                    compareArrayHelper !index =
                        if index >= minNValues then
                            compare nValues1 nValues2                        
                        else
                            //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                            //at the specified indices and it is likely that any reasonable compareFunc will examine both arguments.   
                            case (compareFunc (unsafeCoerce (eager (objectArray_subscript values1 index)))
                                  (unsafeCoerce (eager (objectArray_subscript values2 index)))) of
                                  LT -> LT;
                                  EQ -> compareArrayHelper (index + 1);
                                  GT -> GT;
                        ;                    
                in
                    compareArrayHelper 0;
        
        CalValueArray {values = values1} ->
            let
                //nValues1, nValues2, values2 and minNValues are computed eagerly because
                //a) it is safe to compute them out of order to weak-head normal form     
                //b) we know they will eventually be used in compareArrayHelper, so it is an efficiency gain to dispense with
                //   creating a thunk for them only to certainly evaluate that thunk later.
                //c) so they can be lifted as plinged arguments of the local function compareArrayHelper        
                nValues1 :: Int;
                nValues1 = eager (array_length values1);
                
                values2 :: JCalValueArray;
                values2 = eager (array2.CalValueArray.values);   
                
                nValues2 :: Int;
                nValues2 = eager (array_length values2);
                
                minNValues :: Int;
                minNValues = eager (min nValues1 nValues2);
            in              
                let                
                    //obtain the specialization of Prelude.compare to be used on the array elements
                    //compareFunc :: Ord a => a -> a -> Ordering, where a is the 'a' in the compareArray type signature.
                    compareFunc = 
                        let
                            compareFuncHelper :: Array a -> (a -> a -> Ordering);
                            compareFuncHelper = undefined;
                        in                  
                            asTypeOf compare (compareFuncHelper array1);
                    
                    compareArrayHelper :: Int -> Ordering;
                    compareArrayHelper !index =
                        if index >= minNValues then
                            compare nValues1 nValues2                        
                        else
                            //the subscript operations are done eagerly because we know it is safe to subscript the arrays
                            //at the specified indices and it is likely that any reasonable compareFunc will examine both arguments.                        
                            case (compareFunc (unsafeCoerce (eager (calValueArray_subscript values1 index)))
                                  (unsafeCoerce (eager (calValueArray_subscript values2 index)))) of
                                  LT -> LT;
                                  EQ -> compareArrayHelper (index + 1);
                                  GT -> GT;
                        ;                  
                in
                    compareArrayHelper 0;
        
        EmptyArray ->
            LT; // array2 is not empty, as established by the top if, so [] < [something]
    ;

//for now, implement in terms of compareArray, but we can later "inline" this using the direct primitive array comparisons
    
lessThanArray :: Ord a => Array a -> Array a -> Boolean;
lessThanArray !array1 !array2 = compareArray array1 array2 == LT;

lessThanEqualsArray :: Ord a => Array a -> Array a -> Boolean;
lessThanEqualsArray !array1 !array2 = compareArray array1 array2 != GT;

greaterThanEqualsArray :: Ord a => Array a -> Array a -> Boolean;
greaterThanEqualsArray !array1 !array2 = compareArray array1 array2 != LT;

greaterThanArray :: Ord a => Array a -> Array a -> Boolean;
greaterThanArray !array1 !array2 = compareArray array1 array2 == GT;

maxArray :: Ord a => Array a -> Array a -> Array a;
maxArray !array1 !array2 = if array1 <= array2 then array2 else array1;

minArray :: Ord a => Array a -> Array a -> Array a;
minArray !array1 !array2 = if array1 <= array2 then array1 else array2;

/**
 * Returns an {@link Ordering@} based on how the first array compares to the second array.
 * 
 * This should yield better performance for primitive arrays then the {@link compare@} class method for
 * {@link typeConstructor=Array@}.
 * 
 * @arg array1 the first argument to compare.
 * @arg array2 the second argument to compare.
 * @return {@link LT@}, {@link EQ@}, or {@link GT@} if {@code array1@} is respectively less than, equal to, or greater than
 *         {@code array2@}.
 */
/*
 * @implementation
 * This function is currently protected in scope. We may want to revisit this later to consider how best to
 * expose this functionality in the API.
 * 
 * This higher performance alternative can be more naturally introduced via the use of overlapping instances,
 * when this feature becomes available in the language.
 */
comparePrimitive :: (Typeable a, Ord a) => Array a -> Array a -> Ordering;    
protected comparePrimitive !array1 !array2 =
    let
        isEmpty1 :: Boolean;
        isEmpty1 = eager $ isEmpty array1;
        
        isEmpty2 :: Boolean;
        isEmpty2 = eager $ isEmpty array2;
    in
        if isEmpty1 || isEmpty2 then
            if isEmpty2 then
                if isEmpty1 then
                    EQ // [] == []
                else
                    GT // [something] > []
            else // isEmpty1 is True by top level (isEmpty1 || isEmpty2)
                LT // [] < [something]
        else
            let       
                typeableElementType :: ElementType;
                typeableElementType =
                    let
                        elementTypeHelper :: Array a -> a;
                        elementTypeHelper = undefined;
                    in            
                        typeableElementType_fromValue (elementTypeHelper array1);
            in
                case typeableElementType of
                CharType ->
                    compare array1.CharArray.values array2.CharArray.values;
                
                BooleanType ->
                    compare array1.BooleanArray.values array2.BooleanArray.values;
                
                ByteType ->
                    compare array1.ByteArray.values array2.ByteArray.values;
                
                ShortType ->
                    compare array1.ShortArray.values array2.ShortArray.values;
                
                IntType ->
                    compare array1.IntArray.values array2.IntArray.values;
                
                LongType ->
                    compare array1.LongArray.values array2.LongArray.values;
                
                FloatType ->
                    compare array1.FloatArray.values array2.FloatArray.values;
                
                DoubleType ->
                    compare array1.DoubleArray.values array2.DoubleArray.values;
                
                _ ->
                    compare array1 array2;
    ;

/* @example */
comparePrimitiveExamples :: Boolean;
comparePrimitiveExamples =
    let
        eq :: (Typeable a, Ord a) => Array a -> Array a -> Boolean;
        eq !x !y = x `comparePrimitive` y == EQ;
        
        lt :: (Typeable a, Ord a) => Array a -> Array a -> Boolean;
        lt !x !y = x `comparePrimitive` y == LT;
        
        gt :: (Typeable a, Ord a) => Array a -> Array a -> Boolean;
        gt !x !y = x `comparePrimitive` y == GT;
    in
        assert (fromList ([] :: [Integer]) `eq` fromList ([] :: [Integer]))
        && assert (fromList ['a', 'b', 'c'] `eq` fromList ['a', 'b', 'c'])
        && assert (fromList ['a', 'b', 'c'] `gt` fromList [])
        && assert (fromList [3.0, 1, 4] `eq` fromList [3, 1, 4])
        && assert (fromList [3.0, 1, 4] `lt` fromList [3.0, 1.1, 4])    
        && assert (fromList ["foo", "bar"] `eq` fromList ["foo", "bar"])
        && assert (fromList ["foo", "bar"] `lt` fromList ["foo", "bart"])
        && assert (fromList ["foo", "bar"] `lt` fromList ["foo", "bar", "zaphod"])
        && assert (fromList [1 :: Integer, 2, 3] `eq` fromList [1, 2, 3])
        && assert (fromList [] `lt` fromList [1 :: Integer, 2, 3])
        && assert (fromList [LT, GT, LT, EQ] `eq` fromList [LT, GT, LT, EQ])
        && assert (fromList [LT, GT, LT, EQ] `lt` fromList [LT, GT, LT, GT]) 
        && assert (fromList [] `lt` fromList [LT, GT, LT, GT])   
        && assert (fromList [(2.0, "abc"), (10.0, "pear")] `eq` fromList [(2.0, "abc"), (10.0, "pear")])
        && assert (fromList [(2.0, "abc"), (10.0, "pear")] `gt` fromList [(2.0, "abc"), (9.0, "pear")])
        && assert (fromList [Just LT, Just GT, Just LT, Just EQ] `eq` fromList [Just LT, Just GT, Just LT, Just EQ])
        && assert (fromList [Just LT, Just GT, Just LT, Just EQ] `gt` fromList [Just LT, Just GT, Just LT, Just LT]) 
        && assert (fromList [] `lt` fromList [Just LT, Just GT, Just LT, Nothing])  
    ;    
    
//todoBI for Strings this is called indexOf. We should adopt consistent terminology...
/**
 * Returns the index of the first element in the given array which is equal to
 * the specified value, or {@link Nothing@} if there is no such element.
 * 
 * @arg value the value to be found.
 * @arg array the array to be searched.
 * @return the index of the first element in the given array which is equal to
 *         the specified value, or {@link Nothing@} if there is no such element.
 */
elemIndex :: Eq a => a -> Array a -> Maybe Int;
public elemIndex value !array =
    intToMaybe (indexOf value array);       
    
/* @example */
elemIndexExamples :: Boolean;
elemIndexExamples =
    assert (elemIndex 'b' (fromList ['a', 'b', 'c']) == Just 1)  
    && assert (elemIndex 'd' (fromList ['a', 'b', 'c']) == Nothing)      
    && assert (elemIndex 'e' (fromList (empty :: [Char])) == Nothing)
    && assert (elemIndex 3 (fromList [3 :: Long, 1]) == Just 0)
    && assert (elemIndex 1 (fromList [3.0, 1, 4, 1]) == Just 1)    
    && assert (elemIndex "bar" (fromList ["foo", "bar"]) == Just 1)
    && assert (elemIndex "zaphod" (fromList ["foo", "bar"]) == Nothing)
    && assert (elemIndex 3 (fromList [1 :: Integer, 2, 1, 2, 5, 3, 2]) == Just 5)    
    && assert (elemIndex LT (fromList [LT, GT, LT, EQ]) == Just 0)          
    && assert (elemIndex (10.0, "apple") (fromList [(2.0, "abc"), (10.0, "pear")]) == Nothing) 
    && assert (elemIndex (10.0, "pear") (fromList [(2.0, "abc"), (10.0, "pear")]) == Just 1)     
    && assert (elemIndex (100, "fred") (fromList (empty :: [(Double, String)])) == Nothing)
    && assert (elemIndex Nothing (fromList [Just LT, Just GT, Nothing, Just EQ]) == Just 2)  
    && assert (elemIndex (Just EQ) (fromList [Just LT, Just GT, Nothing, Just EQ]) == Just 3)    
    ; 

/**
 * Returns the indices of all elements of the specified array equal to the
 * specified value, in ascending order.
 * 
 * @arg x the value to be found.
 * @arg array the array to be searched.
 * @return the indices of all elements of the specified array equal to the
 *         specified value, in ascending order.
 */
elemIndices :: Eq a => a -> Array a -> Array Int;
public elemIndices !x !array =
    let
        size :: Int;
        size = eager $ length array;
        
        count :: Int -> Int -> Int;
        count !index !n = 
            if index >= size then
                n
            else if (eager $ subscript array index) == x then
                count (index + 1) (n + 1)
            else
                count (index + 1) n;
        
        nIndices :: Int;
        nIndices = eager $ count 0 0;
    in
        if nIndices == 0 then
            empty
        else
            let
                indexArray :: Array Int;
                indexArray = eager $ makeDefaultInternal IntType nIndices;
                
                findIndices :: Int -> Int -> Array Int;
                findIndices !readIndex !writeIndex =
                    if readIndex >= size then
                        indexArray
                    else if (eager $ subscript array readIndex) == x then
                        update indexArray writeIndex readIndex
                        `seq`
                        findIndices (readIndex + 1) (writeIndex + 1)
                    else
                        findIndices (readIndex + 1) writeIndex;
            in
                findIndices 0 0;

/* @example */
elemIndicesExamples :: Boolean;
elemIndicesExamples =
    assert (elemIndices 2.0 (fromList [1.0, 2, 3, 2, 4, 2, 5, 2]) == fromList [1, 3, 5, 7]) &&
    assert (elemIndices 'a' (fromList ([] :: [Char])) == fromList []) &&
    assert (elemIndices 'a' (fromList ['q', 'w', 'e', 'r', 't', 'y']) == fromList []) &&
    assert (elemIndices 'a' (fromList ['a', 'a', 'a']) == fromList [0, 1, 2]);

/**
 * Finds the index of the first occurrence of {@code valueToFind@} in {@code array@} or -1 if the value does not occur.
 * 
 * @arg valueToFind
 * @arg array
 * @return the index of the first occurrence of {@code valueToFind@} in {@code array@} or -1 if the value does not occur.
 */
indexOf :: Eq a => a -> Array a -> Int;
public indexOf !valueToFind !array =
    indexOfFrom valueToFind 0 array;
    
/**
 * Finds the index of the first occurrence at index greater than or equal to {@code fromIndex@} of {@code valueToFind@} in {@code array@}
 * or -1 if the value does not occur from {@code fromIndex@} onwards.
 * 
 * There are no invalid values of {@code fromIndex@}. {@code fromIndex < 0@} is taken as starting the search from the start of {@code array@}
 * while {@code fromIndex >= length array@} always returns -1. 
 * 
 * @arg valueToFind
 * @arg fromIndex index to start searching from. 
 * @arg array
 * @return the index of the first occurrence at index greater than or equal to {@code fromIndex@} of {@code valueToFind@} in {@code array@}
 *         or -1 if the value does not occur from {@code fromIndex@} onwards.
 */    
indexOfFrom :: Eq a => a -> Int -> Array a -> Int;
public indexOfFrom !valueToFind !fromIndex !array =
    let  
        size :: Int;
        size = eager $ length array;                    
        
        indexOfHelper :: Int -> Int;
        indexOfHelper !index =
            if index >= size then
                -1                        
            else if valueToFind == (eager $ subscript array index) then
                index
            else
                indexOfHelper (index + 1);                             
    in
        indexOfHelper (max fromIndex 0);

/**
 * Finds the index of the last occurrence of {@code valueToFind@} in {@code array@} or -1 if the value does not occur.
 * 
 * @arg valueToFind
 * @arg array
 * @return the index of the last occurrence of {@code valueToFind@} in {@code array@} or -1 if the value does not occur.
 */
lastIndexOf :: Eq a => a -> Array a -> Int;
public lastIndexOf !valueToFind !array =
    lastIndexOfFrom valueToFind (length array - 1) array;

/* @example */
lastIndexOfExamples :: Boolean;
lastIndexOfExamples =
    assert (lastIndexOf 2.0 (fromList [2, 30, 4, 2, 10, 20]) == 3)
    && assert (lastIndexOf 100 (fromList ([] :: [Int])) == -1)
    && assert (lastIndexOf 100 (fromList [2 :: Int, 30, 4, 2, 10, 20]) == -1)
    && assert (lastIndexOf "apple" (fromList ["apple", "pear", "apple", "orange"]) == 2)
    && assert
       (
           lastIndexOf
               (Just "apple")
               (fromList [Just "apple", Nothing, Just "pear", Nothing, Just "apple", Just "orange", Nothing])
           == 4
       )
    ;

/**
 * Finds the index of the last occurrence at index less than or equal to {@code fromIndex@} of {@code valueToFind@}
 * in {@code array@} or -1 if the value does not occur from {@code fromIndex@} and earlier.
 * 
 * There are no invalid values of {@code fromIndex@}. {@code fromIndex < 0@} always returns -1, and
 * {@code fromIndex >= length array@} is taken as starting the search from the last index of {@code array@}.
 * 
 * @arg valueToFind
 * @arg fromIndex index to start searching from. 
 * @arg array
 * @return the index of the last occurrence at index less than or equal to {@code fromIndex@} of {@code valueToFind@}
 *         in {@code array@} or -1 if the value does not occur from {@code fromIndex@} and earlier.
 */ 
lastIndexOfFrom :: Eq a => a -> Int -> Array a -> Int;
public lastIndexOfFrom !valueToFind !fromIndex !array =    
    let  
        size :: Int;
        size = eager $ length array;                    
        
        lastIndexOfHelper :: Int -> Int;
        lastIndexOfHelper !index =
            if index < 0 then
                -1                        
            else if valueToFind == (eager $ subscript array index) then
                index
            else
                lastIndexOfHelper (index - 1);                             
    in
        lastIndexOfHelper (min fromIndex (size - 1));         

/**
 * Converts a failure code of -1 into a {@link Nothing@} value.
 */        
intToMaybe :: Int -> Maybe Int;    
private intToMaybe !intValue =
    if intValue == -1 then
        Nothing
    else
        Just intValue; 

/**
 * {@code find predicate array@} returns the first value of array for which the predicate function is {@link True@},
 * if there is one, or {@link Nothing@} otherwise.
 * 
 * e.g. {@code find {@link Prelude.isEven@} ({@link fromList@} [1, 1, 4, 1, 2, 1, 1, 6]) == {@link Just@} 4@}
 * 
 * @arg predicate a predicate to be applied to the elements of the array.
 * @arg array the array to be searched.
 * @return the first value of array for which the predicate function is {@link True@}, if there is one, or {@link Nothing@}
 *         otherwise.
 */
find :: (a -> Boolean) -> Array a -> Maybe a;
public find predicate !array =
    let
        //size is computed eagerly because
        //a) it is safe to compute it out of order to weak-head normal form     
        //b) we know that it will eventually be used in findHelper, so it is an efficiency gain to dispense with
        //   creating a thunk only to certainly evaluate that thunk later.
        //c) so that it can be lifted as a plinged argument of the local function findHelper      
        size :: Int;
        size = eager (length array);

        findHelper !index =
            if index >= size then
                Nothing                        
            else
                let
                    //use eager to avoid creating the graph for subscript array index which will be 
                    //later reduced to WHNF anyways by the call to 'predicate value'. The compiler can't do this
                    //automatically, since it can't guarantee that 'predicate value' will reduce 'value'. However,
                    //any useful predicate function will need to look at its argument! Note: the laziness of the
                    //function is not changed since the elements of array are known to be in WHNF by the contract
                    //of the Array type.
                    value = eager (subscript array index);
                in
                    if predicate value then
                        Just value
                    else
                        findHelper (index + 1);                                 
    in
        findHelper 0;      

/* @example */
findExamples :: Boolean;
private findExamples =
    assert (find Prelude.isEven (fromList [1 :: Int, 1, 4, 1, 2, 1, 1, 6]) == Just 4)
    && assert (find Prelude.isEven empty == Nothing)
    && assert (find Prelude.isEven (fromList [1 :: Int, 1, 3, 1, 5]) == Nothing)
    && assert (find Char.isUpperCase (fromString "this is a Phrase") == Just 'P')
    ;        

/**
 * Creates a default array of the given size. Generally, used in combination with the update function to then
 * initialize the array properly. This must be kept private, because it violates the public contract of the
 * {@link typeConstructor = Array@} type. 
 */ 
makeDefaultInternal :: ElementType -> Int -> Array a;
private makeDefaultInternal !elementType !size =
    
    if size == 0 then
        empty
    else
        case elementType of       
        CharType ->
            CharArray (array_makeDefault size);
        
        BooleanType ->
            BooleanArray (array_makeDefault size);
        
        ByteType ->
            ByteArray (array_makeDefault size); 
        
        ShortType ->
            ShortArray (array_makeDefault size);
        
        IntType ->
            IntArray (array_makeDefault size);
        
        LongType ->
            LongArray (array_makeDefault size); 
        
        FloatType ->
            FloatArray (array_makeDefault size); 
        
        DoubleType ->
            DoubleArray (array_makeDefault size);
        
        ObjectType ->
            ObjectArray (array_makeDefault size);
        
        CalValueType ->
            CalValueArray (array_makeDefault size);
    ;

/**
 * Destructive array update function. This must be kept private, because it violates the public contract of the
 * {@link typeConstructor = Array@} type. However, it is useful for implementing a variety of functions.
 */        
update :: Array a -> Int -> a -> a;      
update !array !index !value =
    
    case array of       
    CharArray {values} ->
        unsafeCoerce (charArray_update values index (unsafeCoerce value));
                               
    BooleanArray {values} ->
        unsafeCoerce (booleanArray_update values index (unsafeCoerce value));
        
    ByteArray {values} ->
        unsafeCoerce (byteArray_update values index (unsafeCoerce value)); 
        
    ShortArray {values} ->
        unsafeCoerce (shortArray_update values index (unsafeCoerce value));
                    
    IntArray {values} ->
        unsafeCoerce (intArray_update values index (unsafeCoerce value));
       
    LongArray {values} ->
        unsafeCoerce (longArray_update values index (unsafeCoerce value)); 
            
    FloatArray {values} ->
        unsafeCoerce (floatArray_update values index (unsafeCoerce value)); 
        
    DoubleArray {values} ->
        unsafeCoerce (doubleArray_update values index (unsafeCoerce value));
       
    ObjectArray {values} ->  
        unsafeCoerce (objectArray_update values index (unsafeCoerce value));
        
    CalValueArray {values} ->
        unsafeCoerce (calValueArray_update values index (unsafeCoerce value));
    
    EmptyArray ->
        emptyArray_update index value;
    ;       

/**
 * {@code map mapFunction array@} applies the function {@code mapFunction@} to each element of array and returns the
 * resulting array.
 * 
 * @arg mapFunction
 *        a function to be applied to each element of the array.
 * @arg array
 *        the array to which the mapFunction is applied element-wise.
 * @return the array obtained by applying {@code mapFunction@} to each element of the array.
 */
map :: (a -> b) -> Array a -> Array b;
public map mapFunction !array =
    let
        //size is computed eagerly because
        //a) it is safe to compute it out of order to weak-head normal form     
        //b) we know that it will eventually be used in mapHelper, so it is an efficiency gain to dispense with
        //   creating a thunk only to certainly evaluate that thunk later.
        //c) so that it can be lifted as a plinged argument of the local function mapHelper     
        size :: Int;
        size = eager (length array);
    in
        if size == 0 then
            empty
        else
            let
                firstResult = mapFunction (eager $ subscript array 0);
                
                resultArray :: Array b;
                resultArray = eager $ makeDefaultInternal (elementType_fromValue firstResult) size;
                
                mapHelper :: Int -> Array b;
                mapHelper !index =
                    if index < size then
                        //subscripting is done eagerly becasue
                        //a) it is safe to compute out of order, since we know that the index is valid, and that the elements of
                        //   the array are in weak-head normal form, and so subscripting is a fast operation (it doesn't need
                        //   to evaluate the array element to weak-head normal form).
                        //b) any reasonable mapFunction will eventually examine (subscript array index) and so 
                        //   it is an efficiency gain to dispense with creating a thunk only to most likely evaluate it later.                
                        update resultArray index (mapFunction (eager (subscript array index)))
                        `seq`
                        mapHelper (index + 1)
                    else
                        resultArray;      
            in
                update resultArray 0 firstResult
                `seq`
                mapHelper 1; 

/* @example */
mapExamples :: Boolean;
mapExamples =
    assert (map Char.toUpperCase(fromList ['a', 'b', 'c']) == fromList ['A', 'B', 'C'])  
    && assert (map Char.toUpperCase (fromList (empty :: [Char])) == empty)
    && assert (map (Prelude.multiply 10) (fromList [3 :: Long, 1]) == fromList [30, 10])
    && assert (map (\!x -> (x, x * 2)) (fromList [3.0, 1, 4, 1]) == fromList [(3, 6), (1, 2), (4, 8), (1, 2)])  
    && assert (map (\x -> (x, x * 2)) (fromList [3.0, 1, 4, 1]) == fromList [(3, 6), (1, 2), (4, 8), (1, 2)])  
    && assert (map String.length (fromList ["foo", "bar", "zaphod"]) == fromList [3, 3, 6])    
    && assert (map (Prelude.add 5) (fromList [1 :: Integer, 2, 3]) == fromList [6, 7, 8])    
    && assert (map Prelude.orderingToInt (fromList [LT, GT, LT, EQ]) == fromList [-1, 1, -1, 0])
    && assert (map Prelude.id (fromList [LT, GT, LT, EQ]) == fromList [LT, GT, LT, EQ])
    && assert (map Prelude.snd (fromList [(2.0, "abc"), (10.0, "pear")]) == fromList ["abc", "pear"]) 
    && assert (map Prelude.fst (fromList [(2.0, "abc"), (10.0, "pear")]) == fromList [2, 10])     
    && assert (map Prelude.fromJust (fromList [Just LT, Just GT, Just EQ]) == fromList [LT, GT, EQ])  
    ; 

/**
 * {@code mapIndexed mapFunction array@} applies the function {@code mapFunction@} to each element of the array, where
 * {@code mapFunction@} is passed both the element value, and its zero-based index in the array. 
 * 
 * @arg mapFunction 
 *         a function to be applied to each element of the array, being passed both the element value, and its
 *         zero-based index in the array.
 * @arg array the array.
 * @return the array obtained by applying {@code mapFunction@} to each element of the array.
 */
mapIndexed :: (a -> Int -> b) -> Array a -> Array b;
public mapIndexed mapFunction !array =
    let        
        size :: Int;
        size = eager (length array);
    in
        if size == 0 then
            empty
        else
            let
                firstResult = mapFunction (eager $ subscript array 0) 0;
                
                resultArray :: Array b;
                resultArray = eager $ makeDefaultInternal (elementType_fromValue firstResult) size;
                
                mapIndexedHelper :: Int -> Array b;
                mapIndexedHelper !index =
                    if index < size then
                        update resultArray index (mapFunction (eager (subscript array index)) index)
                        `seq`
                        mapIndexedHelper (index + 1)
                    else
                        resultArray;      
            in
                update resultArray 0 firstResult
                `seq`
                mapIndexedHelper 1;     

/* @example */
mapIndexedExamples :: Boolean;
mapIndexedExamples =
    assert 
    (
        mapIndexed 
            (\!value !index -> if index == 0 then Char.toUpperCase value else Char.toLowerCase value)
            (fromList ['a', 'b', 'C', 'd'])
        == fromList ['A', 'b', 'c', 'd']
    )
    && assert
    (
        mapIndexed
            (\!value !index -> if Prelude.isEven index then value + 5 else value - 5)
            (fromList [6 :: Int, 4, 3, 12])
        == fromList [11, -1, 8, 7]
    )
    && assert
    (
        mapIndexed
            (\!value !index -> if Prelude.isEven index then value + 5 else value - 5)
            (fromList ([] :: [Int]))
        == fromList []
    )
    ;

/**
 * {@code filter keepIfTrueFunction array@} applies the predicate function to each element of the array, and returns
 * the array of elements for which the predicate evaluates to {@link True@}.
 * 
 * @arg keepIfTrueFunction
 *        a predicate which returns True for items that should be kept, and False for items that should be dropped.
 * @arg array
 *        the array.
 * @return the array of those elements that satisfy the given predicate.
 */
/*
 * implementation note;
 * An alternative would be to allocate a new array (using makeDefaultFrom) and then copy elements that pass the
 * filter into the new array and then finally call subArray to trim to size. This can be worse memory-wise since
 * the second array is allocated even if it will all be trimmed in the end because the result is a zero-length array.
 */   
filter :: (a -> Boolean) -> Array a -> Array a;
public filter keepIfTrueFunction !array =
    if isEmpty array then
        empty
    else
        fromNonEmptyListInternal (elementType_fromNonEmptyArray array) (List.filter keepIfTrueFunction (toList array));
 
/* @example */
filterExamples :: Boolean;
filterExamples =
    assert (filter (\x -> String.length x > 2) (fromList ["abc", "d", "e", "zaphod", ""]) == fromList ["abc", "zaphod"])
    && assert (filter (\x -> String.length x > 2) (fromList ([] :: [String])) == empty)
    ;

/**
 * {@code filterIndexed keepIfTrueFunction array@} applies the predicate function {@code keepIfTrueFunction@} to each
 * element of the array, and returns the array of elements for which the predicate evaluates to {@link True@}.
 * {@code keepIfTrueFunction@} is a function that is passed both the element value, and its zero-based index in the array.
 * 
 * @arg keepIfTrueFunction
 *          a predicate which returns {@link True@} for items that should be kept, and {@link False@} for items that
 *          should be dropped. It is passed both the element value, and its zero-based index in the array.
 * @arg array the array.
 * @return the array of those elements that satisfy the given predicate.
 */    
filterIndexed :: (a -> Int -> Boolean) -> Array a -> Array a;
public filterIndexed keepIfTrueFunction !array =
    if isEmpty array then
        empty
    else
        fromNonEmptyListInternal (elementType_fromNonEmptyArray array) (List.filterIndexed keepIfTrueFunction (toList array));        
    
/* @example */
filterIndexedExamples :: Boolean;
filterIndexedExamples =
    assert
    (
        filterIndexed
            (\!value !index -> value > 5 && Prelude.isEven index)
            (fromList [1 :: Int, 2, 3, 4, 10, 20, 30, 40])
        == fromList [10, 30]
    )
    && assert 
    (
        filterIndexed
            (\!value !index -> value > 5 || Prelude.isEven index)
            (fromList [1 :: Int, 2, 3, 4, 10, 20, 30, 40])
        == fromList [1, 3, 10, 20, 30, 40]
    )
    && assert 
    (
        filterIndexed
            (\!value !index -> value > 5 || Prelude.isEven index)
            (fromList ([] :: [Int]))
        == fromList []
    )
    ;

/**
 * {@code foldLeft foldFunction initialValue list@} collapses or 'folds' the array down to a single result, starting
 * from the left of the array. It uses {@code initialValue@} as the initial value for the folding process, and
 * {@code foldFunction@} as the collapsing function.
 * 
 * If {@code foldFunction@} is strict in both of its arguments it is usually better to use {@link foldLeftStrict@}
 * instead of {@code foldLeft@} since using {@code foldLeft@} will cause significantly more memory to be used than using
 * {@link foldLeftStrict@}. If {@code foldFunction@} is not strict in both of its arguments, it usually results in better
 * lazy behavior to use {@link foldRight@} rather than {@code foldLeft@}.
 * 
 * @arg foldFunction the function to be used in folding the array.
 * @arg initialValue the initial value for the folding process.
 * @arg array the array to be folded over.
 * @return the single result obtained from folding {@code foldFunction@} over the array. 
 * @see foldLeftStrict, foldRight, foldLeft1, foldLeft1Strict, foldRight1
 */
foldLeft :: (a -> b -> a) -> a -> Array b -> a;
public foldLeft foldFunction initialValue !array =
    let
        size :: Int;
        size = eager (length array);

        foldHelper !index value =
            if index < size then
                foldHelper (index + 1) (foldFunction value (eager (subscript array index)))
            else
                value;
    in
        foldHelper 0 initialValue;  
    
/**
 * {@code foldLeft1@} is similar to {@link foldLeft@}, except that it uses the first element of the array as the initial value
 * in the folding process. Hence it gives an error if array is the empty array.
 * 
 * If {@code foldFunction@} is strict in both of its arguments it is usually better to use {@link foldLeft1Strict@}
 * instead of {@code foldLeft1@} since using {@code foldLeft1@} will cause significantly more memory to be used than using
 * {@link foldLeft1Strict@}. If {@code foldFunction@} is not strict in both of its arguments, it usually results in better
 * lazy behavior to use {@link foldRight1@} rather than {@code foldLeft1@}. 
 * 
 * @arg foldFunction the function to be used in folding the array.
 * @arg array the array to be folded over.
 * @return the single result obtained from folding {@code foldFunction@} over the array.
 * @see foldLeft, foldLeftStrict, foldRight, foldLeft1Strict, foldRight1
 */
foldLeft1 :: (a -> a -> a) -> Array a -> a;
public foldLeft1 foldFunction !array =
    //todoBI implement this...
    error "not implemented yet.";    
    
/**
 * This is the strict version of {@link foldLeft@}. It is used for efficiency reasons in certain situations.
 * For example, it can be used to define the sum and product functions so that they are constant
 * space functions, whereas the versions defined with {@link foldLeft@} would not be constant space.
 * 
 * If {@code foldFunction@} is strict in both of its arguments it is usually better to use {@code foldLeftStrict@}
 * instead of {@link foldLeft@} since using {@link foldLeft@} will cause significantly more memory to be used than using
 * {@code foldLeftStrict@}. If {@code foldFunction@} is not strict in both of its arguments, it usually results in better
 * lazy behavior to use {@link foldRight@} rather than {@link foldLeft@}. 
 * 
 * @arg foldFunction the function to be used in folding the array.
 * @arg initialValue the initial value for the folding process.
 * @arg array the array to be folded over.
 * @return the single result obtained from folding {@code foldFunction@} over the array.
 * @see foldLeft, foldRight, foldLeft1, foldLeft1Strict, foldRight1
 */
/*
 * @implementation notice that the difference between the implementation of foldLeftStrict and
 * foldLeft is just in the plinging.
 */     
foldLeftStrict ::  (a -> b -> a) -> a -> Array b -> a;
public foldLeftStrict foldFunction !initialValue !array =
    let
        size :: Int;
        size = eager (length array);

        foldHelper !index !value =
            if index < size then
                foldHelper (index + 1) (foldFunction value (eager (subscript array index)))
            else
                value;
    in
        foldHelper 0 initialValue;  
    
/**
 * WARNING- keep private, this is for explanation and benchmarking purposes only.
 * 
 * This is another implementation of {@link foldLeftStrict@} that pushes the recursion to the Java array level.
 * In this case, it doesn't benefit performance much. This is good news, since it means pushing to the level
 * of Java arrays is only useful if there is a specific reason for it e.g.
 * 
 * {@unorderedList
 * {@item an especially efficient implementation for a specific primitive array type@}
 * {@item delegation to a foreign function to do most of the work@}
 * {@item does not neet to intertwine with CAL functions at a fine-grained level (unlike with {@link foldLeftStrict@}, which
 * has its folding function).@}
 * @}
 * 
 * {@code {@link "Cal.Test.General.M2.sumArray"@} 100000@} went from 7.6s to 7.5s using this version of {@link foldLeftStrict@}. This is not
 * enough benefit to justify the extra coding here.
 */    
foldLeftStrictAlt ::  (a -> b -> a) -> a -> Array b -> a;    
private foldLeftStrictAlt foldFunction !initialValue !array =
    
    case array of
    CharArray {values} ->
        let
            foldCharHelper :: Int -> Int -> (a -> Char -> a) -> a -> JCharArray -> a;
            foldCharHelper !index !size !foldFunction !value !values =
                if index < (size :: Int) then
                    foldCharHelper (index + 1) size foldFunction (foldFunction value (eager (charArray_subscript values index))) values
                else
                    value;                                    
        in
            foldCharHelper 0 (array_length values) (unsafeCoerce foldFunction) initialValue values;
         
    BooleanArray {values} ->
        let
            foldBooleanHelper :: Int -> Int -> (a -> Boolean -> a) -> a -> JBooleanArray -> a;
            foldBooleanHelper !index !size !foldFunction !value !values =
                if index < (size :: Int) then
                    foldBooleanHelper (index + 1) size foldFunction (foldFunction value (eager (booleanArray_subscript values index))) values
                else
                    value;                                    
        in
            foldBooleanHelper 0 (array_length values) (unsafeCoerce foldFunction) initialValue values;
          
    ByteArray {values} ->
        let
            foldByteHelper :: Int -> Int -> (a -> Byte -> a) -> a -> JByteArray -> a;
            foldByteHelper !index !size !foldFunction !value !values =
                if index < (size :: Int) then
                    foldByteHelper (index + 1) size foldFunction (foldFunction value (eager (byteArray_subscript values index))) values
                else
                    value;                                    
        in
            foldByteHelper 0 (array_length values) (unsafeCoerce foldFunction) initialValue values;
         
    ShortArray {values} ->
        let
            foldShortHelper :: Int -> Int -> (a -> Short -> a) -> a -> JShortArray -> a;
            foldShortHelper !index !size !foldFunction !value !values =
                if index < (size :: Int) then
                    foldShortHelper (index + 1) size foldFunction (foldFunction value (eager (shortArray_subscript values index))) values
                else
                    value;                                    
        in
            foldShortHelper 0 (array_length values) (unsafeCoerce foldFunction) initialValue values;
          
    IntArray {values} ->
        let
            foldIntHelper :: Int -> Int -> (a -> Int -> a) -> a -> JIntArray -> a;
            foldIntHelper !index !size !foldFunction !value !values =
                if index < (size :: Int) then
                    foldIntHelper (index + 1) size foldFunction (foldFunction value (eager (intArray_subscript values index))) values
                else
                    value;                                    
        in
            foldIntHelper 0 (array_length values) (unsafeCoerce foldFunction) initialValue values;
           
    LongArray {values} ->
        let
            foldLongHelper :: Int -> Int -> (a -> Long -> a) -> a -> JLongArray -> a;
            foldLongHelper !index !size !foldFunction !value !values =
                if index < (size :: Int) then
                    foldLongHelper (index + 1) size foldFunction (foldFunction value (eager (longArray_subscript values index))) values
                else
                    value;                                    
        in
            foldLongHelper 0 (array_length values) (unsafeCoerce foldFunction) initialValue values;
           
    FloatArray {values} ->
        let
            foldFloatHelper :: Int -> Int -> (a -> Float -> a) -> a -> JFloatArray -> a;
            foldFloatHelper !index !size !foldFunction !value !values =
                if index < (size :: Int) then
                    foldFloatHelper (index + 1) size foldFunction (foldFunction value (eager (floatArray_subscript values index))) values
                else
                    value;                                    
        in
            foldFloatHelper 0 (array_length values) (unsafeCoerce foldFunction) initialValue values;
           
    DoubleArray {values} ->
        let
            foldDoubleHelper :: Int -> Int -> (a -> Double -> a) -> a -> JDoubleArray -> a;
            foldDoubleHelper !index !size !foldFunction !value !values =
                if index < (size :: Int) then
                    foldDoubleHelper (index + 1) size foldFunction (foldFunction value (eager (doubleArray_subscript values index))) values
                else
                    value;                                    
        in
            foldDoubleHelper 0 (array_length values) (unsafeCoerce foldFunction) initialValue values;
          
    ObjectArray {values} ->
        let
            foldObjectHelper :: Int -> Int -> (a -> JObject -> a) -> a -> JObjectArray -> a;
            foldObjectHelper !index !size !foldFunction !value !values =
                if index < (size :: Int) then
                    foldObjectHelper (index + 1) size foldFunction (foldFunction value (eager (objectArray_subscript values index))) values
                else
                    value;                                    
        in
            foldObjectHelper 0 (array_length values) (unsafeCoerce foldFunction) initialValue values;
           
    CalValueArray {values} ->
        let
            foldCalValueHelper :: Int -> Int -> (a -> CalValue -> a) -> a -> JCalValueArray -> a;
            foldCalValueHelper !index !size !foldFunction !value !values =
                if index < (size :: Int) then
                    foldCalValueHelper (index + 1) size foldFunction (foldFunction value (eager (calValueArray_subscript values index))) values
                else
                    value;                                    
        in
            foldCalValueHelper 0 (array_length values) (unsafeCoerce foldFunction) initialValue values;
    
    EmptyArray -> initialValue;
    ;
    
/**
 * {@code foldLeft1Strict@} is similar to {@link foldLeftStrict@}, except that it uses the first element of the array as
 * the initial value in the folding process. Hence it gives an error if array is the empty array.
 * 
 * @arg foldFunction the function to be used in folding the array.
 * @arg array the array to be folded over.
 * @return the single result obtained from folding {@code foldFunction@} over the array.
 * @see foldLeft, foldLeftStrict, foldRight, foldLeft1, foldRight1
 */
foldLeft1Strict :: (a -> a -> a) -> Array a -> a;
public foldLeft1Strict foldFunction !array =    
    let
        size :: Int;
        size = eager (length array);

        foldHelper !index !value =
            if index < size then
                foldHelper (index + 1) (foldFunction value (eager (subscript array index)))
            else
                value;
    in
        if size >= 0 then
            foldHelper 1 (subscript array 0)
        else
            error "Empty array.";

/**
 * Helper function used in the implementation of {@code foldRight@} and {@code foldRight1@}  
 * @see Array.Array, foldRight, foldRight1
 */
foldRightHelper :: Array a -> (a -> b -> b) -> Int -> b -> b;
private foldRightHelper !array foldFunction !index value =
    if index < (0 :: Int) then
        value
    else
        foldRightHelper array foldFunction (index - 1) (foldFunction (eager (subscript array index)) value);

/**
 * Similar to {@link foldLeft@}, except that the folding process on the array is started with its rightmost element.
 * Often the result of applying {@link foldLeft@} or {@code foldRight@} is the same, and the choice between them is a matter of
 * efficiency. Which is better depends on the nature of the folding function. As a general rule, if the folding
 * function is strict in both arguments, {@link foldLeftStrict@} is a good choice. Otherwise {@code foldRight@} is often best.
 * 
 * @arg foldFunction the function to be used in folding the array.
 * @arg initialValue the initial value for the folding process.
 * @arg array the array to be folded over.
 * @return the single result obtained from folding {@code foldFunction@} over the array.
 * @see foldLeft, foldLeftStrict, foldLeft1, foldLeft1Strict, foldRight1
 */
foldRight :: (a -> b -> b) -> b -> Array a -> b;
public foldRight foldFunction initialValue !array = 
    let 
        lastIndex :: Int;
        lastIndex = eager ((length array) -1);
    in
        foldRightHelper array foldFunction lastIndex initialValue;  
    
/* @example */
foldRightExamples :: Boolean;
foldRightExamples = 
    assert (
        (foldRight (\x y ->x++y) "a" (array3 "b" "c" "d")) == (List.foldRight (\x y ->x++y) "a" (List.list3 "b" "c" "d")) && 
        (foldRight (\x y ->x*y) 1.0 (array2 2.0 3.0)) == (List.foldRight (\x y ->x*y) 1.0 (List.list2 2.0 3.0)) &&
        (foldRight (\x y ->x) 1.0 (array1 2.0)) == (List.foldRight (\x y ->x) 1.0 (List.list1 2.0)) &&
        (foldRight (\x y ->y) 1.0 (array1 2.0)) == (List.foldRight (\x y ->y) 1.0 (List.list1 2.0)) &&
        (foldRight (\x y ->x) "toast" (array0)) == (List.foldRight (\x y ->x) "toast" (List.list0))
        );

/**
 * Similar to {@link foldLeft1@}, except that the folding process on the array is started with its rightmost element.
 * Often the result of applying {@link foldLeft1@} or {@code foldRight1@} is the same, and the choice between them is a matter of
 * efficiency. Which is better depends on the nature of the folding function. As a general rule, if the folding
 * function is strict in both arguments, {@link foldLeft1Strict@} is a good choice. Otherwise {@code foldRight1@} is often best.
 * 
 * @arg foldFunction the function to be used in folding the array.
 * @arg array the array to be folded over.
 * @return the single result obtained from folding {@code foldFunction@} over the array.
 * @see foldLeft, foldLeftStrict, foldRight, foldLeft1, foldLeft1Strict
 */
foldRight1 :: (a -> a -> a) -> Array a -> a;
public foldRight1 foldFunction !array =
    let 
        lastIndex :: Int;
        lastIndex = eager ((length array) -1);
    in
        foldRightHelper array foldFunction (lastIndex - 1) (eager (subscript array lastIndex));  
    
/* @example */
foldRight1Examples :: Boolean;
foldRight1Examples = 
    assert (
        (foldRight1 (\x y ->x++y) (array4 "a" "b" "c" "d")) == (List.foldRight1 (\x y ->x++y) (List.list4 "a" "b" "c" "d")) && 
        (foldRight1 (\x y ->x*y) (array3 1.0 2.0 3.0)) == (List.foldRight1 (\x y ->x*y) (List.list3 1.0 2.0 3.0)) &&
        (foldRight1 (\x y ->x) (array2 1.0 2.0)) == (List.foldRight1 (\x y ->x) (List.list2 1.0 2.0)) &&
        (foldRight1 (\x y ->y) (array2 1.0 2.0)) == (List.foldRight1 (\x y ->y) (List.list2 1.0 2.0)) &&
        (foldRight1 (\x y ->x) (array1 "toast")) == (List.foldRight1 (\x y ->x) (List.list1 "toast"))
        );

/**
 * {@code sum array@} returns the sum of all the elements of {@code array@}, adding from left to right. {@code sum@} applied
 * to an empty array is 0.
 * 
 * @arg array the array whose elements are to be summed.
 * @return the sum of all the elements of the array, adding from left to right, or 0 if the array is empty.
 */
//todoBI can be more efficient for the primitive types by delegating to foreign functions based on arrayType    
sum :: (Num a) => Array a -> a;
public sum = foldLeftStrict add 0;

/* @example */
sumExamples :: Boolean;
sumExamples =
    assert (sum (fromList (upFromTo (1 :: Int) 100)) == 5050)
    && assert (sum (fromList(upFromTo (1 :: Integer) 1000)) == 500500)
    && assert (sum (empty :: Array Int) == 0)
    ;

/**
 * {@code product array@} return the product of all the elements of {@code array@}, multiplying from left to right.
 * {@code product@} applied to an empty array is 1.
 * 
 * @arg array the array whose elements are to be multiplied.
 * @return the product of all the elements of array, multiplying from left to right, or 1 if the array is empty.
 */
//todoBI can be more efficient for the primitive types by delegating to foreign functions based on arrayType
product :: Num a => Array a -> a;
public product = foldLeftStrict multiply 1; 

/**
 * Returns the maximum value in the specified array.
 * Terminates in an error on an empty array.
 * 
 * @arg array the array whose maximum value is to be returned.
 * @return the maximum value in the array.
 */
maximum :: Ord a => Array a -> a;
public maximum = foldLeft1Strict max;

/* @example */
maximumExamples :: Boolean;
private maximumExamples =
    assert (maximum (fromList ['z', 'e', 'r', 'o']) == 'z')
    && assert (maximum (fromList [10, 20, 50.8, 23]) == 50.8)
    && assert (maximum (array1 "abc") == "abc")
    ;

/**
 * Returns the minimum value in the specified array.
 * Terminates in an error on an empty array.
 * 
 * @arg array the array whose minimum value is to be returned.
 * @return the minimum value in the array.
 */
minimum :: Ord a => Array a -> a;
public minimum = foldLeft1Strict min;

/* @example */
minimumExamples :: Boolean;
private minimumExamples =
    assert (minimum (fromList ['z', 'e', 'r', 'o']) == 'e')
    && assert (minimum (fromList [10, 20, 50.8, 23]) == 10)
    && assert (minimum (array1 "abc") == "abc")
    ;

/**
 * This function takes a comparison function and a array and returns the greatest
 * element of the array by the comparison function. The array must be non-empty.
 * 
 * @arg comparisonFunction the comparison function.
 * @arg array a non-empty array.
 * @return the greatest element of the array by the comparison function.
 */
maximumBy :: (a -> a -> Ordering) -> Array a -> a;
public maximumBy comparisonFunction !array =
    if isEmpty array then
        error "Empty array."
    else
        let
            max x y =
                case (comparisonFunction x y) of
                GT -> x;
                _  -> y;
                ;
        in            
            foldLeft1Strict max array;

/* @example */
maximumByExamples :: Boolean;
private maximumByExamples =
    assert (maximumBy compare (fromList ['z', 'e', 'r', 'o']) == 'z')
    && assert (maximumBy compare (fromList [10, 20, 50.8, 23]) == 50.8)
    && assert (maximumBy compare (array1 "abc") == "abc")
    && assert (maximumBy (flip compare) (fromList ['z', 'e', 'r', 'o']) == 'e')
    && assert (maximumBy (flip compare) (fromList [10, 20, 50.8, 23]) == 10)
    && assert (maximumBy (flip compare) (array1 "abc") == "abc")
    ;

/**
 * This function takes a comparison function and a array and returns the least
 * element of the array by the comparison function. The array must be non-empty.
 * 
 * @arg comparisonFunction the comparison function.
 * @arg array a non-empty array.
 * @return the least element of the array by the comparison function.
 */
minimumBy :: (a -> a -> Ordering) -> Array a -> a;
public minimumBy comparisonFunction !array =
    if isEmpty array then
        error "Empty array."
    else
        let
            min x y =
                case (comparisonFunction x y) of
                GT -> y;
                _  -> x;
                ;
        in            
            foldLeft1Strict min array;

/* @example */
minimumByExamples :: Boolean;
private minimumByExamples =
    assert (minimumBy compare (fromList ['z', 'e', 'r', 'o']) == 'e')
    && assert (minimumBy compare (fromList [10, 20, 50.8, 23]) == 10)
    && assert (minimumBy compare (array1 "abc") == "abc")
    && assert (minimumBy (flip compare) (fromList ['z', 'e', 'r', 'o']) == 'z')
    && assert (minimumBy (flip compare) (fromList [10, 20, 50.8, 23]) == 50.8)
    && assert (minimumBy (flip compare) (array1 "abc") == "abc")
    ;

/**
 * {@code andArray array@} returns {@link True@} if every element of the array is {@link True@}.
 * 
 * @arg array the array whose elements are to be tested.
 * @return {@link True@} if every element of the array is {@link True@}.
 */  
andArray :: Array Boolean -> Boolean;
public andArray !array =
    case array of
    EmptyArray -> True;
    BooleanArray {values} ->
        booleanArray_indexOf values False == -1;    
    ;

/* @example */
andArrayExamples :: Boolean; 
private andArrayExamples =
    assert (andArray empty)
    && assert (andArray (fromList [True]))
    && assert (not (andArray (fromList [False])))
    && assert (andArray (fromList [True, True, True]))   
    && assert (andArray (replicate 100000 True))
    ;
          
/**
 * {@code orArray array@} returns {@link True@} if at least one element of the array is {@link True@}.
 * 
 * @arg array the array whose elements are to be tested.
 * @return {@link True@} if at least one element of the array is {@link True@}.
 */
orArray :: Array Boolean -> Boolean;
public orArray !array =
    case array of
    EmptyArray -> False;
    BooleanArray {values} -> 
        booleanArray_indexOf values True != -1;        
    ;

/* @example */
orArrayExamples :: Boolean;  
private orArrayExamples =
    assert (not (orArray (fromList [])))
    && assert (orArray (fromList [True]))
    && assert (orArray (fromList [False, False, False, True]))
    && assert (not (orArray (fromList [False])))
    && assert (orArray (fromList [True, True, True]))    
    && assert (not (orArray (replicate 100000 False)))
    ;

/**
 * {@code any predicate array@} returns {@link True@} if the predicate function evaluates to {@link True@} on at least
 * one element of the array.
 * 
 * @arg predicate a predicate to be applied to the elements of the array.
 * @arg array the array whose elements are to be tested.
 * @return {@link True@} if the predicate function evaluates to {@link True@} on at least one element of the array.
 */
any :: (a -> Boolean) -> Array a -> Boolean;
public any predicate !array =
    let
        size :: Int;
        size = eager (length array);

        anyHelper :: Int -> Boolean;
        anyHelper !index =
            if index < (size :: Int) then
                predicate (eager (subscript array index)) || anyHelper (index + 1)
            else
                False;
    in
        anyHelper 0;

/* @example */
anyExamples :: Boolean;
private anyExamples = 
    assert (any (equals 1.0) (fromList [2.0, 3.0, 1.0]))
    && assert (any (equals "apple") (fromList ["pear", "cherry", "peach", "apple", "strawberry"]))
    && assert (not (any (equals 1.0) (fromList [2.0, 3.0, 5.0])))
    && assert (not (any (equals 1.0) empty))
    && assert (not (any (Prelude.greaterThan (0 :: Int)) (fromList (Prelude.upFromTo 1 100)))) //the predicate is True for negative numbers
    && assert (any (Prelude.greaterThan (0 :: Int)) (fromList ((upFromTo 1 100) ++ [-1])))
    && assert (any (equals (200000 :: Long)) (fromList (upFromTo 1 200000))) 
    ;
        
/**
 * {@code all predicate array@} returns {@link True@} if the predicate function evaluates to {@link True@} on all the
 * elements of the array (and the array is finite).
 * 
 * @arg predicate a predicate to be applied to the elements of the array.
 * @arg array the array whose elements are to be tested.
 * @return {@link True@} if the predicate function evaluates to {@link True@} on all the elements of the array (and the
 *         array is finite).
 */
all :: (a -> Boolean) -> Array a -> Boolean;
public all predicate !array =
    let
        size :: Int;
        size = eager (length array);

        allHelper :: Int -> Boolean;
        allHelper !index =
            if index < size then              
                predicate (eager (subscript array index)) && allHelper (index + 1)
            else
                True;
    in
        allHelper 0;       

/* @example */
allExamples :: Boolean;
private allExamples =
    assert (all (equals 7.0) (fromList [7.0, 7.0, 7.0]))
    && assert (all (equals 2.0) empty)
    && assert (all (equals "apple") (fromList ["apple", "apple"]))
    && assert (all (equals 1.0) (replicate 100000 1.0))
    && assert (not (all (equals "fred") (fromList ["fred", "fred", "bob"])))
    ;

/**
 * {@code isElem elementValue array@} returns {@link True@} if {@code elementValue@} is an element of the array.
 * 
 * @arg elementValue the value to be tested for membership in the array.
 * @arg array the array to be checked.
 * @return {@link True@} if {@code elementValue@} is an element of the array.
 * @see isElemBy 
 */
isElem :: Eq a => a -> Array a -> Boolean;
public isElem = compose any equals;

/**
 * {@code isNotElem elementValue array@} returns {@link True@} if {@code elementValue@} is not an element of the array.
 * 
 * @arg elementValue the value to be tested for membership in the array.
 * @arg array the array to be checked.
 * @return {@link True@} if {@code elementValue@} is not an element of the array.
 * @see isElem
 */
isNotElem :: Eq a => a -> Array a -> Boolean;
public isNotElem = compose all notEquals;

/**
 * Converts two arrays into an array of corresponding pairs.
 * If one input array is short, excess elements of the longer array are discarded.
 * 
 * e.g. {@code zip ({@link fromList@} [6, 3]) ({@link fromList@} ["orange", "apple", "pear"]) == ({@link fromList@} [(6, "orange"), (3, "apple")])@} 
 * 
 * @arg array1 the first array to be zipped.
 * @arg array2 the second array to be zipped.
 * @return an array of corresponding pairs.
 * @see zipWith
 */
zip :: Array a -> Array b -> Array (a, b);
public zip !array1 !array2 =
    let     
        size :: Int;
        size = eager (min (length array1) (length array2));
        
        zipHelper !index !resultArray =
            if index < size then
                //we use eager below because the elements of array1 and array2 are already in weak-head normal form.
                //performing the subscript function is quicker than allocating the suspended application of suscript
                //as well as more space efficient. Note it is always safe to subscript without an exception because
                //we know index >= 0 and index < size.
                update resultArray index (eager (subscript array1 index), eager (subscript array2 index))
                `seq`
                zipHelper (index + 1) resultArray
            else
                resultArray;           
    in
        zipHelper 0 (makeDefaultInternal CalValueType size);

/* @example */
zipExamples :: Boolean;
zipExamples =
    assert (zip (fromList ["apple", "orange", "peach"]) (fromList [2.0, 3, 5, 7]) == fromList [("apple", 2.0), ("orange", 3), ("peach", 5)])
    && assert (zip (empty :: Array (Maybe Char)) (fromList [2.0, 3, 5, 7]) == empty)
    ;

/**
 * Converts three arrays into an array of corresponding triples.
 * If one input array is short, excess elements of the longer arrays are discarded.
 * 
 * e.g. {@code zip3 ({@link fromList@} [6, 3]) ({@link fromList@} ["orange", "apple", "pear"]) ({@link fromList@} ['a', 'b']) == ({@link fromList@} [(6, "orange", 'a'), (3, "apple", 'b')])@} 
 * 
 * @arg array1 the first array to be zipped.
 * @arg array2 the second array to be zipped.
 * @arg array3 the third array to be zipped.
 * @return an array of corresponding triples.
 * @see zip
 */
zip3 :: Array a -> Array b -> Array c -> Array (a, b, c);
public zip3 !array1 !array2 !array3 =
    let     
        size :: Int;
        size = eager (min (min (length array1) (length array2)) (length array3));
        
        zipHelper !index !resultArray =
            if index < size then
                //we use eager below because the elements of array1 and array2 are already in weak-head normal form.
                //performing the subscript function is quicker than allocating the suspended application of suscript
                //as well as more space efficient. Note it is always safe to subscript without an exception because
                //we know index >= 0 and index < size.
                update resultArray index (eager (subscript array1 index), eager (subscript array2 index), eager (subscript array3 index))
                `seq`
                zipHelper (index + 1) resultArray
            else
                resultArray;           
    in
        zipHelper 0 (makeDefaultInternal CalValueType size);

/* @example */
zip3Examples :: Boolean;
zip3Examples =
    assert (zip3 (fromList [6, 3 :: Int]) (fromList ["orange", "apple", "pear"]) (fromList ['a', 'b']) == fromList [(6, "orange", 'a'), (3, "apple", 'b')]);

/**
 * Converts four arrays into an array of corresponding 4-tuples.
 * If one input array is short, excess elements of the longer arrays are discarded.
 * 
 * @arg array1 the first array to be zipped.
 * @arg array2 the second array to be zipped.
 * @arg array3 the third array to be zipped.
 * @arg array4 the fourth array to be zipped.
 * @return an array of corresponding 4-tuples.
 * @see zip
 */
zip4 :: Array a -> Array b -> Array c -> Array d -> Array (a, b, c, d);
public zip4 !array1 !array2 !array3 !array4 =
    let     
        size :: Int;
        size = eager (min (min (length array1) (length array2)) (min (length array3) (length array4)));
        
        zipHelper !index !resultArray =
            if index < size then
                //we use eager below because the elements of array1 and array2 are already in weak-head normal form.
                //performing the subscript function is quicker than allocating the suspended application of suscript
                //as well as more space efficient. Note it is always safe to subscript without an exception because
                //we know index >= 0 and index < size.
                update resultArray index (eager (subscript array1 index), eager (subscript array2 index), eager (subscript array3 index), eager (subscript array4 index))
                `seq`
                zipHelper (index + 1) resultArray
            else
                resultArray;           
    in
        zipHelper 0 (makeDefaultInternal CalValueType size);

/* @example */
zip4Examples :: Boolean;
zip4Examples =
    assert (zip4 (fromList [6, 3 :: Int]) (fromList ["orange", "apple", "pear"]) (fromList ['a', 'b']) (fromList [True, True, False, False]) == fromList [(6, "orange", 'a', True), (3, "apple", 'b', True)]);

/**
 * Returns an array where each element is the result of applying a function to the
 * corresponding elements of two arrays.
 * 
 * {@code zipWith@} generalises {@link zip@} by zipping with the function given as the first
 * argument, instead of a tupling function. For example, {@code zipWith {@link add@}@} applied
 * to two arrays produces the array of corresponding sums.
 * 
 * @arg zipFunction the zipping function.
 * @arg array1 the first array to be zipped.
 * @arg array2 the second array to be zipped.
 * @return an array of the element-wise combination of the input arrays.
 * @see zip
 */
zipWith :: (a -> b -> c) -> Array a -> Array b -> Array c;
public zipWith zipFunction !array1 !array2 =
    let     
        size :: Int;
        size = eager (min (length array1) (length array2));
    in
        if size == 0 then
            empty
        else
            let
                firstResult = zipFunction (eager $ subscript array1 0) (eager $ subscript array2 0);
                
                resultArray :: Array a;
                resultArray = eager $ makeDefaultInternal (elementType_fromValue firstResult) size;
                
                zipHelper :: Int -> Array a;
                zipHelper !index =
                    if index < size then
                        update resultArray index (zipFunction (eager (subscript array1 index)) (eager (subscript array2 index)))                
                        `seq`
                        zipHelper (index + 1)
                    else
                        resultArray;       
            in
                update resultArray 0 firstResult
                `seq`
                zipHelper 1;

/* @example */
zipWithExamples :: Boolean;
zipWithExamples =
    assert (zipWith max (fromList [10, 5, 8, 3, 4 :: Int, 9]) (fromList [5, 8, 3, 4 :: Int, 9]) == fromList [10, 8, 8, 4, 9])
    && assert (zipWith Prelude.subtract (fromList [10, 5, 8, 3, 4 :: Integer, 9]) (fromList [5, 8, 3, 4, 9]) == fromList [5, -3, 5, -1, -5])
    && assert (zipWith Prelude.add (empty :: Array Int) (fromList [2, 3, 5, 7]) == empty)
    ;

/**
 * Returns an array where each element is the result of applying a function to the
 * corresponding elements of three arrays.
 * 
 * @arg zipFunction the zipping function.
 * @arg array1 the first array to be zipped.
 * @arg array2 the second array to be zipped.
 * @arg array3 the third array to be zipped.
 * @return an array of the element-wise combination of the input arrays.
 * @see zip
 */
zipWith3 :: (a -> b -> c -> d) -> Array a -> Array b -> Array c -> Array d;
public zipWith3 zipFunction !array1 !array2 !array3 =
    let     
        size :: Int;
        size = eager (min (length array1) (min (length array2) (length array3)));
    in
        if size == 0 then
            empty
        else
            let
                firstResult = zipFunction (eager $ subscript array1 0) (eager $ subscript array2 0) (eager $ subscript array3 0);
                
                resultArray :: Array a;
                resultArray = eager $ makeDefaultInternal (elementType_fromValue firstResult) size;
                
                zipHelper :: Int -> Array a;
                zipHelper !index =
                    if index < size then
                        update resultArray index (zipFunction (eager (subscript array1 index)) (eager (subscript array2 index)) (eager (subscript array3 index)))                
                        `seq`
                        zipHelper (index + 1)
                    else
                        resultArray;       
            in
                update resultArray 0 firstResult
                `seq`
                zipHelper 1;          

/* @example */
zipWith3Examples :: Boolean;
zipWith3Examples =
    let
        add3 :: Num a => a -> a -> a -> a;
        add3 x y z = x + y + z;
        
        max3 :: Ord a => a -> a -> a -> a;
        max3 x y z = max x (max y z);
    in
        assert (zipWith3 max3 (fromList [10, 5, 8, 3, 4 :: Int, 9]) (fromList [-1, 80, -2, 50 :: Int]) (fromList [5, 8, 3, 4 :: Int, 9]) == fromList [10, 80, 8, 50])
        && assert (zipWith3 add3 (fromList [10, 5, 8, 3, 4 :: Integer, 9]) (fromList [-1, 80, -2, 50 :: Integer]) (fromList [5, 8, 3, 4, 9]) == fromList [14, 93, 9, 57])
        ;

/**
 * Returns an array where each element is the result of applying a function to the
 * corresponding elements of four arrays.
 * 
 * @arg zipFunction the zipping function.
 * @arg array1 the first array to be zipped.
 * @arg array2 the second array to be zipped.
 * @arg array3 the third array to be zipped.
 * @arg array4 the fourth array to be zipped.
 * @return an array of the element-wise combination of the input arrays.
 * @see zip
 */
zipWith4 :: (a -> b -> c -> d -> e) -> Array a -> Array b -> Array c -> Array d -> Array e;
public zipWith4 zipFunction !array1 !array2 !array3 !array4 =
    let     
        size :: Int;
        size = eager (min (min (length array1) (length array2)) (min (length array3) (length array4)));
    in
        if size == 0 then
            empty
        else
            let
                firstResult = zipFunction (eager $ subscript array1 0) (eager $ subscript array2 0) (eager $ subscript array3 0) (eager $ subscript array4 0);
                
                resultArray :: Array a;
                resultArray = eager $ makeDefaultInternal (elementType_fromValue firstResult) size;
                
                zipHelper :: Int -> Array a;
                zipHelper !index =
                    if index < size then
                        update resultArray index (zipFunction (eager (subscript array1 index)) (eager (subscript array2 index)) (eager (subscript array3 index)) (eager (subscript array4 index)))                
                        `seq`
                        zipHelper (index + 1)
                    else
                        resultArray;       
            in
                update resultArray 0 firstResult
                `seq`
                zipHelper 1;

/* @example */
zipWith4Examples :: Boolean;
zipWith4Examples =
    let
        add4 :: Num a => a -> a -> a -> a -> a;
        add4 w x y z = w + x + y + z;
        
        max4 :: Ord a => a -> a -> a -> a -> a;
        max4 w x y z = max (max w x) (max y z);
    in
        assert (zipWith4 max4 (fromList [10, 5, 8, 3, 4 :: Int, 9]) (fromList [-1, 80, -2, 50 :: Int]) (fromList [15, 4, 1400, 3 :: Int])  (fromList [5, 8, 3, 4 :: Int, 9]) == fromList [15, 80, 1400, 50])
        && assert (zipWith4 add4 (fromList [10, 5, 8, 3, 4 :: Integer, 9]) (fromList [1, 2, 3, 4, 5 :: Integer, 6]) (fromList [-1, 80, -2, 50 :: Integer]) (fromList [5, 8, 3, 4, 9]) == fromList [15, 95, 12, 61])
        ;

/**
 * Transforms an array of pairs into a pair of arrays.
 * 
 * @arg array the array to be unzipped.
 * @return a pair of arrays.
 * @see zip
 */
unzip :: Array (a, b) -> (Array a, Array b);
public unzip !array =
    let
        size :: Int;
        size = eager (length array);
    in
        if size == 0 then
            (empty, empty)
        else
            let
                (firstLeft, firstRight) = eager (subscript array 0);
                
                leftArray :: Array a;
                leftArray = eager $ makeDefaultInternal (elementType_fromValue firstLeft) size;
                
                rightArray :: Array a;
                rightArray = eager $ makeDefaultInternal (elementType_fromValue firstRight) size;
                
                unzipHelper :: Int -> (Array a, Array b);
                unzipHelper !index =
                    if index < size then
                        let
                            pairElement = eager (subscript array index);
                        in
                            update leftArray index pairElement.#1
                            `seq`
                            update rightArray index pairElement.#2
                            `seq`
                            unzipHelper (index + 1)
                    else
                        (leftArray, rightArray);
            in
                update leftArray 0 firstLeft
                `seq`
                update rightArray 0 firstRight
                `seq`
                unzipHelper 1;

/* @example */
unzipExamples :: Boolean;
unzipExamples =
    assert (unzip (fromList [("fred", Just 2.0), ("bob", Just 100), ("arthur", Just 70)]) == (fromList ["fred", "bob", "arthur"], fromList [Just 2.0, Just 100, Just 70]))
    && assert (unzip (empty :: Array (Int, Char)) == (empty, empty)) 
    ;

/**
 * Transforms an array of triples into a triple of arrays.
 * 
 * @arg array the array to be unzipped.
 * @return a triple of arrays.
 * @see zip
 */
unzip3 :: Array (a, b, c) -> (Array a, Array b, Array c);
public unzip3 !array =
    let
        size :: Int;
        size = eager (length array);
    in
        if size == 0 then
            (empty, empty, empty)
        else
            let
                (firstLeft, firstMiddle, firstRight) = eager (subscript array 0);
                
                leftArray :: Array a;
                leftArray = eager $ makeDefaultInternal (elementType_fromValue firstLeft) size;
                
                middleArray :: Array a;
                middleArray = eager $ makeDefaultInternal (elementType_fromValue firstMiddle) size;
                
                rightArray :: Array a;
                rightArray = eager $ makeDefaultInternal (elementType_fromValue firstRight) size;
                
                unzipHelper :: Int -> (Array a, Array b, Array c);
                unzipHelper !index =
                    if index < size then
                        let
                            tripleElement = eager (subscript array index);
                        in
                            update leftArray index tripleElement.#1
                            `seq`
                            update middleArray index tripleElement.#2
                            `seq`
                            update rightArray index tripleElement.#3
                            `seq`
                            unzipHelper (index + 1)
                    else
                        (leftArray, middleArray, rightArray);
            in
                update leftArray 0 firstLeft
                `seq`
                update middleArray 0 firstMiddle
                `seq`
                update rightArray 0 firstRight
                `seq`
                unzipHelper 1;

/* @example */
unzip3Examples :: Boolean;
unzip3Examples =
    assert (unzip3 (fromList [("fred", Just 2.0, True), ("bob", Just 100, False), ("arthur", Just 70, True)]) == (fromList ["fred", "bob", "arthur"], fromList [Just 2.0, Just 100, Just 70], fromList [True, False, True]))
    && assert (unzip3 (empty :: Array (Int, Char, (Boolean, Boolean))) == (empty, empty, empty)) 
    ;

/**
 * Transforms an array of 4-tuples into a 4-tuple of arrays.
 * 
 * @arg array the array to be unzipped.
 * @return a 4-tuple of arrays.
 * @see zip
 */
unzip4 :: Array (a, b, c, d) -> (Array a, Array b, Array c, Array d);
public unzip4 !array =
    let
        size :: Int;
        size = eager (length array);
    in
        if size == 0 then
            (empty, empty, empty, empty)
        else
            let
                (first1, first2, first3, first4) = eager (subscript array 0);
                
                array1 :: Array a;
                array1 = eager $ makeDefaultInternal (elementType_fromValue first1) size;
                
                array2 :: Array a;
                array2 = eager $ makeDefaultInternal (elementType_fromValue first2) size;
                
                array3 :: Array a;
                array3 = eager $ makeDefaultInternal (elementType_fromValue first3) size;
                
                array4 :: Array a;
                array4 = eager $ makeDefaultInternal (elementType_fromValue first4) size;
                
                unzipHelper :: Int -> (Array a, Array b, Array c, Array d);
                unzipHelper !index =
                    if index < size then
                        let
                            tupleElement = eager (subscript array index);
                        in
                            update array1 index tupleElement.#1
                            `seq`
                            update array2 index tupleElement.#2
                            `seq`
                            update array3 index tupleElement.#3
                            `seq`
                            update array4 index tupleElement.#4
                            `seq`
                            unzipHelper (index + 1)
                    else
                        (array1, array2, array3, array4);
            in
                update array1 0 first1
                `seq`
                update array2 0 first2
                `seq`
                update array3 0 first3
                `seq`
                update array4 0 first4
                `seq`
                unzipHelper 1;

/* @example */
unzip4Examples :: Boolean;
unzip4Examples =
    assert (unzip4 (fromList [("fred", Just 2.0, True, 0.1), ("bob", Just 100, False, 0.9), ("arthur", Just 70, True, 0.99)]) == (fromList ["fred", "bob", "arthur"], fromList [Just 2.0, Just 100, Just 70], fromList [True, False, True], fromList [0.1, 0.9, 0.99]))
    && assert (unzip4 (empty :: Array (Int, Char, (Boolean, Boolean), Maybe Char)) == (empty, empty, empty, empty)) 
    ;

/**
 * Constructs an empty array.
 * 
 * @return an empty array.
 */
array0 :: Array a;
public array0 = empty;

/**
 * Constructs an array of one item.
 * 
 * @arg item the item.
 * @return the array containing the specified item.
 */
/*
 * @implementation array1 could be implemented as
 * public array1 !item = fromList [item];
 * but the following implementation avoids the creation of the intermediate list.
 */
array1 :: a -> Array a;
public array1 !item = array1Internal (elementType_fromValue item) item;
         
array1Internal :: ElementType -> a -> Array a;
private array1Internal !elementType !item =
    case elementType of         
    CharType ->
        CharArray (charArray_array1 (unsafeCoerce item));        
        
    BooleanType ->
        BooleanArray (booleanArray_array1 (unsafeCoerce item));  
        
    ByteType ->
        ByteArray (byteArray_array1 (unsafeCoerce item));  
        
    ShortType ->
        ShortArray (shortArray_array1 (unsafeCoerce item)); 
                    
    IntType ->
        IntArray (intArray_array1 (unsafeCoerce item)); 
       
    LongType ->
        LongArray (longArray_array1 (unsafeCoerce item)); 
            
    FloatType ->
        FloatArray (floatArray_array1 (unsafeCoerce item)); 
        
    DoubleType ->
        DoubleArray (doubleArray_array1 (unsafeCoerce item)); 
      
    ObjectType ->
        ObjectArray (objectArray_array1 (unsafeCoerce item));
        
    CalValueType ->
        CalValueArray (calValueArray_array1 (unsafeCoerce item)); 
    ;

/**
 * Constructs an array of two items.
 * 
 * @arg item1 the first item.
 * @arg item2 the second item.
 * @return the array containing all the specified items.
 */
array2 :: a -> a -> Array a;
public array2 !item1 !item2 = array2Internal (elementType_fromValue item1) item1 item2;
    
array2Internal :: ElementType -> a -> a -> Array a;
private array2Internal !elementType !item1 !item2 =    
    
    case elementType of
          
    CharType ->
        CharArray (charArray_array2 (unsafeCoerce item1) (unsafeCoerce item2));        
        
    BooleanType ->
        BooleanArray (booleanArray_array2 (unsafeCoerce item1) (unsafeCoerce item2));  
        
    ByteType ->
        ByteArray (byteArray_array2 (unsafeCoerce item1) (unsafeCoerce item2));  
        
    ShortType ->
        ShortArray (shortArray_array2 (unsafeCoerce item1) (unsafeCoerce item2)); 
                    
    IntType ->
        IntArray (intArray_array2 (unsafeCoerce item1) (unsafeCoerce item2)); 
       
    LongType ->
        LongArray (longArray_array2 (unsafeCoerce item1) (unsafeCoerce item2)); 
            
    FloatType ->
        FloatArray (floatArray_array2 (unsafeCoerce item1) (unsafeCoerce item2)); 
        
    DoubleType ->
        DoubleArray (doubleArray_array2 (unsafeCoerce item1) (unsafeCoerce item2)); 
      
    ObjectType ->
        ObjectArray (objectArray_array2 (unsafeCoerce item1) (unsafeCoerce item2));
        
    CalValueType ->
        CalValueArray (calValueArray_array2 (unsafeCoerce item1) (unsafeCoerce item2)); 
    ;          

/**
 * Constructs an array of three items.
 * 
 * @arg item1 the first item.
 * @arg item2 the second item.
 * @arg item3 the third item.
 * @return the array containing all the specified items.
 */
array3 :: a -> a -> a -> Array a;
public array3 !item1 !item2 !item3 = array3Internal (elementType_fromValue item1) item1 item2 item3;

array3Internal :: ElementType -> a -> a -> a -> Array a;
private array3Internal !elementType !item1 !item2 !item3 =    
    case elementType of
          
    CharType ->
        CharArray (charArray_array3 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3));        
        
    BooleanType ->
        BooleanArray (booleanArray_array3 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3));  
        
    ByteType ->
        ByteArray (byteArray_array3 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3));  
        
    ShortType ->
        ShortArray (shortArray_array3 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3)); 
                    
    IntType ->
        IntArray (intArray_array3 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3)); 
       
    LongType ->
        LongArray (longArray_array3 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3)); 
            
    FloatType ->
        FloatArray (floatArray_array3 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3)); 
        
    DoubleType ->
        DoubleArray (doubleArray_array3 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3)); 
      
    ObjectType ->
        ObjectArray (objectArray_array3 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3));
        
    CalValueType ->
        CalValueArray (calValueArray_array3 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3)); 
    ; 
    
/**
 * Constructs an array of four items.
 * 
 * @arg item1 the first item.
 * @arg item2 the second item.
 * @arg item3 the third item.
 * @arg item4 the fourth item.
 * @return the array containing all the specified items.
 */
array4 :: a -> a -> a -> a -> Array a;
public array4 !item1 !item2 !item3 !item4 = array4Internal (elementType_fromValue item1) item1 item2 item3 item4;

array4Internal :: ElementType -> a -> a -> a -> a -> Array a;
private array4Internal !elementType !item1 !item2 !item3 !item4 =
    case elementType of
          
    CharType ->
        CharArray (charArray_array4 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4));        
        
    BooleanType ->
        BooleanArray (booleanArray_array4 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4));  
        
    ByteType ->
        ByteArray (byteArray_array4 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4));  
        
    ShortType ->
        ShortArray (shortArray_array4 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4)); 
                    
    IntType ->
        IntArray (intArray_array4 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4)); 
       
    LongType ->
        LongArray (longArray_array4 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4)); 
            
    FloatType ->
        FloatArray (floatArray_array4 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4)); 
        
    DoubleType ->
        DoubleArray (doubleArray_array4 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4)); 
      
    ObjectType ->
        ObjectArray (objectArray_array4 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4));
        
    CalValueType ->
        CalValueArray (calValueArray_array4 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4)); 
    ;

/**
 * Constructs an array of five items.
 * 
 * @arg item1 the first item.
 * @arg item2 the second item.
 * @arg item3 the third item.
 * @arg item4 the fourth item.
 * @arg item5 the fifth item.
 * @return the array containing all the specified items.
 */
array5 :: a -> a -> a -> a -> a -> Array a;
public array5 !item1 !item2 !item3 !item4 !item5 = array5Internal (elementType_fromValue item1) item1 item2 item3 item4 item5;
    
array5Internal :: ElementType -> a -> a -> a -> a -> a -> Array a;
private array5Internal !elementType !item1 !item2 !item3 !item4 !item5 =
    case elementType of    
          
    CharType ->
        CharArray (charArray_array5 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5));        
        
    BooleanType ->
        BooleanArray (booleanArray_array5 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5));  
        
    ByteType ->
        ByteArray (byteArray_array5 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5));  
        
    ShortType ->
        ShortArray (shortArray_array5 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5)); 
                    
    IntType ->
        IntArray (intArray_array5 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5)); 
       
    LongType ->
        LongArray (longArray_array5 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5)); 
            
    FloatType ->
        FloatArray (floatArray_array5 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5)); 
        
    DoubleType ->
        DoubleArray (doubleArray_array5 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5)); 
      
    ObjectType ->
        ObjectArray (objectArray_array5 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5));
        
    CalValueType ->
        CalValueArray (calValueArray_array5 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5)); 
    ;

/**
 * Constructs an array of six items.
 * 
 * @arg item1 the first item.
 * @arg item2 the second item.
 * @arg item3 the third item.
 * @arg item4 the fourth item.
 * @arg item5 the fifth item.
 * @arg item6 the sixth item.
 * @return the array containing all the specified items.
 */
array6 :: a -> a -> a -> a -> a -> a -> Array a;
public array6 !item1 !item2 !item3 !item4 !item5 !item6 = array6Internal (elementType_fromValue item1) item1 item2 item3 item4 item5 item6;
    
array6Internal :: ElementType -> a -> a -> a -> a -> a -> a -> Array a;
private array6Internal !elementType !item1 !item2 !item3 !item4 !item5 !item6 =    
    
    case elementType of
          
    CharType ->
        CharArray (charArray_array6 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6));        
        
    BooleanType ->
        BooleanArray (booleanArray_array6 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6));  
        
    ByteType ->
        ByteArray (byteArray_array6 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6));  
        
    ShortType ->
        ShortArray (shortArray_array6 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6)); 
                    
    IntType ->
        IntArray (intArray_array6 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6)); 
       
    LongType ->
        LongArray (longArray_array6 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6)); 
            
    FloatType ->
        FloatArray (floatArray_array6 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6)); 
        
    DoubleType ->
        DoubleArray (doubleArray_array6 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6)); 
      
    ObjectType ->
        ObjectArray (objectArray_array6 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6));
        
    CalValueType ->
        CalValueArray (calValueArray_array6 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6)); 
    ;

/**
 * Constructs an array of seven items.
 * 
 * @arg item1 the first item.
 * @arg item2 the second item.
 * @arg item3 the third item.
 * @arg item4 the fourth item.
 * @arg item5 the fifth item.
 * @arg item6 the sixth item.
 * @arg item7 the seventh item.
 * @return the array containing all the specified items.
 */
array7 :: a -> a -> a -> a -> a -> a -> a -> Array a;
public array7 !item1 !item2 !item3 !item4 !item5 !item6 !item7 = array7Internal (elementType_fromValue item1) item1 item2 item3 item4 item5 item6 item7;
    
array7Internal :: ElementType -> a -> a -> a -> a -> a -> a -> a -> Array a;
private array7Internal !elementType !item1 !item2 !item3 !item4 !item5 !item6 !item7 =      

    case elementType of
          
    CharType ->
        CharArray (charArray_array7 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6) (unsafeCoerce item7));        
        
    BooleanType ->
        BooleanArray (booleanArray_array7 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6) (unsafeCoerce item7));  
        
    ByteType ->
        ByteArray (byteArray_array7 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6) (unsafeCoerce item7));  
        
    ShortType ->
        ShortArray (shortArray_array7 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6) (unsafeCoerce item7)); 
                    
    IntType ->
        IntArray (intArray_array7 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6) (unsafeCoerce item7)); 
       
    LongType ->
        LongArray (longArray_array7 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6) (unsafeCoerce item7)); 
            
    FloatType ->
        FloatArray (floatArray_array7 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6) (unsafeCoerce item7)); 
        
    DoubleType ->
        DoubleArray (doubleArray_array7 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6) (unsafeCoerce item7)); 
      
    ObjectType ->
        ObjectArray (objectArray_array7 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6) (unsafeCoerce item7));
        
    CalValueType ->
        CalValueArray (calValueArray_array7 (unsafeCoerce item1) (unsafeCoerce item2) (unsafeCoerce item3) (unsafeCoerce item4) (unsafeCoerce item5) (unsafeCoerce item6) (unsafeCoerce item7)); 
    ;

/**
 * Removes the array item at the specified index.
 * Note that the argument array is not modified.
 * Fails in a run-time error if index is not a valid index into the argument array.
 * 
 * @arg index the index of the item to be removed.
 * @arg array the array from which an item is to be removed.
 * @return the array with the item at the specified index removed.
 */    
deleteAt :: Int -> Array a -> Array a;
public deleteAt !index !array =
    deleteRange index (index + 1) array;

/* @example */
deleteAtExamples :: Boolean;
deleteAtExamples =
    assert (deleteAt 0 (fromList ['a', 'b', 'c']) == fromList ['b', 'c'])
    && assert (deleteAt 1 (fromList ['a', 'b', 'c']) == fromList ['a', 'c'])
    && assert (deleteAt 2 (fromList [3.0, 1, 4]) == fromList [3, 1])    
    && assert (deleteAt 0 (fromList ["foo", "bar"]) == fromList ["bar"])
    && assert (deleteAt 1 (fromList ["foo", "bar"]) == fromList ["foo"])   
    && assert (deleteAt 1 (fromList [1 :: Integer, 2, 3]) == fromList [1, 3])    
    && assert (deleteAt 3 (fromList [LT, GT, LT, EQ]) == fromList [LT, GT, LT])   
    && assert (deleteAt 0 (fromList [(2.0, "abc"), (10.0, "pear")]) == fromList [(10.0, "pear")])    
    && assert (deleteAt 2 (fromList [Just LT, Just GT, Just LT, Just EQ]) == fromList [Just LT, Just GT, Just EQ])    
    ;    

/**
 * Removes the array items at the specified range of indices.
 * Note that the argument array is not modified.
 * Fails in a run-time error if
 * 
 * {@unorderedList
 * {@item {@code fromIndex < 0@}@}
 * {@item {@code toIndex > length array@}@}
 * {@item {@code fromIndex > toIndex@}@}
 * @}
 *    
 * @arg fromIndex the index of the first element to be removed.
 * @arg toIndex one more than the index of the last element to be removed.
 * @arg array the array from which the given values at the specified range of indices are to be removed.
 * @return the array with the items at the specified range of indices removed.
 */ 
deleteRange :: Int -> Int -> Array a -> Array a;
public deleteRange !fromIndex !toIndex !array =

    case array of   
    CharArray {values} ->
        let
            newValues :: JCharArray;
            newValues = array_removeRange values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                CharArray newValues;
                               
    BooleanArray {values} ->
        let
            newValues :: JBooleanArray;
            newValues = array_removeRange values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                BooleanArray newValues;
        
    ByteArray {values} ->
        let
            newValues :: JByteArray;
            newValues = array_removeRange values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                ByteArray newValues;
        
    ShortArray {values} ->
        let
            newValues :: JShortArray;
            newValues = array_removeRange values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                ShortArray newValues;
                    
    IntArray {values} ->
        let
            newValues :: JIntArray;
            newValues = array_removeRange values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                IntArray newValues;
       
    LongArray {values} ->
        let
            newValues :: JLongArray;
            newValues = array_removeRange values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                LongArray newValues;
            
    FloatArray {values} ->
        let
            newValues :: JFloatArray;
            newValues = array_removeRange values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                FloatArray newValues;
        
    DoubleArray {values} ->
        let
            newValues :: JDoubleArray;
            newValues = array_removeRange values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                DoubleArray newValues;
       
    ObjectArray {values} ->                    
        let
            newValues :: JObjectArray;
            newValues = array_removeRange values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                ObjectArray newValues;
        
    CalValueArray {values} ->
        let
            newValues :: JCalValueArray;
            newValues = array_removeRange values fromIndex toIndex;
        in
            if array_length newValues == 0 then
                empty
            else
                CalValueArray newValues;
    
    EmptyArray ->
        if emptyArray_isRemoveRangeOK fromIndex toIndex then
            empty
        else
            undefined;
    ;

/* @example */
deleteRangeExamples :: Boolean;
deleteRangeExamples =
    assert (deleteRange 0 2 (fromList ['a', 'b', 'c']) == fromList ['c'])
    && assert (deleteRange 1 3 (fromList ['a', 'b', 'c']) == fromList ['a'])
    && assert (deleteRange 0 3 (fromList [3.0, 1, 4]) == empty)    
    && assert (deleteRange 0 2 (fromList ["foo", "bar"]) == empty)    
    && assert (deleteRange 1 3 (fromList [1 :: Integer, 2, 3]) == fromList [1])    
    && assert (deleteRange 1 3 (fromList [LT, GT, LT, EQ]) == fromList [LT, EQ])     
    && assert (deleteRange 2 4 (fromList [Just LT, Nothing, Just GT, Just LT, Just EQ]) == fromList [Just LT, Nothing, Just EQ])    
    ;    

/**
 * Updates an array at a specified index with a new element value. The returned array is a copy
 * and the original array is unmodified (as is required by the fact that the {@link typeConstructor = Array@} type is a
 * pure-functional type).
 * Terminates in an error if index is not a valid array index.
 * 
 * @arg index zero-based index to update.
 * @arg value to set into the array.
 * @arg array to be updated.
 * @return updated array.
 */
updateAt :: Int -> a -> Array a -> Array a;
public updateAt !index !value !array =
        
    case array of      
    CharArray {values} ->
        let
            newValues :: JCharArray;
            newValues = eager $ array_cloneReplacingNullArray values;
        in        
            charArray_update newValues index (unsafeCoerce value)
            `seq`
            CharArray newValues;
        
    BooleanArray {values} ->
        let
            newValues :: JBooleanArray;
            newValues = eager $ array_cloneReplacingNullArray values;
        in        
            booleanArray_update newValues index (unsafeCoerce value)
            `seq`
            BooleanArray newValues;
      
    ByteArray {values} ->
        let
            newValues :: JByteArray;
            newValues = eager $ array_cloneReplacingNullArray values;
        in        
            byteArray_update newValues index (unsafeCoerce value)
            `seq`
            ByteArray newValues;
        
    ShortArray {values} ->
        let
            newValues :: JShortArray;
            newValues = eager $ array_cloneReplacingNullArray values;
        in        
            shortArray_update newValues index (unsafeCoerce value)
            `seq`
            ShortArray newValues;
    
    IntArray {values} ->
        let
            newValues :: JIntArray;
            newValues = eager $ array_cloneReplacingNullArray values;
        in        
            intArray_update newValues index (unsafeCoerce value)
            `seq`
            IntArray newValues;
        
    LongArray {values} ->
        let
            newValues :: JLongArray;
            newValues = eager $ array_cloneReplacingNullArray values;
        in        
            longArray_update newValues index (unsafeCoerce value)
            `seq`
            LongArray newValues;
       
    FloatArray {values} ->
        let
            newValues :: JFloatArray;
            newValues = eager $ array_cloneReplacingNullArray values;
        in        
            floatArray_update newValues index (unsafeCoerce value)
            `seq`
            FloatArray newValues;
       
    DoubleArray {values} ->
        let
            newValues :: JDoubleArray;
            newValues = eager $ array_cloneReplacingNullArray values;
        in        
            doubleArray_update newValues index (unsafeCoerce value)
            `seq`
            DoubleArray newValues;

       
    ObjectArray {values} ->
        let
            newValues :: JObjectArray;
            newValues = eager $ array_cloneReplacingNullArray values;
        in        
            objectArray_update newValues index (unsafeCoerce value)
            `seq`
            ObjectArray newValues;
      
    CalValueArray {values} ->
        let
            newValues :: JCalValueArray;
            newValues = eager $ array_cloneReplacingNullArray values;
        in        
            calValueArray_update newValues index (unsafeCoerce value)
            `seq`
            CalValueArray newValues;
    
    EmptyArray ->
        emptyArray_update index value
        `seq`
        empty;
    ;

/* @example */
updateAtExamples :: Boolean;
updateAtExamples =
    let
        a1 :: Array Char;
        a1 = fromString "orange";
    in
        assert (updateAt 2 'i' a1 == fromString "oringe")
        //the original array a1 is not mutated after updating
        && assert (a1 == fromString "orange")
        ;

/**
 * Inserts a value into a array at the specified index.
 *
 * @arg index the zero-based index. 
 * @arg value the value to be inserted.
 * @arg array the array to which the value is to be inserted.
 * @return the array with the value inserted at the specified index.
 */
//todoBI more efficient implementation possible by directly delegating to foreign functions (fewer temp arrays)
insertAt :: Int -> a -> Array a -> Array a;
public insertAt !index value !array = 
    insertArrayAt index (array1Internal (elementType_fromValue value) value) array;                   

/**
 * Inserts values into a array at the specified index.
 *
 * @arg index the zero-based index.
 * @arg valuesToInsert the values to be inserted. 
 * @arg array the array to which the values are to be inserted.
 * @return the array with the values inserted at the specified index.
 */
//todoBI more efficient implementation possible by directly delegating to foreign functions (fewer temp arrays)
//however, this is not too bad...
insertArrayAt :: Int -> Array a -> Array a -> Array a;
public insertArrayAt !index !valuesToInsert !array =
    if isEmpty valuesToInsert then
        array
    else
        concatArray [eager (subArray array 0 index), valuesToInsert, eager (subArray array index (length array))];     

/* @example */
insertArrayAtExamples :: Boolean;
insertArrayAtExamples =
    assert (insertArrayAt 0 (fromString "apple") (fromString "orange") == fromString "appleorange")
    && assert (insertArrayAt 6 (fromString "apple") (fromString "orange") == fromString "orangeapple")
    && assert (insertArrayAt 2 (fromString "apple") (fromString "orange") == fromString "orappleange")
    ;        

/**
 * Assuming that {@code array1@} and {@code array2@} are sorted, {@code merge array1 array2@} will merge all
 * the elements of the two arrays into a single sorted array. If an element of {@code array1@} is equal
 * to an element of {@code array2@}, then the element of {@code array1@} will be before the element of {@code array2@}
 * in the merged result.
 * 
 * @arg array1 assumed to be sorted
 * @arg array2 assumed to be sorted
 * @return the result of merging {@code array1@} and {@code array2@}. Will be a sorted array.
 */    
merge :: Ord a => Array a -> Array a -> Array a;
public merge !array1 !array2 =
    mergeBy compare array1 array2; 

/* @example */
mergeExamples :: Boolean;
mergeExamples =
    assert (merge (fromList [1 :: Int, 3, 5]) (fromList [2, 4, 6]) == (fromList [1, 2, 3, 4, 5, 6]))
    && assert (merge empty empty == (empty :: Array Int))
    && assert (merge empty (fromString "ab") == fromString "ab")
    && assert (merge (fromString "cd") empty == fromString "cd")
    && assert (merge (fromString "abdeghjk") (fromString "cdfijlm") == fromString "abcddefghijjklm")
    ;

/**
 * Assuming that {@code array1@} and {@code array2@} are sorted according to {@code comparator@},
 * {@code mergeBy comparator array1 array2@} will merge all the elements of the two arrays into
 * a single array sorted according to {@code comparator@}. If an element of {@code array1@} is equal
 * to an element of {@code array2@} under the comparator, then the element of {@code array1@} will
 * be before the element of {@code array2@} in the merged result.
 * 
 * @arg comparator comparison function to define the order of elements.
 * @arg array1 assumed to be sorted according to 'comparator'
 * @arg array2 assumed to be sorted according to 'comparator'
 * @return the result of merging {@code array1@} and {@code array2@}. Will be sorted according to {@code comparator@}.
 */    
mergeBy :: (a -> a -> Ordering) -> Array a -> Array a -> Array a;
public mergeBy comparator !array1 !array2 =       
    let
        length1 :: Int;
        length1 = eager $ length array1;
        
        length2 :: Int;
        length2 = eager $ length array2;
        
        mergedLength :: Int;
        mergedLength = length1 + length2;
    in
        if mergedLength == 0 then
            empty
        else
            let
                elementType :: ElementType;
                elementType =
                    if length1 == 0 then
                        elementType_fromNonEmptyArray array2
                    else
                        elementType_fromNonEmptyArray array1;
                
                //mergedArray will be initialized by mergeByHelper
                mergedArray :: Array a;
                mergedArray = eager (makeDefaultInternal elementType mergedLength);
                
                mergeByHelper !array1Index !array2Index !mergedIndex =
                    if array2Index >= length2 then
                        //copy the remaining elements of array1
                        if length1 == 0 then
                            mergedArray
                        else
                            nonEmptyArrayCopy array1 array1Index mergedArray mergedIndex (length1 - array1Index)      
                        
                    else if array1Index >= length1 then
                        //copy the remaining elements of array2
                        if length2 == 0 then
                            mergedArray
                        else
                            nonEmptyArrayCopy array2 array2Index mergedArray mergedIndex (length2 - array2Index)
                        
                    else
                        let
                            elem1 = eager (subscript array1 array1Index);
                            elem2 = eager (subscript array2 array2Index);
                        in                
                            case comparator elem1 elem2 of
                            GT ->
                                update mergedArray mergedIndex elem2
                                `seq`
                                mergeByHelper array1Index (array2Index + 1) (mergedIndex + 1);
                            _ ->
                                update mergedArray mergedIndex elem1
                                `seq`
                                mergeByHelper (array1Index + 1) array2Index (mergedIndex + 1);
                    ;
            in
                mergeByHelper 0 0 0;

/* @example */
mergeByExamples :: Boolean;
mergeByExamples = 
    //mergeBy orders equal elements of the first array first.                                 
    assert (mergeBy (\x y -> compare (fst x) (fst y))
                    (fromList [(1 :: Int, 'a'), (1, 'e'), (3, 'd')])
                    (fromList [(1, 'b'), (1, 'c'), (3, 'b'), (3, 'c')])
            == fromList [(1, 'a'), (1, 'e'), (1, 'b'), (1, 'c'), (3, 'd'), (3, 'b'), (3, 'c')])
    ;

/**
 * Sorts the specified array. All order comparisons are done using the
 * {@link Prelude.compare@} class method.
 * 
 * This function implements a stable sort in that items which evaluate to {@link EQ@}
 * under the {@link Prelude.compare@} class method preserve their original ordering in the original
 * array.
 * 
 * @arg array the array to be sorted.
 * @return the sorted array.
 * @see sortBy
 */    
sort :: Ord a => Array a -> Array a;
public sort !array =
    sortBy compare array;         

/**
 * Sorts the specified array. All order comparisons are done using the
 * {@link Prelude.compare@} class method.
 * 
 * This function implements a stable sort in that items which evaluate to {@link EQ@}
 * under the {@link Prelude.compare@} class method preserve their original ordering in the original
 * array.
 * 
 * This should yield better performance for primitive arrays then the {@link sort@} function.
 * 
 * @arg array the array to be sorted.
 * @return the sorted array.
 * @see sort, sortBy
 */
/*
 * @implementation
 * This function is currently protected in scope. We may want to revisit this later to consider how best to
 * expose this functionality in the API.
 */
sortPrimitive :: (Typeable a, Ord a) => Array a -> Array a;
protected sortPrimitive !array =
    if isEmpty array then
        empty
    else
        let       
            typeableElementType :: ElementType;
            typeableElementType =
                let
                    elementTypeHelper :: Array a -> a;
                    elementTypeHelper = undefined;
                in            
                    typeableElementType_fromValue (elementTypeHelper array);
        in
            case typeableElementType of
            CharType ->
                CharArray $ charArray_sort array.CharArray.values;
            
            BooleanType ->
                BooleanArray $ booleanArray_sort array.BooleanArray.values;
            
            ByteType ->
                ByteArray $ byteArray_sort array.ByteArray.values;
            
            ShortType ->
                ShortArray $ shortArray_sort array.ShortArray.values;
            
            IntType ->
                IntArray $ intArray_sort array.IntArray.values;
            
            LongType ->
                LongArray $ longArray_sort array.LongArray.values;
            
            FloatType ->
                FloatArray $ floatArray_sort array.FloatArray.values;
            
            DoubleType ->
                DoubleArray $ doubleArray_sort array.DoubleArray.values;
            
            _ ->
                sort array;
    ;

/* @example */
sortExamples :: Boolean;
private sortExamples =
    assert (sort (fromList ['z','e','b','r','a']) == fromList ['a','b','e','r','z'])
    && assert (sortPrimitive (fromList ['z','e','b','r','a']) == fromList ['a','b','e','r','z'])
    
    && assert (sort (fromList [90, 80, 70, 60, 50, 40, 30, 20, 10]) == fromList [10 :: Int, 20, 30, 40, 50, 60, 70, 80, 90]) 
    && assert (sortPrimitive (fromList [90, 80, 70, 60, 50, 40, 30, 20, 10]) == fromList [10 :: Int, 20, 30, 40, 50, 60, 70, 80, 90])
    
    && assert (sort (fromList [20, 70, 10, 49.5]) == fromList [10, 20, 49.5, 70])
    && assert (sortPrimitive (fromList [20, 70, 10, 49.5]) == fromList [10, 20, 49.5, 70])
    
    && assert (sort (fromList [-20 :: Integer, 70, 10, 40, 30, 1]) == fromList [-20, 1, 10, 30, 40, 70])
    && assert (sortPrimitive (fromList [-20 :: Integer, 70, 10, 40, 30, 1]) == fromList [-20, 1, 10, 30, 40, 70])
    
    && assert (sort (fromList ["Apple", "apple", "Pear", "pear", "banana", "Banana"])
          == fromList ["Apple", "Banana", "Pear", "apple", "banana", "pear"])
    && assert (sortPrimitive (fromList ["Apple", "apple", "Pear", "pear", "banana", "Banana"])
          == fromList ["Apple", "Banana", "Pear", "apple", "banana", "pear"])
    
    && assert ((sort empty :: Array Char) == empty)
    && assert ((sortPrimitive empty :: Array Char) == empty)
    ;

/**
 * Sorts the specified array according to the specified comparison function. All
 * order comparisons are done using the supplied comparison function.
 * 
 * This function implements a stable sort in that items which evaluate to {@link EQ@}
 * under the {@code comparisonFunction@} preserve their original ordering in the original
 * array.
 * 
 * @arg comparisonFunction the comparison function to use in determining the
 *      order of the elements.
 * @arg array the array to be sorted.
 * @return the sorted array.
 */
sortBy :: (a -> a -> Ordering) -> Array a -> Array a;
public sortBy !comparisonFunction !array =
    if isEmpty array then
        empty
    else
        let
            valuesToSort :: JCalValueArray;
            valuesToSort = eager (internalArrayValues array);
            
            sortedValues :: JCalValueArray;
            sortedValues =
                objectArray_sort (unsafeCoerce valuesToSort) (Prelude.makeComparator comparisonFunction)
                `seq`
                valuesToSort;
        in
            makeArrayFromCalValues (elementType_fromNonEmptyArray array) sortedValues;

/* @example */
sortByExamples :: Boolean;
private sortByExamples =
    assert (sortBy compare (array4 'd' 'a' 'b' 'e') == array4 'a' 'b' 'd' 'e')
    && assert (sortBy compare (fromList ['z','e','b','r','a']) == fromList ['a','b','e','r','z'])
    && assert (sortBy compare (fromList [90, 80, 70, 60, 50, 40, 30, 20, 10]) == fromList [10 :: Int, 20, 30, 40, 50, 60, 70, 80, 90]) 
    && assert (sortBy compare (fromList [20, 70, 10, 49.5]) == fromList [10, 20, 49.5, 70])
    && assert (sortBy compare (fromList [-20 :: Integer, 70, 10, 40, 30, 1]) == fromList [-20, 1, 10, 30, 40, 70])
    && assert (sortBy compare (fromList ["Apple", "apple", "Pear", "pear", "banana", "Banana"])
          == fromList ["Apple", "Banana", "Pear", "apple", "banana", "pear"])
    && assert ((sortBy compare empty :: Array Char) == empty) 
    && assert (sortBy compare (array4 GT LT EQ LT) == array4 LT LT EQ GT)
    
    //sortBy is a stable sort i.e. equal elements do not change their order                                                  
    && assert (sortBy (\x y -> compare (fst x) (fst y)) (fromList [(1, 'a'), (3, 'd'), (1, 'b'), (1, 'c'), (3, 'b'), (3, 'c')] :: Array (Int, Char))
          == fromList [(1, 'a'), (1, 'b'), (1, 'c'), (3, 'd'), (3, 'b'), (3, 'c')])
                              
    && assert (sortBy (\x y -> compare (String.toLowerCase x) (String.toLowerCase y)) (fromList ["Apple", "apple", "Pear", "pear", "banana", "Banana"])
          == fromList ["Apple", "apple", "banana", "Banana", "Pear", "pear"])    
    && assert (sortBy (\x y -> compare (String.toLowerCase x) (String.toLowerCase y)) empty == empty)    
    ;

/**
 * Searches the array for the specified value using the binary search algorithm. The array must be
 * sorted (via the ordering defined by {@link Prelude.compare@}) for the result to be well-defined. 
 * If the array contains multiple elements that are equal to the specified value, there is no guarantee
 * which specific one will be found.
 * 
 * If the array does not contain the specified value, a negative value will be returned. This negative value
 * is equal to {@code (-insertionPoint - 1)@} where {@code insertionPoint@} is the point at which the value would need to
 * be inserted into the array to maintain a sorted array.
 * 
 * @arg array sorted array to search
 * @arg value the value to search for
 * @return the index of value in the array, or a negative value if value does not occur in the array.
 * @see binarySearchBy
 */
binarySearch :: Ord a => Array a -> a -> Int;
public binarySearch !array !value =
    binarySearchBy compare array value;         

/**
 * Searches the array for the specified value using the binary search algorithm. The array must be
 * sorted (via the ordering defined by {@link Prelude.compare@}) for the result to be well-defined. 
 * If the array contains multiple elements that are equal to the specified value, there is no guarantee
 * which specific one will be found.
 * 
 * If the array does not contain the specified value, a negative value will be returned. This negative value
 * is equal to {@code (-insertionPoint - 1)@} where {@code insertionPoint@} is the point at which the value would need to
 * be inserted into the array to maintain a sorted array.
 * 
 * This should yield better performance for primitive arrays then the {@link binarySearch@} function.
 * 
 * @arg array sorted array to search
 * @arg value the value to search for
 * @return the index of value in the array, or a negative value if value does not occur in the array.
 * @see binarySearch, binarySearchBy
 */
/*
 * @implementation
 * This function is currently protected in scope. We may want to revisit this later to consider how best to
 * expose this functionality in the API.
 */
binarySearchPrimitive :: (Typeable a, Ord a) => Array a -> a -> Int;
protected binarySearchPrimitive !array !value =
    if isEmpty array then
        -1
    else
        let       
            typeableElementType :: ElementType;
            typeableElementType =
                let
                    elementTypeHelper :: Array a -> a;
                    elementTypeHelper = undefined;
                in            
                    typeableElementType_fromValue (elementTypeHelper array);
        in
            case typeableElementType of
            CharType ->
                charArray_binarySearch array.CharArray.values (unsafeCoerce value);
            
//          todoBI it doesn't seem important to do this more efficiently, but it could be done.        
//          BooleanType ->
//              booleanArray_binarySearch array.BooleanArray.values (unsafeCoerce value);
            
            ByteType ->
                byteArray_binarySearch array.ByteArray.values (unsafeCoerce value);
            
            ShortType ->
                shortArray_binarySearch array.ShortArray.values (unsafeCoerce value);
            
            IntType ->
                intArray_binarySearch array.IntArray.values (unsafeCoerce value);
            
            LongType ->
                longArray_binarySearch array.LongArray.values (unsafeCoerce value);
            
            FloatType ->
                floatArray_binarySearch array.FloatArray.values (unsafeCoerce value);
            
            DoubleType ->
                doubleArray_binarySearch array.DoubleArray.values (unsafeCoerce value);
            
            _ ->
                binarySearch array value;
        ;

/* @example */
binarySearchExamples :: Boolean;
binarySearchExamples =
    assert (binarySearch (fromList [10 :: Int, 20, 30, 40, 50]) 50 == 4)
    && assert (binarySearchPrimitive (fromList [10 :: Int, 20, 30, 40, 50]) 50 == 4)
    
    && assert (binarySearch (fromList [10 :: Byte, 20, 30, 40, 50]) 60 == -6)
    && assert (binarySearchPrimitive (fromList [10 :: Byte, 20, 30, 40, 50]) 60 == -6)
    
    && assert (binarySearch (fromList [10 :: Short, 20, 30, 40, 50]) 0 == -1)
    && assert (binarySearchPrimitive (fromList [10 :: Short, 20, 30, 40, 50]) 0 == -1)
    
    && assert (binarySearch (fromList [10 :: Long, 20, 30, 40, 50]) 10 == 0)
    && assert (binarySearchPrimitive (fromList [10 :: Long, 20, 30, 40, 50]) 10 == 0)
    
    && assert (binarySearch (empty :: Array Double) 10 == -1)
    && assert (binarySearchPrimitive (empty :: Array Double) 10 == -1)
    
    && assert (binarySearch (fromList [False]) False == 0)
    && assert (binarySearchPrimitive (fromList [False]) False == 0)
    
    && assert (binarySearch (fromList [False]) True == -2)
    && assert (binarySearchPrimitive (fromList [False]) True == -2)
    
    && assert (binarySearch (fromList [True]) False == -1)
    && assert (binarySearchPrimitive (fromList [True]) False == -1)
    
    && assert (binarySearch (fromList [True]) True == 0)
    && assert (binarySearchPrimitive (fromList [True]) True == 0)
    
    && assert (binarySearch (fromList [False, True]) True == 1)
    && assert (binarySearchPrimitive (fromList [False, True]) True == 1)
    
    && assert (binarySearch (fromList [False, True]) False == 0)
    && assert (binarySearchPrimitive (fromList [False, True]) False == 0)
    
    && assert (binarySearch (fromList ["apple", "banana", "orange", "pear"]) "tomato" == -5)
    && assert (binarySearchPrimitive (fromList ["apple", "banana", "orange", "pear"]) "tomato" == -5)
    
    && assert (binarySearch (fromList ["apple", "banana", "orange", "pear"]) "abc" == -1)
    && assert (binarySearchPrimitive (fromList ["apple", "banana", "orange", "pear"]) "abc" == -1)
    
    && assert (binarySearch (fromList ["apple", "banana", "orange", "pear"]) "banana" == 1)
    && assert (binarySearchPrimitive (fromList ["apple", "banana", "orange", "pear"]) "banana" == 1)
    
    && assert (binarySearch (fromList ["apple", "banana", "orange", "pear"]) "pear" == 3)
    && assert (binarySearchPrimitive (fromList ["apple", "banana", "orange", "pear"]) "pear" == 3)
    
    && assert (binarySearch (fromList ["apple", "banana", "orange", "pear"]) "cherry" == -3)        
    && assert (binarySearchPrimitive (fromList ["apple", "banana", "orange", "pear"]) "cherry" == -3)        
    ;

/**
 * Searches the array for the specified value using the binary search algorithm. The array must be
 * sorted (via the ordering defined by the {@code comparisonFunction@} argument) for the result to be well-defined. 
 * If the array contains multiple elements that are equal to the specified value (under the notion of equality
 * defined by {@code comparisonFunction@}), there is no guarantee which specific one will be found.
 * 
 * If the array does not contain the specified value, a negative value will be returned. This negative value
 * is equal to {@code (-insertionPoint - 1)@} where {@code insertionPoint@} is the point at which the value would need to
 * be inserted into the array to maintain a sorted array.
 * 
 * @arg comparisonFunction the comparison function to use for the search.
 * @arg array the array to search. Assumed to be sorted according to the ordering established by comparisonFunction.
 * @arg value the value to search for
 * @return the index of value in the array, or a negative value if value does not occur in the array.
 */    
/*
 * @implementation we do not implement by delegating to java.util.Arrays.binarySearch(Object[], Comparator) because
 * we don't want to box every element of the array in the case when the Array type is a primitive unboxed array
 * as in Array Int. A similar thing could be done for sortBy, but it would require implementing the sorting algorithm
 * which is more of a bother...
 */
binarySearchBy :: (a -> a -> Ordering) -> Array a -> a -> Int;
public binarySearchBy !comparisonFunction !array !value = 
    let
        search :: Int -> Int -> Int;
        search !low !high =
            if (low > high) then
                -(low + 1) //value not found
            else                
               let
                   //use eager to avoid creating the graph for mid, which will then be
                   //reduced anyways in evaluating the comparison. Actually, in this case eager is not 
                   //strictly necessary since we automatically treat expressions such as the one below
                   //eagerly. (The expression depends only on evaluated values low and high and involves
                   //a small set of operations from the Prelude that we optimize, including int addition
                   //and int division by a non-zero value.
                   mid :: Int;
                   mid = eager ((low + high) / 2);                   
               in
                   //use eager to avoid greating the graph for 'subscript array mid' which
                   //will almost certainly be reduced anyways by the comparison function.
                   //(The exception would be a comparison function which ignores its first argument
                   //which is only a theoretical situation).
                   case comparisonFunction (eager (subscript array mid)) value of
                   LT ->
                       search (mid + 1) high;
                   EQ ->
                       mid; //value found                  
                   GT ->
                       search low (mid - 1);
                   ;                          
    in
        search 0 (length array - 1);

/* @example */
binarySearchByExamples :: Boolean;
binarySearchByExamples =
    assert (binarySearchBy compare (fromList [10 :: Long, 20, 30, 40, 50]) 50 == 4)
    && assert (binarySearchBy compare (fromList [10 :: Byte, 20, 30, 40, 50]) 60 == -6)
    && assert (binarySearchBy compare (fromList [10 :: Short, 20, 30, 40, 50]) 0 == -1)
    && assert (binarySearchBy compare (fromList [10 :: Integer, 20, 30, 40, 50]) 10 == 0)
    && assert (binarySearchBy compare (empty :: Array Long) 10 == -1)
    ;

/**
 * Returns a compressed version of a byte array.
 *
 * @arg byteArray  the byte array to be compressed
 * @return         the compressed byte array
 * @see decompressBytes
 */
compressBytes :: Array Byte -> Array Byte;
public compressBytes !byteArray = 
    case byteArray of
    ByteArray {values} -> ByteArray (byteArray_compress values);
    EmptyArray -> empty;
    ;

/**
 * Returns an uncompressed version of a compressed byte array.
 *
 * @arg byteArray  the byte array to be decompressed
 * @return         the decompressed byte array
 * @see compressBytes
 */
decompressBytes :: Array Byte -> Array Byte;
public decompressBytes !byteArray = 
    case byteArray of
    ByteArray {values} -> ByteArray (byteArray_decompress values);
    EmptyArray -> empty;
    ;

/**
 * Alternate items from the 2 arrays.
 * If one arrays is longer than the other, then any remaining items will appear at the end of the array.
 * @arg array1  one of the arrays to be merged
 * @arg array2  the other array to be merged
 * @return      an array consisting of alternating items from the input arrays
 */
alternate :: Array a -> Array a -> Array a;
public alternate !array1 !array2 = 
    let
        size1 :: Int;
        size1 = eager $ length array1;
    in
        if size1 == 0 then
            array2
        else
            let
                size2 :: Int;
                size2 = eager $ length array2;
                
                //updatedArray :: Array a;
                updatedArray :: Array a;
                updatedArray = eager $ makeDefaultInternal (elementType_fromNonEmptyArray array1) (size1 + size2);
                
                //processElement :: Int -> Int -> Array a;
                processElement :: Int -> Int -> Array a;
                processElement !inputIndex !outputIndex =
                    if inputIndex < size1 && inputIndex < size2 then
                        update updatedArray outputIndex (subscript array1 inputIndex)
                        `seq`
                        update updatedArray (outputIndex + 1) (subscript array2 inputIndex)
                        `seq`
                        processElement (inputIndex + 1) (outputIndex + 2)
                    else if inputIndex < size1 then
                        update updatedArray outputIndex (subscript array1 inputIndex)
                        `seq`
                        processElement (inputIndex + 1) (outputIndex + 1)
                    else if inputIndex < size2 then
                        update updatedArray outputIndex (subscript array2 inputIndex)
                        `seq`
                        processElement (inputIndex + 1) (outputIndex + 1)
                    else
                        updatedArray;
            in
                processElement 0 0;

/* @example */
alternateExamples :: Boolean;
alternateExamples =
    assert (alternate (fromList ['a', 'b', 'c']) (fromList ['A', 'B', 'C', 'D', 'E']) == fromList ['a', 'A', 'b', 'B', 'c', 'C', 'D', 'E'])
    && assert (alternate (fromList [1 :: Int, 2, 3, 4]) (fromList [-1]) == (fromList [1, -1, 2, 3, 4]))
    && assert (alternate (fromList [1 :: Int, 2, 3, 4]) empty == (fromList [1, 2, 3, 4]))
    && assert (alternate empty (fromList [-1.0]) == (fromList [-1.0]))
    && assert (alternate empty empty == (empty :: Array Char));

/**
 * @return index of the first element for which predicate returns True, or
 *         -1 if predicate returns False for all elements
 */
indexOfBy :: (a -> Boolean) -> Array a -> Int;
private indexOfBy predicate !array =
    let
        arrayLength :: Int;
        arrayLength = eager (length array);
        
        search :: Int -> Int;
        search !index =
            if index >= arrayLength then
                -1
            else if predicate (eager (subscript array index)) then
                index
            else
                search (index + 1);
    in
        search 0;

/**
 * {@code findIndex predicate array@} returns the first index of array for which the predicate function is {@link True@},
 * if there is one, or {@link Nothing@} otherwise. The index is 0-based.
 * 
 * e.g. {@code findIndex {@link isEven@} ({@link fromList @} [1, 1, 4, 1, 2, 1, 1, 6]) == {@link Just@} 2@}
 * 
 * @arg predicate a predicate to be applied to the elements of the list.
 * @arg array the array to be searched.
 * @return the first index of array for which the predicate function is {@link True@}, if there is one, or {@link Nothing@} otherwise.
 * @see findIndices
 */
findIndex :: (a -> Boolean) -> Array a -> Maybe Int;
public findIndex predicate !array =
    intToMaybe (indexOfBy predicate array);

/* @example */
findIndexExamples :: Boolean;
findIndexExamples =
    assert (findIndex Prelude.isEven (fromList [1 :: Int, 1, 4, 1, 2, 1, 1, 6, 3]) == Just 2)
    && assert (findIndex (equals "apple") (fromList ["apple", "cherry", "peach", "banana", "apple", "orange"]) == Just 0)
    && assert (findIndex (equals "pear") (fromList ["apple", "cherry", "peach", "banana", "apple", "orange"]) == Nothing)
    && assert (findIndex (equals "pear") empty == Nothing)
    ; 
    
/**
 * Returns the indices of all elements satisfying the specified predicate, in ascending order. The index values are 0-based.
 * 
 * e.g. {@code findIndices {@link isEven@} [1, 1, 4, 1, 2, 1, 1, 6] == [2, 4, 7]@}
 * 
 * @arg predicate a predicate to be applied to the elements of the list.
 * @arg array the array to be searched.
 * @return the list of all indices of array for which the predicate function evaluates to {@link True@}.
 * @see findIndex
 */
findIndices :: (a -> Boolean) -> Array a -> [Int];
public findIndices predicate !array =
    let
        arrayLength :: Int;
        arrayLength = eager (length array);
        
        search :: Int -> [Int];
        search !index = 
            if index >= arrayLength then
                []
            else if predicate (eager (subscript array index)) then
                index : search (index + 1)
            else
                search (index + 1);
    in
        search 0;

/* @example */
findIndicesExamples :: Boolean;
private findIndicesExamples =
    assert (findIndices isEven (fromList [1 :: Int, 1, 4, 1, 2, 1, 1, 6, 3]) == [2, 4, 7])
    && assert (findIndices (equals "apple") (fromList ["apple", "cherry", "peach", "banana", "apple", "orange"]) == [0, 4])
    && assert (findIndices (equals "pear") (fromList ["apple", "cherry", "peach", "banana", "apple", "orange"]) == [])
    && assert (findIndices (equals "pear") empty == [])
    ;
        
/**
 * {@code splitAt nElemsToSplit list@} returns a pair of arrays. The first consists of the first {@code nElemsToSplit@}
 * elements of array, the second consists of the remaining elements.
 * 
 * @arg nElementsToSplit the number of elements to be returned in the first array.
 * @arg array the array to be split.
 * @return a pair of arrays. The first consists of the first {@code nElementsToSplit@} elements of array,
 *         the second consists of the remaining elements.
 */
splitAt :: Int -> Array a -> (Array a, Array a);
public splitAt !nElementsToSplit !array =
    let
        size :: Int;
        size = eager (length array);
    in
        if nElementsToSplit >= size then
            (array, empty)
        else if nElementsToSplit <= 0 then
            (empty, array)
        else
            (subArray array 0 nElementsToSplit, subArray array nElementsToSplit size);

/**
 * {@code break predicate array@} breaks up array into a pair of arrays. The start of the second array is the first element of
 * {@code array@} on which predicate is {@link True@}.
 * 
 * @arg predicate a predicate to be applied to the elements of the array.
 * @arg array the array to be broken up into a pair of arrays.
 * @return a pair of arrays, where the first array is the longest prefix of the array for which predicate
 *         is {@link False@} for each element, and the second array contains the remaining elements of the original array.
 */
break :: (a -> Boolean) -> Array a -> (Array a, Array a);
public break predicate !array =
    splitAt (indexOfBy predicate array) array;

/* @example */
breakExamples :: Boolean;
breakExamples =
    assert (break (Prelude.equals 'e') empty == (empty, empty)) &&
    assert (break (Prelude.equals 'e') (array6 'q' 'w' 'e' 'r' 't' 'y') == (array2 'q' 'w', array4 'e' 'r' 't' 'y')) &&
    assert (break (Prelude.lessThan (10 :: Int)) (array4 22 10 8 0) == (empty, array4 22 10 8 0)) &&
    assert (break (Prelude.greaterThan (10 :: Int)) (array4 22 10 8 0) == (array2 22 10, array2 8 0));

/**
 * {@code breakAfter predicate array@} breaks up array into a pair of arrays. The last item of the first array is the first element
 * of array on which the predicate function is {@link True@}.
 * 
 * @arg predicate a predicate to be applied to the elements of the array.
 * @arg array the array to be split.
 * @return a pair of arrays. The last item of the first array is the first element of array
 *         on which the predicate function is {@link True@}. The second array contains the remaining
 *         elements of the original array.
 */
breakAfter :: (a -> Boolean) -> Array a -> (Array a, Array a);
public breakAfter predicate !array =
    splitAt ((indexOfBy predicate array) + 1) array;

/* @example */
breakAfterExamples :: Boolean;
breakAfterExamples =
    assert (breakAfter (Prelude.equals 'e') empty == (empty, empty)) &&
    assert (breakAfter (equals 'e') (array6 'q' 'w' 'e' 'r' 't' 'y') == (array3 'q' 'w' 'e', array3 'r' 't' 'y'));

/**
 * {@code span predicate array@} breaks up {@code array@} into a pair of arrays. The start of the second array is
 * the first element of array on which predicate is False.
 * 
 * @arg predicate a predicate to be applied to the elements of the array.
 * @arg array the array to be broken up into a pair of arrays.
 * @return a pair of arrays, where the first array is the longest prefix of the array for which predicate
 *         is {@link True@} for each element, and the second array contains the remaining elements of the original array.
 */
span :: (a -> Boolean) -> Array a -> (Array a, Array a);
public span predicate !array =
    splitAt (indexOfBy (compose not predicate) array) array;

/* @example */
spanExamples :: Boolean;
spanExamples =
    assert (span (Prelude.equals 'e') empty == (empty, empty)) &&
    assert (span (Char.isUpperCase ) (array6 'Q' 'W' 'E' 'r' 't' 'y') == (array3 'Q' 'W' 'E', array3 'r' 't' 'y'));

/**
 * {@code spanInclusive predicate array@} breaks up array into a pair of arrays. The last item in the first array is the first element
 * of array on which predicate is {@link False@}.
 * 
 * @arg predicate a predicate to be applied to the elements of the array.
 * @arg array the array to be split.
 * @return a pair of arrays. The last item in the first array is the first element of array
 *         on which predicate is {@link False@}. The second array contains the remaining
 *         elements of the original array.
 */
spanInclusive :: (a -> Boolean) -> Array a -> (Array a, Array a);
public spanInclusive predicate !array =
    splitAt ((indexOfBy (compose not predicate) array) + 1) array;

/* @example */
spanInclusiveExamples :: Boolean;
spanInclusiveExamples =
    assert (spanInclusive (Prelude.equals 'e') empty == (empty, empty)) &&
    assert (spanInclusive (Char.isUpperCase ) (array6 'Q' 'W' 'E' 'r' 't' 'y') == (array4 'Q' 'W' 'E' 'r', array2 't' 'y'));

/**
 * {@code drop nElements array@} drops the first {@code nElements@} elements of the array and returns the remaining elements
 * 
 * @arg nElementsToDrop the number of elements to drop.
 * @arg array the array from which elements are to be dropped.
 * @return an array of the remaining elements.
 */
drop :: Int -> Array a -> Array a;
public drop !nElementsToDrop !array =
    let
        size :: Int;
        size = eager (length array);
    in
        if nElementsToDrop >= size then
            empty
        else if nElementsToDrop <= 0 then
            array
        else
            subArray array nElementsToDrop size;

/* @example */
dropExamples :: Boolean;
dropExamples =
    assert (drop (-10) (fromList ["keep", "them", "all"]) == fromList ["keep", "them", "all"])
    && assert (drop 1 (fromList ["keep", "them", "all"]) == fromList ["them", "all"])
    && assert (drop 1 empty == (empty :: Array Char))
    && assert (drop 4 (array4 88.8 6.28 3.1 3.2) == empty); 

/**
 * {@code take nElements array@} returns an array consisting of the first {@code nElements@} elements of {@code array@}.
 * If the array has fewer than {@code nElements@} elements, it just returns the array.
 * 
 * @arg nElementsToTake the number of elements to take.
 * @arg array the array from which elements are to be taken.
 * @return a array of the requested elements from the array.
 */
take :: Int -> Array a -> Array a;
public take !nElementsToTake !array =
    let
        size :: Int;
        size = eager (length array);
    in
        if nElementsToTake >= size then
            array
        else if nElementsToTake <= 0 then
            empty
        else
            subArray array 0 nElementsToTake;

/* @example */
takeExamples :: Boolean;
takeExamples =
    assert (take (-1) (fromList ['q', 'w', 'e', 'r', 't', 'y']) == empty)
    && assert (take 3 (fromList ['q', 'w', 'e', 'r', 't', 'y']) == fromList ['q', 'w', 'e'])
    && assert (take 3 empty == (empty :: Array Char))
    && assert (take 9 (fromList ['q', 'w', 'e', 'r', 't', 'y']) == fromList ['q', 'w', 'e', 'r', 't', 'y']);

/**
 * {@code dropWhile dropWhileTrueFunction list@} drops the longest prefix of the array for which {@code dropWhileTrueFunction@}
 * is {@link True@} for each element.
 * 
 * e.g. {@code dropWhile {@link isEven@} ({@link fromList@} [6, 2, 1, 2]) = ({@link fromList@} [1, 2])@}
 * 
 * @arg dropWhileTrueFunction a predicate to be applied to the elements of the array.
 * @arg array the array from which elements are to be taken.
 * @return the remainder of the array after having dropped the longest prefix in
 *         which {@code dropWhileTrueFunction@} is {@link True@} for each element.
 */
dropWhile :: (a -> Boolean) -> Array a -> Array a;
public dropWhile dropWhileTrueFunction !array =
    drop (indexOfBy (compose not dropWhileTrueFunction) array) array;

/* @example */
dropWhileExamples :: Boolean;
dropWhileExamples =
    assert (dropWhile isEven (fromList [6, 2, 1, 2]) == fromList [1, 2]);

/**
 * {@code takeWhile takeWhileTrueFunction array@} returns the longest prefix of the array for which {@code takeWhileTrueFunction@}
 * is {@link True@} for each element.
 * 
 * e.g. {@code takeWhile {@link isEven@} ({@link fromList@} [6, 2, 1, 2]) = ({@link fromList@} [6, 2])@}
 * 
 * @arg takeWhileTrueFunction a predicate to be applied to the elements of the array.
 * @arg array the array from which elements are to be taken.
 * @return the longest prefix of the array for which {@code takeWhileTrueFunction@} is True 
 *         for each element.
 */
takeWhile :: (a -> Boolean) -> Array a -> Array a;
public takeWhile takeWhileTrueFunction !array =
    take (indexOfBy (compose not takeWhileTrueFunction) array) array;

/* @example */
takeWhileExamples :: Boolean;
takeWhileExamples =
    assert (takeWhile isEven (fromList [6, 2, 1, 2]) == fromList [6, 2]);

/**
 * {@code delete x array@} returns the array with the first element equivalent to {@code x@} removed.
 * 
 * e.g. {@code delete 1 [3, 1, 4, 1, 5, 9] = [3, 4, 1, 5, 9]@}
 * 
 * @arg element the value of the element to be removed.
 * @arg array the array from which an element is to be removed.
 * @return the array with the first element equivalent to x removed.
 * @see deleteBy
 */
delete :: Eq a => a -> Array a -> Array a;
public delete =
    deleteBy equals;

/* @example */
deleteExamples :: Boolean;
deleteExamples =
    assert (delete 'a' (fromList ['q', 'w', 'e', 'r', 't', 'y']) == fromList ['q', 'w', 'e', 'r', 't', 'y'])
    && assert (delete 'e' empty == empty)
    && assert (delete 'e' (fromList ['q', 'w', 'e', 'r', 't', 'y']) == fromList ['q', 'w', 'r', 't', 'y'])
    && assert (delete 'e' (fromList ['h', 'e', 'r', 'e']) == fromList ['h', 'r', 'e']);

/**
 * {@code deleteBy eq element array@} returns the array with the first element equivalent to {@code x@} (under {@code eq@}) removed.
 * 
 * @arg eq the equality comparison function to use in comparing the array elements.
 * @arg element the value of the element to be removed.
 * @arg array the array from which an element is to be removed.
 * @return the array with the first element equivalent to x (under {@code eq@}) removed.
 */
deleteBy :: (a -> b -> Boolean) -> a -> Array b -> Array b;
public deleteBy eq element !array =
    let
        targetIndex :: Int;
        targetIndex = indexOfBy (eq element) array;
    in
        if targetIndex < 0 then
            array
        else
            deleteAt targetIndex array;

/* @example */
deleteByExamples :: Boolean;
deleteByExamples =
    assert (deleteBy equals 'a' (fromList ['q', 'w', 'e', 'r', 't', 'y']) == fromList ['q', 'w', 'e', 'r', 't', 'y'])
    && assert (deleteBy equals 'e' empty == empty)
    && assert (deleteBy equals 'e' (fromList ['q', 'w', 'e', 'r', 't', 'y']) == fromList ['q', 'w', 'r', 't', 'y'])
    && assert (deleteBy equals 'e' (fromList ['h', 'e', 'r', 'e']) == fromList ['h', 'r', 'e']);

/**
 * Returns whether a value is an element of an array, according to the specified equality comparison function.
 * 
 * @arg eq the equality comparison function to use in comparing the array elements.
 * @arg x the value to be tested for membership in the array.
 * @arg array the array to be checked.
 * @return {@link True@} if {@code x@} is an element of the array according to {@code eq@}; {@link False@} otherwise.
 */
isElemBy :: (a -> b -> Boolean) -> a -> Array b -> Boolean;
public isElemBy eq x !array =
    any (eq x) array;

/* @example */
isElemByExamples :: Boolean;
isElemByExamples =
    assert (isElemBy equals 'a' (fromList ['q', 'w', 'e', 'r', 't', 'y']) == False) 
    && assert (isElemBy equals 'a' empty == False) 
    && assert (isElemBy equals 't' (fromList ['q', 'w', 'e', 'r', 't', 'y']) == True);

/**
 * This function takes an element and an array and inserts the element into the
 * array at the last position where it is still less than or equal to the next
 * element. All order comparisons are done using the supplied comparison
 * function.
 * 
 * If the array is sorted before the call, the result will also be sorted.
 * 
 * @arg comparisonFunction the comparison function.
 * @arg value the value to be inserted into the array.
 * @arg array the array.
 * @return a copy of the input array with the specified value inserted.
 */
insertBy :: (a -> a -> Ordering) -> a -> Array a -> Array a;
public insertBy comparisonFunction value !array =
    let
        //insertionPredicate :: a -> Boolean;  (a is non-generic)
        insertionPredicate element =
            case comparisonFunction value element of
            LT -> True;
            _ -> False;
            ;
            
        insertionIndex :: Int;
        insertionIndex = eager $ indexOfBy insertionPredicate array;
    in 
        if insertionIndex < 0 then
            // Everything is smaller than value, so add it to the end
            insertAt (length array) value array
        else
            insertAt insertionIndex value array;

/* @example */
insertByExamples :: Boolean;
insertByExamples =
    assert (insertBy compare 'a' (fromList ['b', 'f', 'q']) == fromList ['a', 'b', 'f', 'q'])
    && assert (insertBy compare 45.8 (fromList [-9, 3, 0, 1, 50, 100]) == (fromList [-9, 3, 0, 1, 45.8, 50, 100]))
    && assert (insertBy compare "z" (fromList ["a", "l", "p", "s"]) == fromList ["a", "l", "p", "s", "z"])
    && assert (insertBy compare "singleton" empty == array1 "singleton")   
    && assert (insertBy (flip compare) 'a' (fromList ['q', 'f', 'b']) == fromList ['q', 'f', 'b', 'a'])
    && assert (insertBy (flip compare) 45.8 (fromList [100, 50, 1, 0, 3, -9]) == fromList [100, 50, 45.8, 1, 0, 3, -9])
    && assert (insertBy (flip compare) "z" (fromList ["s", "p", "l", "a"]) == fromList ["z", "s", "p", "l", "a"])
    && assert (insertBy (flip compare) "singleton" empty == array1 "singleton");   

/**
 * This function takes an element and an array and inserts the element into the
 * array at the last position where it is still less than or equal to the next
 * element. All order comparisons are done using the {@link Prelude.compare@} class
 * method.
 * 
 * If the array is sorted before the call, the result will also be sorted.
 * 
 * @arg value the value to be inserted into the array.
 * @arg array the array.
 * @return a copy of the input array with the specified value inserted.
 * @see insertBy
 */
insert :: Ord a => a -> Array a -> Array a;
public insert =
    insertBy compare;

/* @example */
insertExamples :: Boolean;
insertExamples =
    assert (insert 'a' (fromList ['b', 'f', 'q']) == fromList ['a', 'b', 'f', 'q'])
    && assert (insert 45.8 (fromList [-9, 3, 0, 1, 50, 100]) == (fromList [-9, 3, 0, 1, 45.8, 50, 100]))
    && assert (insert "z" (fromList ["a", "l", "p", "s"]) == fromList ["a", "l", "p", "s", "z"])   
    && assert (insert "singleton" empty == array1 "singleton");   

/**
 * Returns whether {@code arrayToTest@} starts with the specified prefix using {@code eq@} as the notion of equality between 
 * elements of the prefix and elements of the arrayToTest.
 * 
 * @arg eq the equality comparison function to use in comparing the array elements for equality.
 * @arg prefix
 * @arg arrayToTest the array to be tested for starting with {@code prefix@}.
 * @return {@link True@} if {@code arrayToTest@} starts with the array {@code prefix@} using {@code eq@} for comparing array
 *         elements for equality.   
 */
startsWithBy :: (a -> b -> Boolean) -> Array a -> Array b -> Boolean;
public startsWithBy eq !prefix !arrayToTest =
    let
        prefixLength :: Int;
        prefixLength = eager $ length prefix;
        
        arrayLength :: Int;
        arrayLength = eager $ length arrayToTest;
        
        scan :: Int -> Boolean;
        scan !index =
            if index >= prefixLength then
                True
            else
                if eq (subscript prefix index) (subscript arrayToTest index) then
                    scan (index + 1)
                else
                    False;
    in
        if prefixLength > arrayLength then
            False
        else
            scan 0;

/* @example */
startsWithByExamples :: Boolean;
startsWithByExamples =
    assert (startsWithBy equals empty (fromList [8.0, 1, 2]) == True) 
    && assert (startsWithBy equals (fromList ['a', 'r', 'r']) (fromList ['a', 'r', 'r', 'a', 'y']) == True)
    && assert (startsWithBy equals (fromList ['a', 'r', 't']) (fromList ['a', 'r', 'r', 'a', 'y']) == False)
    && assert (startsWithBy equals (fromList ['a', 'r', 't']) (fromList ['a']) == False);

/**
 * Returns whether {@code arrayToTest@} starts with the specified prefix.
 *
 * @arg prefix
 * @arg arrayToTest the array to be tested for starting with {@code prefix@}. 
 * @return {@link True@} if {@code arrayToTest@} starts with the array {@code prefix@}.   
 * @see startsWithBy
 */    
startsWith :: Eq a => Array a -> Array a -> Boolean;
public startsWith =
    startsWithBy equals;

/* @example */
startsWithExamples :: Boolean;
startsWithExamples =
    assert (startsWith empty (fromList [8.0, 1, 2]) == True) 
    && assert (startsWith (fromList ['a', 'r', 'r']) (fromList ['a', 'r', 'r', 'a', 'y']) == True)
    && assert (startsWith (fromList ['a', 'r', 't']) (fromList ['a', 'r', 'r', 'a', 'y']) == False)
    && assert (startsWith (fromList ['a', 'r', 't']) (fromList ['a']) == False);

/**
 * Returns the array with the value at a specified offset replaced by a specified value.
 * Specifying a negative offset, or an offset larger than the last element of the array 
 * causes a runtime error to be signalled.
 * 
 * @arg index The index of the element to replace
 * @arg value The value to replace the element with
 * @arg array The array to replace an element of
 * @return a copy of {@code array@} with {@code value@} at {@code index@} instead of the original value.
 */
replaceAt :: Int -> a -> Array a -> Array a;
public replaceAt !index value !array =
    updateAt index value array;

/* @example */
replaceAtExamples :: Boolean;
replaceAtExamples =
    assert (replaceAt 2 'X' (fromList ['c', 'a', 'r', 't']) == fromList ['c', 'a', 'X', 't']);

/**
 * Applies the predicate to each element and returns the array 
 * where every element for which the predicate evaluated to {@link True@} is replaced by {@code replaceWithValue@}.
 * 
 * @arg array the array whose elements are to be checked and replaced.
 * @arg predicate a predicate to be applied to the elements of the array.
 * @arg replaceWithValue the value to replace existing elements in the array.
 * @return a copy of the array where every element for which the predicate evaluated to {@link True@} is replaced by
 *         {@code replaceWithValue@}.
 */
replaceAll :: Array a -> (a -> Boolean) -> a -> Array a;
public replaceAll !array predicate replaceWithValue =
    let
        size :: Int;
        size = eager $ length array;
    in
        if size == 0 then
            empty
        else
            let
                updatedArray :: Array a;
                updatedArray = eager $ makeDefaultInternal (elementType_fromNonEmptyArray array) size;
                
                //processElement :: Int -> Array a;
                processElement :: Int -> Array a;
                processElement !index =
                    if index >= size then
                        updatedArray
                    else if predicate (subscript array index) then
                        update updatedArray index replaceWithValue
                        `seq`
                        processElement (index + 1)
                    else
                        processElement (index + 1);
            in
                nonEmptyArrayCopy array 0 updatedArray 0 size
                `seq`
                processElement 0;

/* @example */
replaceAllExamples :: Boolean;
replaceAllExamples =
    let
        isNegative :: Num a => a -> Boolean;
        isNegative !x = Prelude.signum x == (-1);
        
        isObjectJust :: JObject -> Boolean;
        isObjectJust !obj = 
            Prelude.isJust (input obj :: Maybe Int);
        
        justObj :: Int -> JObject;
        justObj !x = output (Just x);
        
        nothingObj :: JObject;
        nothingObj = output (Nothing :: Maybe Int);
    in
        assert (replaceAll (fromList [True, False, True, False, True, False]) Prelude.not True == fromList [True, True, True, True, True, True])
        && assert (replaceAll empty Prelude.not True == empty)
        && assert (replaceAll (fromList ['a', 'B', 'c', 'D', 'e']) Char.isUpperCase 'X' == fromList ['a', 'X', 'c', 'X', 'e'])
        && assert (replaceAll (fromList [1 :: Byte, -2, 3, -4, 5]) isNegative 0 == fromList [1, 0, 3, 0, 5])
        && assert (replaceAll (fromList [1 :: Short, -2, 3, -4, 5]) isNegative 0 == fromList [1, 0, 3, 0, 5])
        && assert (replaceAll (fromList [1 :: Int, -2, 3, -4, 5]) isNegative 0 == fromList [1, 0, 3, 0, 5])
        && assert (replaceAll (fromList [1 :: Long, -2, 3, -4, 5]) isNegative 0 == fromList [1, 0, 3, 0, 5])
        && assert (replaceAll (fromList [1 :: Float, -2, 3, -4, 5]) isNegative 0 == fromList [1, 0, 3, 0, 5])
        && assert (replaceAll (fromList [1 :: Double, -2, 3, -4, 5]) isNegative 0 == fromList [1, 0, 3, 0, 5])
        && assert (replaceAll (fromList [Just 5 :: Maybe Int, Nothing, Just 10, Nothing]) Prelude.isJust Nothing == fromList [Nothing, Nothing, Nothing, Nothing])
        && assert (map input (replaceAll (fromList [justObj 5, nothingObj, nothingObj, justObj 10]) isObjectJust nothingObj) == fromList [Nothing :: Maybe Int, Nothing, Nothing, Nothing]) 
        ; 
/**
 * Replicates a array for a specified number of times.
 * 
 * @arg array the array.
 * @arg nCopies the number of copies to make.
 * @return an array of {@code nCopies@} of the array concatenated together.
 */
replicateArray :: Array a -> Int -> Array a;
public replicateArray !array !nCopies =
    if isEmpty array || nCopies <= 0 then
        empty
    else
        concatNonEmptyArrayInternal (elementType_fromNonEmptyArray array) (Prelude.replicate nCopies array);

/* @example */
replicateArrayExamples :: Boolean;
replicateArrayExamples =
    assert (replicateArray (fromList ["orange", "apple", "pear"]) 3 == fromList ["orange", "apple", "pear", "orange", "apple", "pear", "orange", "apple", "pear"])
    && assert (replicateArray (empty :: Array Int) 50 == empty)
    && assert (replicateArray (fromList ['a', 'b', 'c']) 0 == empty)
    ;

/**
 * Creates an {@code Array@} calling a function for each of the indices in the resultant array 
 *
 * @arg size The number of items to include in the array
 * @arg itemFunction A function applied for [0, 1, 2, ...  {@code size@}-1].  
 * @return an array of {@code a@}.
 * @see Array.Array
 */
makeArrayFromIndices :: Int -> (Int -> a) -> Array a;
public makeArrayFromIndices !size itemFunction =
    if size == 0 then
        empty
    else
        let
            firstResult = itemFunction 0;
            
            resultArray :: Array a;
            resultArray = eager $ makeDefaultInternal (elementType_fromValue firstResult) size;
            
            makeArrayHelper :: Int -> Array a;
            makeArrayHelper !index =
                if index < size then
                    update resultArray index (itemFunction index)
                    `seq`
                    makeArrayHelper (index + 1)
                else
                    resultArray;      
        in
            update resultArray 0 firstResult
            `seq`
            makeArrayHelper 1; 

/* @example */
makeArrayFromIndicesExamples :: Boolean;
makeArrayFromIndicesExamples = 
    assert (
        (makeArrayFromIndices 4 Prelude.intToString ) == (array4 "0" "1" "2" "3") &&
        (makeArrayFromIndices 0 (\x->x) ) == array0
    );


/**
 * Periodizes an array at the specified frequency, returning an array of arrays, one for each modulo of the frequency.
 * 
 * @arg frequency the frequency.
 * @arg array the array to be periodized.
 * @return an array of arrays, one for each modulo of the frequency.
 */
periodize :: Int -> Array a -> Array (Array a);
public periodize !frequency !array =
    if frequency > 0 then
        let 
            lengthCalc = length array  + frequency - 1;
        in                
            makeArrayFromIndices (Prelude.min frequency (length array)) (\!i -> makeArrayFromIndices ( (lengthCalc - i) / frequency) (\!j -> subscript array (j * frequency + i)))
    else
        error "The frequency must be positive.";


/* @example */
periodizeExamples :: Boolean;
periodizeExamples =
    assert ((periodize 2 (fromList [1.0, 2, 3, 4, 5, 6, 7])) == fromList [ fromList [1, 3, 5, 7], fromList [2, 4, 6]] )
    && assert ((periodize 3 (fromList [3.0, 1, 4, 1, 5, 9, 2, 6])) == fromList [ fromList [3, 1, 2], fromList[1, 5, 6], fromList [4, 9] ] )
    && assert ((periodize 3 (fromList [3.0, 1, 4, 1, 5, 9, 2, 6, 7])) == fromList [ fromList [3, 1, 2], fromList[1, 5, 6], fromList [4, 9, 7] ] )
    && assert ((periodize 3 (fromList [3.0])) == fromList [ fromList [3] ] )
    && assert ((periodize 3 (fromList ([]::[Int]))) == fromList [ ] )
    ;
        

/**
 * Chops up an Array into equals subarrays of length {@code chopLength@}.
 * 
 * @arg chopLength the length of the resulting sublists.
 * @arg arrayToChop the list to be chopped.
 * @return an array of the subarrays.
 */
chop :: Int -> Array a -> Array (Array a);
public chop !chopLength !arrayToChop =
    if chopLength <= 0 then
        error "The chop length must be greater than zero."
    else
        let
            size :: Int; // the size of the initial array
            size = eager (length arrayToChop);

            // to work out the number of slices we need to add on 1 if 
            // the size doesn't divide exactly into the size
            lastSlice :: Int;
            lastSlice = if ((size % chopLength) != 0) then 1 else 0;
            
            sliceCount :: Int;
            sliceCount = (size / chopLength) + lastSlice;
            
            // function used to create the sub arrays for the new array
            chopper index =
                let
                    start :: Int;
                    start = index * chopLength;
                    
                    end :: Int;
                    end = min size (start + chopLength); // make sure we don't go off the end  
                in
                    subArray arrayToChop start end; 
        in
            makeArrayFromIndices sliceCount chopper;            

/* @example */
chopExamples :: Boolean;
chopExamples =
    assert ((chop 3 (fromList [10.0, 20, 30, 40, 50, 60, 70, 80, 90, 100])) == (fromList [(fromList [10, 20, 30]),(fromList [40, 50, 60]),(fromList [70, 80, 90]),(fromList [100])]))
    && assert ((chop 100 (fromList [10.0, 20, 30, 40, 50, 60, 70, 80, 90, 100])) == (fromList [(fromList [10, 20, 30, 40, 50, 60, 70, 80, 90, 100])]))
    ;      

//strictTests = subscript (fromList [trace "a" 2.0, trace "b" 3.0, trace "c" 4.0]) 0;
//strictTests = subscript (fromList [trace "a" 2.0, trace "b" 3.0, trace "c" 4.0]) 2;
//strictTests = subscript (fromList [trace "a" [2.0], trace "b" [error "don't call this"], trace "c" [4.0]]) 2;

//todoBI test strictness property of array elements

/*
//todoBI
-enum types as well as foreing types whose implementation java type is a Java primitive type should be able to take advantage of
 the unboxed representation. 
-see the Appendable instance declaration for Array. It would be nice if the class methods in certain cases could have a more general type.
 */    

      
/**
 * An Array version of the regular {@code concat@} function
 * 
 * @arg array The Array we're collapsing to a single value
 * @see Prelude.concat, Array.Array
 */
concat :: Appendable a => Array a -> a;
public concat !array =
    if isEmpty array then
        empty
    else
        foldRight1 append array;

/* @example */
concatExamples :: Boolean;
concatExamples = 
    assert (
        (concat array0) == "" &&
        (concat (array2 "fear" "and")) == "fearand" &&
        (concat (array1 ["loathing"])) == ["loathing"] && 
        (concat (array2 (array1 "in") (array1 "lasvegas"))) == (array2 "in" "lasvegas") &&
        (concat (array2 "fear" "and")) == (Prelude.concat (List.list2 "fear" "and")) && 
        (concat (array1 ["loathing"])) == (Prelude.concat (List.list1 ["loathing"])) &&
        (concat (array2 (array1 "in") (array1 "lasvegas"))) == (Prelude.concat (List.list2 (array1 "in") (array1 "lasvegas")))
        );
    

/**
 * The {@link Arbitrary@} instance for the {@link typeConstructor = Array@} type. This creates Arrays
 * using the fromList method.
 */
instance Arbitrary a => Arbitrary (Array a) where
    arbitrary = arbitraryArray;
    coarbitrary = coarbitraryArray;
   ;

arbitraryArray :: Arbitrary a => Gen (Array a);
arbitraryArray = 
    QuickCheck.mapGen Array.fromList arbitrary;
 
coarbitraryArray :: Arbitrary a => (Array a)-> Gen b -> Gen b;
coarbitraryArray array = 
    coarbitrary $ Array.toList array; 

/**
 * Unit test for the {@code Array@} module.
 * @return {@link True@} if the unit tests for the {@code Array@} module pass.
 */
/* @test */
testModule :: Boolean;
public testModule =  
    assert allExamples
    && assert alternateExamples
    && assert andArrayExamples
    && assert anyExamples    
    && assert appendExamples       
    && assert binarySearchExamples
    && assert binarySearchByExamples    
    && assert chopExamples
    && assert concatArrayExamples
    && assert concatExamples
    && assert deleteAtExamples 
    && assert deleteExamples
    && assert deleteByExamples
    && assert deleteRangeExamples
    && assert dropExamples
    && assert dropWhileExamples    
    && assert elemIndexExamples
    && assert elemIndicesExamples
    && assert eqArrayInstanceExamples
    && assert equalsPrimitiveExamples
    && assert comparePrimitiveExamples
    && assert filterExamples
    && assert filterIndexedExamples    
    && assert findExamples 
    && assert findIndexExamples
    && assert findIndicesExamples
    && assert foldRight1Examples
    && assert foldRightExamples
    && assert fromListWithExamples
    && assert fromStringExamples  
    && assert inputArrayExamples    
    && assert inputPrimitiveExamples    
    && assert insertArrayAtExamples
    && assert insertByExamples
    && assert insertExamples   
    && assert isElemByExamples
    && assert lastExamples
    && assert lastIndexOfExamples
    && assert lengthExamples      
    && assert makeArrayFromIndicesExamples
    && assert mapExamples
    && assert mapIndexedExamples    
    && assert maximumByExamples
    && assert maximumExamples
    && assert mergeExamples
    && assert mergeByExamples
    && assert minimumByExamples
    && assert minimumExamples    
    && assert orArrayExamples    
    && assert replicateArrayExamples
    && assert showArrayInstanceExamples      
    && assert sortExamples
    && assert sortByExamples
    && assert startsWithByExamples
    && assert startsWithExamples
    && assert subscriptExamples  
    && assert sumExamples           
    && assert toListExamples   
    && assert toListWithExamples
    && assert toStringExamples
    && assert takeExamples
    && assert takeWhileExamples
    && assert unzipExamples    
    && assert unzip3Examples    
    && assert unzip4Examples    
    && assert updateAtExamples       
    && assert zipExamples
    && assert zip3Examples
    && assert zip4Examples
    && assert zipWithExamples    
    && assert zipWith3Examples    
    && assert zipWith4Examples 
    && assert periodizeExamples
    ; 
//please leave testModule last! Also sort the tests. It makes it easy to see what tests are hooked up.
